#----------------------------------------------------------------------
#
# Contents of GUC tables.
#
# See src/backend/utils/misc/README for design notes.
#
# Portions Copyright (c) 2000-2025, PostgreSQL Global Development Group
#
# src/backend/utils/misc/guc_parameters.dat
#
#----------------------------------------------------------------------

[

# TO ADD AN OPTION:
#
# 1. Declare a global variable of type bool, int, double, or char* and
#    make use of it.
#
# 2. Decide at what times it's safe to set the option. See guc.h for
#    details.
#
# 3. Decide on a name, a default value, upper and lower bounds (if
#    applicable), etc.
#
# 4. Add a record below.
#
# 5. Add it to src/backend/utils/misc/postgresql.conf.sample, if
#    appropriate.
#
# 6. Don't forget to document the option (at least in config.sgml).
#
# 7. If it's a new GUC_LIST_QUOTE option, you must add it to
#    variable_is_guc_list_quote() in src/bin/pg_dump/dumputils.c.

{ name => 'enable_seqscan', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of sequential-scan plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_seqscan',
  boot_val => 'true',
},

{ name => 'enable_indexscan', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of index-scan plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_indexscan',
  boot_val => 'true',
},

{ name => 'enable_indexonlyscan', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of index-only-scan plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_indexonlyscan',
  boot_val => 'true',
},

{ name => 'enable_bitmapscan', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of bitmap-scan plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_bitmapscan',
  boot_val => 'true',
},

{ name => 'enable_tidscan', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of TID scan plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_tidscan',
  boot_val => 'true',
},

{ name => 'enable_sort', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of explicit sort steps.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_sort',
  boot_val => 'true',
},

{ name => 'enable_incremental_sort', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of incremental sort steps.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_incremental_sort',
  boot_val => 'true',
},

{ name => 'enable_hashagg', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of hashed aggregation plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_hashagg',
  boot_val => 'true',
},

{ name => 'enable_material', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of materialization.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_material',
  boot_val => 'true',
},

{ name => 'enable_memoize', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of memoization.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_memoize',
  boot_val => 'true',
},

{ name => 'enable_nestloop', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of nested-loop join plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_nestloop',
  boot_val => 'true',
},

{ name => 'enable_mergejoin', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of merge join plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_mergejoin',
  boot_val => 'true',
},

{ name => 'enable_hashjoin', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of hash join plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_hashjoin',
  boot_val => 'true',
},

{ name => 'enable_gathermerge', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of gather merge plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_gathermerge',
  boot_val => 'true',
},

{ name => 'enable_partitionwise_join', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables partitionwise join.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_partitionwise_join',
  boot_val => 'false',
},

{ name => 'enable_partitionwise_aggregate', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables partitionwise aggregation and grouping.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_partitionwise_aggregate',
  boot_val => 'false',
},

{ name => 'enable_eager_aggregate', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables eager aggregation.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_eager_aggregate',
  boot_val => 'true',
},

{ name => 'enable_parallel_append', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of parallel append plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_parallel_append',
  boot_val => 'true',
},

{ name => 'enable_parallel_hash', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of parallel hash plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_parallel_hash',
  boot_val => 'true',
},

{ name => 'enable_partition_pruning', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables plan-time and execution-time partition pruning.',
  long_desc => 'Allows the query planner and executor to compare partition bounds to conditions in the query to determine which partitions must be scanned.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_partition_pruning',
  boot_val => 'true',
},

{ name => 'enable_presorted_aggregate', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s ability to produce plans that provide presorted input for ORDER BY / DISTINCT aggregate functions.',
  long_desc => 'Allows the query planner to build plans that provide presorted input for aggregate functions with an ORDER BY / DISTINCT clause.  When disabled, implicit sorts are always performed during execution.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_presorted_aggregate',
  boot_val => 'true',
},

{ name => 'enable_async_append', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables the planner\'s use of async append plans.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_async_append',
  boot_val => 'true',
},

{ name => 'enable_self_join_elimination', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables removal of unique self-joins.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_self_join_elimination',
  boot_val => 'true',
},

{ name => 'enable_group_by_reordering', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables reordering of GROUP BY keys.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_group_by_reordering',
  boot_val => 'true',
},

{ name => 'enable_distinct_reordering', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables reordering of DISTINCT keys.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_distinct_reordering',
  boot_val => 'true',
},

{ name => 'geqo', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'Enables genetic query optimization.',
  long_desc => 'This algorithm attempts to do planning without exhaustive searching.',
  flags => 'GUC_EXPLAIN',
  variable => 'enable_geqo',
  boot_val => 'true',
},

# Not for general use --- used by SET SESSION AUTHORIZATION and SET
# ROLE
{ name => 'is_superuser', type => 'bool', context => 'PGC_INTERNAL', group => 'UNGROUPED',
  short_desc => 'Shows whether the current user is a superuser.',
  flags => 'GUC_REPORT | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_ALLOW_IN_PARALLEL',
  variable => 'current_role_is_superuser',
  boot_val => 'false',
},

# This setting itself cannot be set by ALTER SYSTEM to avoid an
# operator turning this setting off by using ALTER SYSTEM, without a
# way to turn it back on.
{ name => 'allow_alter_system', type => 'bool', context => 'PGC_SIGHUP', group => 'COMPAT_OPTIONS_OTHER',
  short_desc => 'Allows running the ALTER SYSTEM command.',
  long_desc => 'Can be set to off for environments where global configuration changes should be made using a different method.',
  flags => 'GUC_DISALLOW_IN_AUTO_FILE',
  variable => 'AllowAlterSystem',
  boot_val => 'true',
},

{ name => 'bonjour', type => 'bool', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Enables advertising the server via Bonjour.',
  variable => 'enable_bonjour',
  boot_val => 'false',
  check_hook => 'check_bonjour',
},

{ name => 'track_commit_timestamp', type => 'bool', context => 'PGC_POSTMASTER', group => 'REPLICATION_SENDING',
  short_desc => 'Collects transaction commit time.',
  variable => 'track_commit_timestamp',
  boot_val => 'false',
},

{ name => 'ssl', type => 'bool', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Enables SSL connections.',
  variable => 'EnableSSL',
  boot_val => 'false',
  check_hook => 'check_ssl',
},

{ name => 'ssl_passphrase_command_supports_reload', type => 'bool', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Controls whether "ssl_passphrase_command" is called during server reload.',
  variable => 'ssl_passphrase_command_supports_reload',
  boot_val => 'false',
},

{ name => 'ssl_prefer_server_ciphers', type => 'bool', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Give priority to server ciphersuite order.',
  variable => 'SSLPreferServerCiphers',
  boot_val => 'true',
},

{ name => 'fsync', type => 'bool', context => 'PGC_SIGHUP', group => 'WAL_SETTINGS',
  short_desc => 'Forces synchronization of updates to disk.',
  long_desc => 'The server will use the fsync() system call in several places to make sure that updates are physically written to disk. This ensures that a database cluster will recover to a consistent state after an operating system or hardware crash.',
  variable => 'enableFsync',
  boot_val => 'true',
},

{ name => 'ignore_checksum_failure', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Continues processing after a checksum failure.',
  long_desc => 'Detection of a checksum failure normally causes PostgreSQL to report an error, aborting the current transaction. Setting ignore_checksum_failure to true causes the system to ignore the failure (but still report a warning), and continue processing. This behavior could cause crashes or other serious problems. Only has an effect if checksums are enabled.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'ignore_checksum_failure',
  boot_val => 'false',
},

{ name => 'zero_damaged_pages', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Continues processing past damaged page headers.',
  long_desc => 'Detection of a damaged page header normally causes PostgreSQL to report an error, aborting the current transaction. Setting "zero_damaged_pages" to true causes the system to instead report a warning, zero out the damaged page, and continue processing. This behavior will destroy data, namely all the rows on the damaged page.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'zero_damaged_pages',
  boot_val => 'false',
},

{ name => 'ignore_invalid_pages', type => 'bool', context => 'PGC_POSTMASTER', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Continues recovery after an invalid pages failure.',
  long_desc => 'Detection of WAL records having references to invalid pages during recovery causes PostgreSQL to raise a PANIC-level error, aborting the recovery. Setting "ignore_invalid_pages" to true causes the system to ignore invalid page references in WAL records (but still report a warning), and continue recovery. This behavior may cause crashes, data loss, propagate or hide corruption, or other serious problems. Only has an effect during recovery or in standby mode.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'ignore_invalid_pages',
  boot_val => 'false',
},

{ name => 'full_page_writes', type => 'bool', context => 'PGC_SIGHUP', group => 'WAL_SETTINGS',
  short_desc => 'Writes full pages to WAL when first modified after a checkpoint.',
  long_desc => 'A page write in process during an operating system crash might be only partially written to disk.  During recovery, the row changes stored in WAL are not enough to recover.  This option writes pages when first modified after a checkpoint to WAL so full recovery is possible.',
  variable => 'fullPageWrites',
  boot_val => 'true',
},

{ name => 'wal_log_hints', type => 'bool', context => 'PGC_POSTMASTER', group => 'WAL_SETTINGS',
  short_desc => 'Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modification.',
  variable => 'wal_log_hints',
  boot_val => 'false',
},

{ name => 'wal_init_zero', type => 'bool', context => 'PGC_SUSET', group => 'WAL_SETTINGS',
  short_desc => 'Writes zeroes to new WAL files before first use.',
  variable => 'wal_init_zero',
  boot_val => 'true',
},

{ name => 'wal_recycle', type => 'bool', context => 'PGC_SUSET', group => 'WAL_SETTINGS',
  short_desc => 'Recycles WAL files by renaming them.',
  variable => 'wal_recycle',
  boot_val => 'true',
},

{ name => 'log_checkpoints', type => 'bool', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Logs each checkpoint.',
  variable => 'log_checkpoints',
  boot_val => 'true',
},

{ name => 'trace_connection_negotiation', type => 'bool', context => 'PGC_POSTMASTER', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Logs details of pre-authentication connection handshake.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_connection_negotiation',
  boot_val => 'false',
},

{ name => 'log_disconnections', type => 'bool', context => 'PGC_SU_BACKEND', group => 'LOGGING_WHAT',
  short_desc => 'Logs end of a session, including duration.',
  variable => 'Log_disconnections',
  boot_val => 'false',
},

{ name => 'log_replication_commands', type => 'bool', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs each replication command.',
  variable => 'log_replication_commands',
  boot_val => 'false',
},

{ name => 'debug_assertions', type => 'bool', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows whether the running server has assertion checks enabled.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'assert_enabled',
  boot_val => 'DEFAULT_ASSERT_ENABLED',
},

{ name => 'exit_on_error', type => 'bool', context => 'PGC_USERSET', group => 'ERROR_HANDLING_OPTIONS',
  short_desc => 'Terminate session on any error.',
  variable => 'ExitOnAnyError',
  boot_val => 'false',
},

{ name => 'restart_after_crash', type => 'bool', context => 'PGC_SIGHUP', group => 'ERROR_HANDLING_OPTIONS',
  short_desc => 'Reinitialize server after backend crash.',
  variable => 'restart_after_crash',
  boot_val => 'true',
},

{ name => 'remove_temp_files_after_crash', type => 'bool', context => 'PGC_SIGHUP', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Remove temporary files after backend crash.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'remove_temp_files_after_crash',
  boot_val => 'true',
},

{ name => 'send_abort_for_crash', type => 'bool', context => 'PGC_SIGHUP', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Send SIGABRT not SIGQUIT to child processes after backend crash.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'send_abort_for_crash',
  boot_val => 'false',
},

{ name => 'send_abort_for_kill', type => 'bool', context => 'PGC_SIGHUP', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Send SIGABRT not SIGKILL to stuck child processes.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'send_abort_for_kill',
  boot_val => 'false',
},

{ name => 'log_duration', type => 'bool', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs the duration of each completed SQL statement.',
  variable => 'log_duration',
  boot_val => 'false',
},

{ name => 'debug_copy_parse_plan_trees', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Set this to force all parse and plan trees to be passed through copyObject(), to facilitate catching errors and omissions in copyObject().',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Debug_copy_parse_plan_trees',
  boot_val => 'DEFAULT_DEBUG_COPY_PARSE_PLAN_TREES',
  ifdef => 'DEBUG_NODE_TESTS_ENABLED',
},

{ name => 'debug_write_read_parse_plan_trees', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Set this to force all parse and plan trees to be passed through outfuncs.c/readfuncs.c, to facilitate catching errors and omissions in those modules.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Debug_write_read_parse_plan_trees',
  boot_val => 'DEFAULT_DEBUG_READ_WRITE_PARSE_PLAN_TREES',
  ifdef => 'DEBUG_NODE_TESTS_ENABLED',
},

{ name => 'debug_raw_expression_coverage_test', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Set this to force all raw parse trees for DML statements to be scanned by raw_expression_tree_walker(), to facilitate catching errors and omissions in that function.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Debug_raw_expression_coverage_test',
  boot_val => 'DEFAULT_DEBUG_RAW_EXPRESSION_COVERAGE_TEST',
  ifdef => 'DEBUG_NODE_TESTS_ENABLED',
},

{ name => 'debug_print_raw_parse', type => 'bool', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs each query\'s raw parse tree.',
  variable => 'Debug_print_raw_parse',
  boot_val => 'false',
},

{ name => 'debug_print_parse', type => 'bool', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs each query\'s parse tree.',
  variable => 'Debug_print_parse',
  boot_val => 'false',
},

{ name => 'debug_print_rewritten', type => 'bool', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs each query\'s rewritten parse tree.',
  variable => 'Debug_print_rewritten',
  boot_val => 'false',
},

{ name => 'debug_print_plan', type => 'bool', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs each query\'s execution plan.',
  variable => 'Debug_print_plan',
  boot_val => 'false',
},

{ name => 'debug_pretty_print', type => 'bool', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Indents parse and plan tree displays.',
  variable => 'Debug_pretty_print',
  boot_val => 'true',
},

{ name => 'log_parser_stats', type => 'bool', context => 'PGC_SUSET', group => 'STATS_MONITORING',
  short_desc => 'Writes parser performance statistics to the server log.',
  variable => 'log_parser_stats',
  boot_val => 'false',
  check_hook => 'check_stage_log_stats',
},

{ name => 'log_planner_stats', type => 'bool', context => 'PGC_SUSET', group => 'STATS_MONITORING',
  short_desc => 'Writes planner performance statistics to the server log.',
  variable => 'log_planner_stats',
  boot_val => 'false',
  check_hook => 'check_stage_log_stats',
},

{ name => 'log_executor_stats', type => 'bool', context => 'PGC_SUSET', group => 'STATS_MONITORING',
  short_desc => 'Writes executor performance statistics to the server log.',
  variable => 'log_executor_stats',
  boot_val => 'false',
  check_hook => 'check_stage_log_stats',
},

{ name => 'log_statement_stats', type => 'bool', context => 'PGC_SUSET', group => 'STATS_MONITORING',
  short_desc => 'Writes cumulative performance statistics to the server log.',
  variable => 'log_statement_stats',
  boot_val => 'false',
  check_hook => 'check_log_stats',
},

{ name => 'log_btree_build_stats', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Logs system resource usage statistics (memory and CPU) on various B-tree operations.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'log_btree_build_stats',
  boot_val => 'false',
  ifdef => 'BTREE_BUILD_STATS',
},

{ name => 'track_activities', type => 'bool', context => 'PGC_SUSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Collects information about executing commands.',
  long_desc => 'Enables the collection of information on the currently executing command of each session, along with the time at which that command began execution.',
  variable => 'pgstat_track_activities',
  boot_val => 'true',
},

{ name => 'track_counts', type => 'bool', context => 'PGC_SUSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Collects statistics on database activity.',
  variable => 'pgstat_track_counts',
  boot_val => 'true',
},

{ name => 'track_cost_delay_timing', type => 'bool', context => 'PGC_SUSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Collects timing statistics for cost-based vacuum delay.',
  variable => 'track_cost_delay_timing',
  boot_val => 'false',
},

{ name => 'track_io_timing', type => 'bool', context => 'PGC_SUSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Collects timing statistics for database I/O activity.',
  variable => 'track_io_timing',
  boot_val => 'false',
},

{ name => 'track_wal_io_timing', type => 'bool', context => 'PGC_SUSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Collects timing statistics for WAL I/O activity.',
  variable => 'track_wal_io_timing',
  boot_val => 'false',
},

{ name => 'update_process_title', type => 'bool', context => 'PGC_SUSET', group => 'PROCESS_TITLE',
  short_desc => 'Updates the process title to show the active SQL command.',
  long_desc => 'Enables updating of the process title every time a new SQL command is received by the server.',
  variable => 'update_process_title',
  boot_val => 'DEFAULT_UPDATE_PROCESS_TITLE',
},

{ name => 'autovacuum', type => 'bool', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Starts the autovacuum subprocess.',
  variable => 'autovacuum_start_daemon',
  boot_val => 'true',
},

{ name => 'trace_notify', type => 'bool', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Generates debugging output for LISTEN and NOTIFY.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_notify',
  boot_val => 'false',
},

{ name => 'trace_locks', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Emits information about lock usage.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_locks',
  boot_val => 'false',
  ifdef => 'LOCK_DEBUG',
},

{ name => 'trace_userlocks', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Emits information about user lock usage.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_userlocks',
  boot_val => 'false',
  ifdef => 'LOCK_DEBUG',
},

{ name => 'trace_lwlocks', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Emits information about lightweight lock usage.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_lwlocks',
  boot_val => 'false',
  ifdef => 'LOCK_DEBUG',
},

{ name => 'debug_deadlocks', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Dumps information about all current locks when a deadlock timeout occurs.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Debug_deadlocks',
  boot_val => 'false',
  ifdef => 'LOCK_DEBUG',
},

{ name => 'log_lock_waits', type => 'bool', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs long lock waits.',
  variable => 'log_lock_waits',
  boot_val => 'true',
},

{ name => 'log_lock_failures', type => 'bool', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Logs lock failures.',
  variable => 'log_lock_failures',
  boot_val => 'false',
},

{ name => 'log_recovery_conflict_waits', type => 'bool', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Logs standby recovery conflict waits.',
  variable => 'log_recovery_conflict_waits',
  boot_val => 'false',
},

{ name => 'log_hostname', type => 'bool', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Logs the host name in the connection logs.',
  long_desc => 'By default, connection logs only show the IP address of the connecting host. If you want them to show the host name you can turn this on, but depending on your host name resolution setup it might impose a non-negligible performance penalty.',
  variable => 'log_hostname',
  boot_val => 'false',
},

{ name => 'transform_null_equals', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_OTHER',
  short_desc => 'Treats "expr=NULL" as "expr IS NULL".',
  long_desc => 'When turned on, expressions of the form expr = NULL (or NULL = expr) are treated as expr IS NULL, that is, they return true if expr evaluates to the null value, and false otherwise. The correct behavior of expr = NULL is to always return null (unknown).',
  variable => 'Transform_null_equals',
  boot_val => 'false',
},

{ name => 'default_transaction_read_only', type => 'bool', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the default read-only status of new transactions.',
  flags => 'GUC_REPORT',
  variable => 'DefaultXactReadOnly',
  boot_val => 'false',
},

{ name => 'transaction_read_only', type => 'bool', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the current transaction\'s read-only status.',
  flags => 'GUC_NO_RESET | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'XactReadOnly',
  boot_val => 'false',
  check_hook => 'check_transaction_read_only',
},

{ name => 'default_transaction_deferrable', type => 'bool', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the default deferrable status of new transactions.',
  variable => 'DefaultXactDeferrable',
  boot_val => 'false',
},

{ name => 'transaction_deferrable', type => 'bool', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures.',
  flags => 'GUC_NO_RESET | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'XactDeferrable',
  boot_val => 'false',
  check_hook => 'check_transaction_deferrable',
},

{ name => 'row_security', type => 'bool', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Enables row security.',
  long_desc => 'When enabled, row security will be applied to all users.',
  variable => 'row_security',
  boot_val => 'true',
},

{ name => 'check_function_bodies', type => 'bool', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Check routine bodies during CREATE FUNCTION and CREATE PROCEDURE.',
  variable => 'check_function_bodies',
  boot_val => 'true',
},

{ name => 'array_nulls', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'Enables input of NULL elements in arrays.',
  long_desc => 'When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally.',
  variable => 'Array_nulls',
  boot_val => 'true',
},

# WITH OIDS support, and consequently default_with_oids, was removed
# in PostgreSQL 12, but we tolerate the parameter being set to false
# to avoid unnecessarily breaking older dump files.
{ name => 'default_with_oids', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'WITH OIDS is no longer supported; this can only be false.',
  flags => 'GUC_NO_SHOW_ALL | GUC_NOT_IN_SAMPLE',
  variable => 'default_with_oids',
  boot_val => 'false',
  check_hook => 'check_default_with_oids',
},

{ name => 'logging_collector', type => 'bool', context => 'PGC_POSTMASTER', group => 'LOGGING_WHERE',
  short_desc => 'Start a subprocess to capture stderr, csvlog and/or jsonlog into log files.',
  variable => 'Logging_collector',
  boot_val => 'false',
},

{ name => 'log_truncate_on_rotation', type => 'bool', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Truncate existing log files of same name during log rotation.',
  variable => 'Log_truncate_on_rotation',
  boot_val => 'false',
},

{ name => 'trace_sort', type => 'bool', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Emit information about resource usage in sorting.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'trace_sort',
  boot_val => 'false',
},

# this is undocumented because not exposed in a standard build
{ name => 'trace_syncscan', type => 'bool', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Generate debugging output for synchronized scanning.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'trace_syncscan',
  boot_val => 'false',
  ifdef => 'TRACE_SYNCSCAN',
},

# this is undocumented because not exposed in a standard build
{ name => 'optimize_bounded_sort', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_METHOD',
  short_desc => 'Enables bounded sorting using heap sort.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_EXPLAIN',
  variable => 'optimize_bounded_sort',
  boot_val => 'true',
  ifdef => 'DEBUG_BOUNDED_SORT',
},

{ name => 'wal_debug', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Emit WAL-related debugging output.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'XLOG_DEBUG',
  boot_val => 'false',
  ifdef => 'WAL_DEBUG',
},

{ name => 'integer_datetimes', type => 'bool', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows whether datetimes are integer based.',
  flags => 'GUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'integer_datetimes',
  boot_val => 'true',
},

{ name => 'krb_caseins_users', type => 'bool', context => 'PGC_SIGHUP', group => 'CONN_AUTH_AUTH',
  short_desc => 'Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive.',
  variable => 'pg_krb_caseins_users',
  boot_val => 'false',
},

{ name => 'gss_accept_delegation', type => 'bool', context => 'PGC_SIGHUP', group => 'CONN_AUTH_AUTH',
  short_desc => 'Sets whether GSSAPI delegation should be accepted from the client.',
  variable => 'pg_gss_accept_delegation',
  boot_val => 'false',
},

{ name => 'escape_string_warning', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'Warn about backslash escapes in ordinary string literals.',
  variable => 'escape_string_warning',
  boot_val => 'true',
},

{ name => 'standard_conforming_strings', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'Causes \'...\' strings to treat backslashes literally.',
  flags => 'GUC_REPORT',
  variable => 'standard_conforming_strings',
  boot_val => 'true',
},

{ name => 'synchronize_seqscans', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'Enables synchronized sequential scans.',
  variable => 'synchronize_seqscans',
  boot_val => 'true',
},

{ name => 'recovery_target_inclusive', type => 'bool', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Sets whether to include or exclude transaction with recovery target.',
  variable => 'recoveryTargetInclusive',
  boot_val => 'true',
},

{ name => 'summarize_wal', type => 'bool', context => 'PGC_SIGHUP', group => 'WAL_SUMMARIZATION',
  short_desc => 'Starts the WAL summarizer process to enable incremental backup.',
  variable => 'summarize_wal',
  boot_val => 'false',
},

{ name => 'hot_standby', type => 'bool', context => 'PGC_POSTMASTER', group => 'REPLICATION_STANDBY',
  short_desc => 'Allows connections and queries during recovery.',
  variable => 'EnableHotStandby',
  boot_val => 'true',
},

{ name => 'hot_standby_feedback', type => 'bool', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Allows feedback from a hot standby to the primary that will avoid query conflicts.',
  variable => 'hot_standby_feedback',
  boot_val => 'false',
},

{ name => 'in_hot_standby', type => 'bool', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows whether hot standby is currently active.',
  flags => 'GUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'in_hot_standby_guc',
  boot_val => 'false',
  show_hook => 'show_in_hot_standby',
},

{ name => 'allow_system_table_mods', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Allows modifications of the structure of system tables.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'allowSystemTableMods',
  boot_val => 'false',
},

{ name => 'ignore_system_indexes', type => 'bool', context => 'PGC_BACKEND', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Disables reading from system indexes.',
  long_desc => 'It does not prevent updating the indexes, so it is safe to use.  The worst consequence is slowness.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'IgnoreSystemIndexes',
  boot_val => 'false',
},

{ name => 'allow_in_place_tablespaces', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Allows tablespaces directly inside pg_tblspc, for testing.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'allow_in_place_tablespaces',
  boot_val => 'false',
},

{ name => 'lo_compat_privileges', type => 'bool', context => 'PGC_SUSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'Enables backward compatibility mode for privilege checks on large objects.',
  long_desc => 'Skips privilege checks when reading or modifying large objects, for compatibility with PostgreSQL releases prior to 9.0.',
  variable => 'lo_compat_privileges',
  boot_val => 'false',
},

{ name => 'quote_all_identifiers', type => 'bool', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'When generating SQL fragments, quote all identifiers.',
  variable => 'quote_all_identifiers',
  boot_val => 'false',
},

{ name => 'data_checksums', type => 'bool', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows whether data checksums are turned on for this cluster.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_RUNTIME_COMPUTED',
  variable => 'data_checksums',
  boot_val => 'false',
},

{ name => 'syslog_sequence_numbers', type => 'bool', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Add sequence number to syslog messages to avoid duplicate suppression.',
  variable => 'syslog_sequence_numbers',
  boot_val => 'true',
},

{ name => 'syslog_split_messages', type => 'bool', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Split messages sent to syslog by lines and to fit into 1024 bytes.',
  variable => 'syslog_split_messages',
  boot_val => 'true',
},

{ name => 'parallel_leader_participation', type => 'bool', context => 'PGC_USERSET', group => 'RESOURCES_WORKER_PROCESSES',
  short_desc => 'Controls whether Gather and Gather Merge also run subplans.',
  long_desc => 'Should gather nodes also run subplans or just gather tuples?',
  flags => 'GUC_EXPLAIN',
  variable => 'parallel_leader_participation',
  boot_val => 'true',
},

{ name => 'jit', type => 'bool', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Allow JIT compilation.',
  flags => 'GUC_EXPLAIN',
  variable => 'jit_enabled',
  boot_val => 'true',
},

# This is not guaranteed to be available, but given it's a developer
# oriented option, it doesn't seem worth adding code checking
# availability.
{ name => 'jit_debugging_support', type => 'bool', context => 'PGC_SU_BACKEND', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Register JIT-compiled functions with debugger.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'jit_debugging_support',
  boot_val => 'false',
},

{ name => 'jit_dump_bitcode', type => 'bool', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Write out LLVM bitcode to facilitate JIT debugging.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'jit_dump_bitcode',
  boot_val => 'false',
},

{ name => 'jit_expressions', type => 'bool', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Allow JIT compilation of expressions.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'jit_expressions',
  boot_val => 'true',
},

# This is not guaranteed to be available, but given it's a developer
# oriented option, it doesn't seem worth adding code checking
# availability.
{ name => 'jit_profiling_support', type => 'bool', context => 'PGC_SU_BACKEND', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Register JIT-compiled functions with perf profiler.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'jit_profiling_support',
  boot_val => 'false',
},

{ name => 'jit_tuple_deforming', type => 'bool', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Allow JIT compilation of tuple deforming.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'jit_tuple_deforming',
  boot_val => 'true',
},

{ name => 'data_sync_retry', type => 'bool', context => 'PGC_POSTMASTER', group => 'ERROR_HANDLING_OPTIONS',
  short_desc => 'Whether to continue running after a failure to sync data files.',
  variable => 'data_sync_retry',
  boot_val => 'false',
},

{ name => 'wal_receiver_create_temp_slot', type => 'bool', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets whether a WAL receiver should create a temporary replication slot if no permanent slot is configured.',
  variable => 'wal_receiver_create_temp_slot',
  boot_val => 'false',
},

{ name => 'event_triggers', type => 'bool', context => 'PGC_SUSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Enables event triggers.',
  long_desc => 'When enabled, event triggers will fire for all applicable statements.',
  variable => 'event_triggers',
  boot_val => 'true',
},

{ name => 'sync_replication_slots', type => 'bool', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Enables a physical standby to synchronize logical failover replication slots from the primary server.',
  variable => 'sync_replication_slots',
  boot_val => 'false',
},

{ name => 'md5_password_warnings', type => 'bool', context => 'PGC_USERSET', group => 'CONN_AUTH_AUTH',
  short_desc => 'Enables deprecation warnings for MD5 passwords.',
  variable => 'md5_password_warnings',
  boot_val => 'true',
},

{ name => 'vacuum_truncate', type => 'bool', context => 'PGC_USERSET', group => 'VACUUM_DEFAULT',
  short_desc => 'Enables vacuum to truncate empty pages at the end of the table.',
  variable => 'vacuum_truncate',
  boot_val => 'true',
},

{ name => 'archive_timeout', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_ARCHIVING',
  short_desc => 'Sets the amount of time to wait before forcing a switch to the next WAL file.',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_S',
  variable => 'XLogArchiveTimeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX / 2',
},

{ name => 'post_auth_delay', type => 'int', context => 'PGC_BACKEND', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Sets the amount of time to wait after authentication on connection startup.',
  long_desc => 'This allows attaching a debugger to the process.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_UNIT_S',
  variable => 'PostAuthDelay',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX / 1000000',
},

{ name => 'default_statistics_target', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Sets the default statistics target.',
  long_desc => 'This applies to table columns that have not had a column-specific target set via ALTER TABLE SET STATISTICS.',
  variable => 'default_statistics_target',
  boot_val => '100',
  min => '1',
  max => 'MAX_STATISTICS_TARGET',
},

{ name => 'from_collapse_limit', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Sets the FROM-list size beyond which subqueries are not collapsed.',
  long_desc => 'The planner will merge subqueries into upper queries if the resulting FROM list would have no more than this many items.',
  flags => 'GUC_EXPLAIN',
  variable => 'from_collapse_limit',
  boot_val => '8',
  min => '1',
  max => 'INT_MAX',
},

{ name => 'join_collapse_limit', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Sets the FROM-list size beyond which JOIN constructs are not flattened.',
  long_desc => 'The planner will flatten explicit JOIN constructs into lists of FROM items whenever a list of no more than this many items would result.',
  flags => 'GUC_EXPLAIN',
  variable => 'join_collapse_limit',
  boot_val => '8',
  min => '1',
  max => 'INT_MAX',
},

{ name => 'geqo_threshold', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'Sets the threshold of FROM items beyond which GEQO is used.',
  flags => 'GUC_EXPLAIN',
  variable => 'geqo_threshold',
  boot_val => '12',
  min => '2',
  max => 'INT_MAX',
},

{ name => 'geqo_effort', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'GEQO: effort is used to set the default for other GEQO parameters.',
  flags => 'GUC_EXPLAIN',
  variable => 'Geqo_effort',
  boot_val => 'DEFAULT_GEQO_EFFORT',
  min => 'MIN_GEQO_EFFORT',
  max => 'MAX_GEQO_EFFORT',
},

{ name => 'geqo_pool_size', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'GEQO: number of individuals in the population.',
  long_desc => '0 means use a suitable default value.',
  flags => 'GUC_EXPLAIN',
  variable => 'Geqo_pool_size',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'geqo_generations', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'GEQO: number of iterations of the algorithm.',
  long_desc => '0 means use a suitable default value.',
  flags => 'GUC_EXPLAIN',
  variable => 'Geqo_generations',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

# This is PGC_SUSET to prevent hiding from log_lock_waits.
{ name => 'deadlock_timeout', type => 'int', context => 'PGC_SUSET', group => 'LOCK_MANAGEMENT',
  short_desc => 'Sets the time to wait on a lock before checking for deadlock.',
  flags => 'GUC_UNIT_MS',
  variable => 'DeadlockTimeout',
  boot_val => '1000',
  min => '1',
  max => 'INT_MAX',
},

{ name => 'max_standby_archive_delay', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data.',
  long_desc => '-1 means wait forever.',
  flags => 'GUC_UNIT_MS',
  variable => 'max_standby_archive_delay',
  boot_val => '30 * 1000',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'max_standby_streaming_delay', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data.',
  long_desc => '-1 means wait forever.',
  flags => 'GUC_UNIT_MS',
  variable => 'max_standby_streaming_delay',
  boot_val => '30 * 1000',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'recovery_min_apply_delay', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the minimum delay for applying changes during recovery.',
  flags => 'GUC_UNIT_MS',
  variable => 'recovery_min_apply_delay',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'wal_receiver_status_interval', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the maximum interval between WAL receiver status reports to the sending server.',
  flags => 'GUC_UNIT_S',
  variable => 'wal_receiver_status_interval',
  boot_val => '10',
  min => '0',
  max => 'INT_MAX / 1000',
},

{ name => 'wal_receiver_timeout', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the maximum wait time to receive data from the sending server.',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_MS',
  variable => 'wal_receiver_timeout',
  boot_val => '60 * 1000',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'max_connections', type => 'int', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the maximum number of concurrent connections.',
  variable => 'MaxConnections',
  boot_val => '100',
  min => '1',
  max => 'MAX_BACKENDS',
},

# see max_connections
{ name => 'superuser_reserved_connections', type => 'int', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the number of connection slots reserved for superusers.',
  variable => 'SuperuserReservedConnections',
  boot_val => '3',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'reserved_connections', type => 'int', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the number of connection slots reserved for roles with privileges of pg_use_reserved_connections.',
  variable => 'ReservedConnections',
  boot_val => '0',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'min_dynamic_shared_memory', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Amount of dynamic shared memory reserved at startup.',
  flags => 'GUC_UNIT_MB',
  variable => 'min_dynamic_shared_memory',
  boot_val => '0',
  min => '0',
  max => '(int) Min((size_t) INT_MAX, SIZE_MAX / (1024 * 1024))',
},

# We sometimes multiply the number of shared buffers by two without
# checking for overflow, so we mustn't allow more than INT_MAX / 2.
{ name => 'shared_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the number of shared memory buffers used by the server.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'NBuffers',
  boot_val => '16384',
  min => '16',
  max => 'INT_MAX / 2',
},

{ name => 'vacuum_buffer_usage_limit', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_MEM',
  short_desc => 'Sets the buffer pool size for VACUUM, ANALYZE, and autovacuum.',
  flags => 'GUC_UNIT_KB',
  variable => 'VacuumBufferUsageLimit',
  boot_val => '2048',
  min => '0',
  max => 'MAX_BAS_VAC_RING_SIZE_KB',
  check_hook => 'check_vacuum_buffer_usage_limit',
},

{ name => 'shared_memory_size', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the size of the server\'s main shared memory area (rounded up to the nearest MB).',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_UNIT_MB | GUC_RUNTIME_COMPUTED',
  variable => 'shared_memory_size_mb',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'shared_memory_size_in_huge_pages', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the number of huge pages needed for the main shared memory area.',
  long_desc => '-1 means huge pages are not supported.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_RUNTIME_COMPUTED',
  variable => 'shared_memory_size_in_huge_pages',
  boot_val => '-1',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'num_os_semaphores', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the number of semaphores required for the server.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_RUNTIME_COMPUTED',
  variable => 'num_os_semaphores',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'commit_timestamp_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the commit timestamp cache.',
  long_desc => '0 means use a fraction of "shared_buffers".',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'commit_timestamp_buffers',
  boot_val => '0',
  min => '0',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_commit_ts_buffers',
},

{ name => 'multixact_member_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the MultiXact member cache.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'multixact_member_buffers',
  boot_val => '32',
  min => '16',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_multixact_member_buffers',
},

{ name => 'multixact_offset_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the MultiXact offset cache.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'multixact_offset_buffers',
  boot_val => '16',
  min => '16',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_multixact_offset_buffers',
},

{ name => 'notify_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the LISTEN/NOTIFY message cache.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'notify_buffers',
  boot_val => '16',
  min => '16',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_notify_buffers',
},

{ name => 'serializable_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the serializable transaction cache.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'serializable_buffers',
  boot_val => '32',
  min => '16',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_serial_buffers',
},

{ name => 'subtransaction_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the subtransaction cache.',
  long_desc => '0 means use a fraction of "shared_buffers".',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'subtransaction_buffers',
  boot_val => '0',
  min => '0',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_subtrans_buffers',
},

{ name => 'transaction_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the size of the dedicated buffer pool used for the transaction status cache.',
  long_desc => '0 means use a fraction of "shared_buffers".',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'transaction_buffers',
  boot_val => '0',
  min => '0',
  max => 'SLRU_MAX_ALLOWED_BUFFERS',
  check_hook => 'check_transaction_buffers',
},

{ name => 'temp_buffers', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum number of temporary buffers used by each session.',
  flags => 'GUC_UNIT_BLOCKS | GUC_EXPLAIN',
  variable => 'num_temp_buffers',
  boot_val => '1024',
  min => '100',
  max => 'INT_MAX / 2',
  check_hook => 'check_temp_buffers',
},

{ name => 'port', type => 'int', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the TCP port the server listens on.',
  variable => 'PostPortNumber',
  boot_val => 'DEF_PGPORT',
  min => '1',
  max => '65535',
},

{ name => 'unix_socket_permissions', type => 'int', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the access permissions of the Unix-domain socket.',
  long_desc => 'Unix-domain sockets use the usual Unix file system permission set. The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format the number must start with a 0 (zero).)',
  variable => 'Unix_socket_permissions',
  boot_val => '0777',
  min => '0000',
  max => '0777',
  show_hook => 'show_unix_socket_permissions',
},

{ name => 'log_file_mode', type => 'int', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the file permissions for log files.',
  long_desc => 'The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format the number must start with a 0 (zero).)',
  variable => 'Log_file_mode',
  boot_val => '0600',
  min => '0000',
  max => '0777',
  show_hook => 'show_log_file_mode',
},

{ name => 'data_directory_mode', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the mode of the data directory.',
  long_desc => 'The parameter value is a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format the number must start with a 0 (zero).)',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_RUNTIME_COMPUTED',
  variable => 'data_directory_mode',
  boot_val => '0700',
  min => '0000',
  max => '0777',
  show_hook => 'show_data_directory_mode',
},

{ name => 'work_mem', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum memory to be used for query workspaces.',
  long_desc => 'This much memory can be used by each internal sort operation and hash table before switching to temporary disk files.',
  flags => 'GUC_UNIT_KB | GUC_EXPLAIN',
  variable => 'work_mem',
  boot_val => '4096',
  min => '64',
  max => 'MAX_KILOBYTES',
},

# Dynamic shared memory has a higher overhead than local memory
# contexts, so when testing low-memory scenarios that could use shared
# memory, the recommended minimum is 1MB.
{ name => 'maintenance_work_mem', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum memory to be used for maintenance operations.',
  long_desc => 'This includes operations such as VACUUM and CREATE INDEX.',
  flags => 'GUC_UNIT_KB',
  variable => 'maintenance_work_mem',
  boot_val => '65536',
  min => '64',
  max => 'MAX_KILOBYTES',
},

{ name => 'logical_decoding_work_mem', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum memory to be used for logical decoding.',
  long_desc => 'This much memory can be used by each internal reorder buffer before spilling to disk.',
  flags => 'GUC_UNIT_KB',
  variable => 'logical_decoding_work_mem',
  boot_val => '65536',
  min => '64',
  max => 'MAX_KILOBYTES',
},

# We use the hopefully-safely-small value of 100kB as the compiled-in
# default for max_stack_depth.  InitializeGUCOptions will increase it
# if possible, depending on the actual platform-specific stack limit.
{ name => 'max_stack_depth', type => 'int', context => 'PGC_SUSET', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum stack depth, in kilobytes.',
  flags => 'GUC_UNIT_KB',
  variable => 'max_stack_depth',
  boot_val => '100',
  min => '100',
  max => 'MAX_KILOBYTES',
  check_hook => 'check_max_stack_depth',
  assign_hook => 'assign_max_stack_depth',
},

{ name => 'temp_file_limit', type => 'int', context => 'PGC_SUSET', group => 'RESOURCES_DISK',
  short_desc => 'Limits the total size of all temporary files used by each process.',
  long_desc => '-1 means no limit.',
  flags => 'GUC_UNIT_KB',
  variable => 'temp_file_limit',
  boot_val => '-1',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'vacuum_cost_page_hit', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_COST_DELAY',
  short_desc => 'Vacuum cost for a page found in the buffer cache.',
  variable => 'VacuumCostPageHit',
  boot_val => '1',
  min => '0',
  max => '10000',
},

{ name => 'vacuum_cost_page_miss', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_COST_DELAY',
  short_desc => 'Vacuum cost for a page not found in the buffer cache.',
  variable => 'VacuumCostPageMiss',
  boot_val => '2',
  min => '0',
  max => '10000',
},

{ name => 'vacuum_cost_page_dirty', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_COST_DELAY',
  short_desc => 'Vacuum cost for a page dirtied by vacuum.',
  variable => 'VacuumCostPageDirty',
  boot_val => '20',
  min => '0',
  max => '10000',
},

{ name => 'vacuum_cost_limit', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_COST_DELAY',
  short_desc => 'Vacuum cost amount available before napping.',
  variable => 'VacuumCostLimit',
  boot_val => '200',
  min => '1',
  max => '10000',
},

{ name => 'autovacuum_vacuum_cost_limit', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Vacuum cost amount available before napping, for autovacuum.',
  long_desc => '-1 means use "vacuum_cost_limit".',
  variable => 'autovacuum_vac_cost_limit',
  boot_val => '-1',
  min => '-1',
  max => '10000',
},

{ name => 'max_files_per_process', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_KERNEL',
  short_desc => 'Sets the maximum number of files each server process is allowed to open simultaneously.',
  variable => 'max_files_per_process',
  boot_val => '1000',
  min => '64',
  max => 'INT_MAX',
},

# See also CheckRequiredParameterValues() if this parameter changes
{ name => 'max_prepared_transactions', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum number of simultaneously prepared transactions.',
  variable => 'max_prepared_xacts',
  boot_val => '0',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'trace_lock_oidmin', type => 'int', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Sets the minimum OID of tables for tracking locks.',
  long_desc => 'Is used to avoid output on system tables.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_lock_oidmin',
  boot_val => 'FirstNormalObjectId',
  min => '0',
  max => 'INT_MAX',
  ifdef => 'LOCK_DEBUG',
},

{ name => 'trace_lock_table', type => 'int', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Sets the OID of the table with unconditionally lock tracing.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'Trace_lock_table',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  ifdef => 'LOCK_DEBUG',
},

{ name => 'statement_timeout', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the maximum allowed duration of any statement.',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_MS',
  variable => 'StatementTimeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'lock_timeout', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the maximum allowed duration of any wait for a lock.',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_MS',
  variable => 'LockTimeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'idle_in_transaction_session_timeout', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the maximum allowed idle time between queries, when in a transaction.',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_MS',
  variable => 'IdleInTransactionSessionTimeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'transaction_timeout', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the maximum allowed duration of any transaction within a session (not a prepared transaction).',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_MS',
  variable => 'TransactionTimeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  assign_hook => 'assign_transaction_timeout',
},

{ name => 'idle_session_timeout', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the maximum allowed idle time between queries, when not in a transaction.',
  long_desc => '0 disables the timeout.',
  flags => 'GUC_UNIT_MS',
  variable => 'IdleSessionTimeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'vacuum_freeze_min_age', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Minimum age at which VACUUM should freeze a table row.',
  variable => 'vacuum_freeze_min_age',
  boot_val => '50000000',
  min => '0',
  max => '1000000000',
},

{ name => 'vacuum_freeze_table_age', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Age at which VACUUM should scan whole table to freeze tuples.',
  variable => 'vacuum_freeze_table_age',
  boot_val => '150000000',
  min => '0',
  max => '2000000000',
},

{ name => 'vacuum_multixact_freeze_min_age', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Minimum age at which VACUUM should freeze a MultiXactId in a table row.',
  variable => 'vacuum_multixact_freeze_min_age',
  boot_val => '5000000',
  min => '0',
  max => '1000000000',
},

{ name => 'vacuum_multixact_freeze_table_age', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Multixact age at which VACUUM should scan whole table to freeze tuples.',
  variable => 'vacuum_multixact_freeze_table_age',
  boot_val => '150000000',
  min => '0',
  max => '2000000000',
},

{ name => 'vacuum_failsafe_age', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Age at which VACUUM should trigger failsafe to avoid a wraparound outage.',
  variable => 'vacuum_failsafe_age',
  boot_val => '1600000000',
  min => '0',
  max => '2100000000',
},

{ name => 'vacuum_multixact_failsafe_age', type => 'int', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Multixact age at which VACUUM should trigger failsafe to avoid a wraparound outage.',
  variable => 'vacuum_multixact_failsafe_age',
  boot_val => '1600000000',
  min => '0',
  max => '2100000000',
},

# See also CheckRequiredParameterValues() if this parameter changes
{ name => 'max_locks_per_transaction', type => 'int', context => 'PGC_POSTMASTER', group => 'LOCK_MANAGEMENT',
  short_desc => 'Sets the maximum number of locks per transaction.',
  long_desc => 'The shared lock table is sized on the assumption that at most "max_locks_per_transaction" objects per server process or prepared transaction will need to be locked at any one time.',
  variable => 'max_locks_per_xact',
  boot_val => '64',
  min => '10',
  max => 'INT_MAX',
},

{ name => 'max_pred_locks_per_transaction', type => 'int', context => 'PGC_POSTMASTER', group => 'LOCK_MANAGEMENT',
  short_desc => 'Sets the maximum number of predicate locks per transaction.',
  long_desc => 'The shared predicate lock table is sized on the assumption that at most "max_pred_locks_per_transaction" objects per server process or prepared transaction will need to be locked at any one time.',
  variable => 'max_predicate_locks_per_xact',
  boot_val => '64',
  min => '10',
  max => 'INT_MAX',
},

{ name => 'max_pred_locks_per_relation', type => 'int', context => 'PGC_SIGHUP', group => 'LOCK_MANAGEMENT',
  short_desc => 'Sets the maximum number of predicate-locked pages and tuples per relation.',
  long_desc => 'If more than this total of pages and tuples in the same relation are locked by a connection, those locks are replaced by a relation-level lock.',
  variable => 'max_predicate_locks_per_relation',
  boot_val => '-2',
  min => 'INT_MIN',
  max => 'INT_MAX',
},

{ name => 'max_pred_locks_per_page', type => 'int', context => 'PGC_SIGHUP', group => 'LOCK_MANAGEMENT',
  short_desc => 'Sets the maximum number of predicate-locked tuples per page.',
  long_desc => 'If more than this number of tuples on the same page are locked by a connection, those locks are replaced by a page-level lock.',
  variable => 'max_predicate_locks_per_page',
  boot_val => '2',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'authentication_timeout', type => 'int', context => 'PGC_SIGHUP', group => 'CONN_AUTH_AUTH',
  short_desc => 'Sets the maximum allowed time to complete client authentication.',
  flags => 'GUC_UNIT_S',
  variable => 'AuthenticationTimeout',
  boot_val => '60',
  min => '1',
  max => '600',
},

# Not for general use
{ name => 'pre_auth_delay', type => 'int', context => 'PGC_SIGHUP', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Sets the amount of time to wait before authentication on connection startup.',
  long_desc => 'This allows attaching a debugger to the process.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_UNIT_S',
  variable => 'PreAuthDelay',
  boot_val => '0',
  min => '0',
  max => '60',
},

{ name => 'max_notify_queue_pages', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_DISK',
  short_desc => 'Sets the maximum number of allocated pages for NOTIFY / LISTEN queue.',
  variable => 'max_notify_queue_pages',
  boot_val => '1048576',
  min => '64',
  max => 'INT_MAX',
},

{ name => 'wal_decode_buffer_size', type => 'int', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY',
  short_desc => 'Buffer size for reading ahead in the WAL during recovery.',
  long_desc => 'Maximum distance to read ahead in the WAL to prefetch referenced data blocks.',
  flags => 'GUC_UNIT_BYTE',
  variable => 'wal_decode_buffer_size',
  boot_val => '512 * 1024',
  min => '64 * 1024',
  max => 'MaxAllocSize',
},

{ name => 'wal_keep_size', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_SENDING',
  short_desc => 'Sets the size of WAL files held for standby servers.',
  flags => 'GUC_UNIT_MB',
  variable => 'wal_keep_size_mb',
  boot_val => '0',
  min => '0',
  max => 'MAX_KILOBYTES',
},

{ name => 'min_wal_size', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_CHECKPOINTS',
  short_desc => 'Sets the minimum size to shrink the WAL to.',
  flags => 'GUC_UNIT_MB',
  variable => 'min_wal_size_mb',
  boot_val => 'DEFAULT_MIN_WAL_SEGS * (DEFAULT_XLOG_SEG_SIZE / (1024 * 1024))',
  min => '2',
  max => 'MAX_KILOBYTES',
},

{ name => 'max_wal_size', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_CHECKPOINTS',
  short_desc => 'Sets the WAL size that triggers a checkpoint.',
  flags => 'GUC_UNIT_MB',
  variable => 'max_wal_size_mb',
  boot_val => 'DEFAULT_MAX_WAL_SEGS * (DEFAULT_XLOG_SEG_SIZE / (1024 * 1024))',
  min => '2',
  max => 'MAX_KILOBYTES',
  assign_hook => 'assign_max_wal_size',
},

{ name => 'checkpoint_timeout', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_CHECKPOINTS',
  short_desc => 'Sets the maximum time between automatic WAL checkpoints.',
  flags => 'GUC_UNIT_S',
  variable => 'CheckPointTimeout',
  boot_val => '300',
  min => '30',
  max => '86400',
},

{ name => 'checkpoint_warning', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_CHECKPOINTS',
  short_desc => 'Sets the maximum time before warning if checkpoints triggered by WAL volume happen too frequently.',
  long_desc => 'Write a message to the server log if checkpoints caused by the filling of WAL segment files happen more frequently than this amount of time. 0 disables the warning.',
  flags => 'GUC_UNIT_S',
  variable => 'CheckPointWarning',
  boot_val => '30',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'checkpoint_flush_after', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_CHECKPOINTS',
  short_desc => 'Number of pages after which previously performed writes are flushed to disk.',
  long_desc => '0 disables forced writeback.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'checkpoint_flush_after',
  boot_val => 'DEFAULT_CHECKPOINT_FLUSH_AFTER',
  min => '0',
  max => 'WRITEBACK_MAX_PENDING_FLUSHES',
},

{ name => 'wal_buffers', type => 'int', context => 'PGC_POSTMASTER', group => 'WAL_SETTINGS',
  short_desc => 'Sets the number of disk-page buffers in shared memory for WAL.',
  long_desc => '-1 means use a fraction of "shared_buffers".',
  flags => 'GUC_UNIT_XBLOCKS',
  variable => 'XLOGbuffers',
  boot_val => '-1',
  min => '-1',
  max => '(INT_MAX / XLOG_BLCKSZ)',
  check_hook => 'check_wal_buffers',
},

{ name => 'wal_writer_delay', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_SETTINGS',
  short_desc => 'Time between WAL flushes performed in the WAL writer.',
  flags => 'GUC_UNIT_MS',
  variable => 'WalWriterDelay',
  boot_val => '200',
  min => '1',
  max => '10000',
},

{ name => 'wal_writer_flush_after', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_SETTINGS',
  short_desc => 'Amount of WAL written out by WAL writer that triggers a flush.',
  flags => 'GUC_UNIT_XBLOCKS',
  variable => 'WalWriterFlushAfter',
  boot_val => 'DEFAULT_WAL_WRITER_FLUSH_AFTER',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'wal_skip_threshold', type => 'int', context => 'PGC_USERSET', group => 'WAL_SETTINGS',
  short_desc => 'Minimum size of new file to fsync instead of writing WAL.',
  flags => 'GUC_UNIT_KB',
  variable => 'wal_skip_threshold',
  boot_val => '2048',
  min => '0',
  max => 'MAX_KILOBYTES',
},

{ name => 'max_wal_senders', type => 'int', context => 'PGC_POSTMASTER', group => 'REPLICATION_SENDING',
  short_desc => 'Sets the maximum number of simultaneously running WAL sender processes.',
  variable => 'max_wal_senders',
  boot_val => '10',
  min => '0',
  max => 'MAX_BACKENDS',
},

/* see max_wal_senders */
{ name => 'max_replication_slots', type => 'int', context => 'PGC_POSTMASTER', group => 'REPLICATION_SENDING',
  short_desc => 'Sets the maximum number of simultaneously defined replication slots.',
  variable => 'max_replication_slots',
  boot_val => '10',
  min => '0',
  max => 'MAX_BACKENDS /* XXX? */',
},

{ name => 'max_slot_wal_keep_size', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_SENDING',
  short_desc => 'Sets the maximum WAL size that can be reserved by replication slots.',
  long_desc => 'Replication slots will be marked as failed, and segments released for deletion or recycling, if this much space is occupied by WAL on disk. -1 means no maximum.',
  flags => 'GUC_UNIT_MB',
  variable => 'max_slot_wal_keep_size_mb',
  boot_val => '-1',
  min => '-1',
  max => 'MAX_KILOBYTES',
},

{ name => 'wal_sender_timeout', type => 'int', context => 'PGC_USERSET', group => 'REPLICATION_SENDING',
  short_desc => 'Sets the maximum time to wait for WAL replication.',
  flags => 'GUC_UNIT_MS',
  variable => 'wal_sender_timeout',
  boot_val => '60 * 1000',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'idle_replication_slot_timeout', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_SENDING',
  short_desc => 'Sets the duration a replication slot can remain idle before it is invalidated.',
  flags => 'GUC_UNIT_S',
  variable => 'idle_replication_slot_timeout_secs',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

# we have no microseconds designation, so can't supply units here
{ name => 'commit_delay', type => 'int', context => 'PGC_SUSET', group => 'WAL_SETTINGS',
  short_desc => 'Sets the delay in microseconds between transaction commit and flushing WAL to disk.',
  variable => 'CommitDelay',
  boot_val => '0',
  min => '0',
  max => '100000',
},

{ name => 'commit_siblings', type => 'int', context => 'PGC_USERSET', group => 'WAL_SETTINGS',
  short_desc => 'Sets the minimum number of concurrent open transactions required before performing "commit_delay".',
  variable => 'CommitSiblings',
  boot_val => '5',
  min => '0',
  max => '1000',
},

{ name => 'extra_float_digits', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the number of digits displayed for floating-point values.',
  long_desc => 'This affects real, double precision, and geometric data types. A zero or negative parameter value is added to the standard number of digits (FLT_DIG or DBL_DIG as appropriate). Any value greater than zero selects precise output mode.',
  variable => 'extra_float_digits',
  boot_val => '1',
  min => '-15',
  max => '3',
},

{ name => 'log_min_duration_sample', type => 'int', context => 'PGC_SUSET', group => 'LOGGING_WHEN',
  short_desc => 'Sets the minimum execution time above which a sample of statements will be logged. Sampling is determined by "log_statement_sample_rate".',
  long_desc => '-1 disables sampling. 0 means sample all statements.',
  flags => 'GUC_UNIT_MS',
  variable => 'log_min_duration_sample',
  boot_val => '-1',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'log_min_duration_statement', type => 'int', context => 'PGC_SUSET', group => 'LOGGING_WHEN',
  short_desc => 'Sets the minimum execution time above which all statements will be logged.',
  long_desc => '-1 disables logging statement durations. 0 means log all statement durations.',
  flags => 'GUC_UNIT_MS',
  variable => 'log_min_duration_statement',
  boot_val => '-1',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'log_autovacuum_min_duration', type => 'int', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Sets the minimum execution time above which vacuum actions by autovacuum will be logged.',
  long_desc => '-1 disables logging vacuum actions by autovacuum. 0 means log all vacuum actions by autovacuum.',
  flags => 'GUC_UNIT_MS',
  variable => 'Log_autovacuum_min_duration',
  boot_val => '600000',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'log_autoanalyze_min_duration', type => 'int', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Sets the minimum execution time above which analyze actions by autovacuum will be logged.',
  long_desc => '-1 disables logging analyze actions by autovacuum. 0 means log all analyze actions by autovacuum.',
  flags => 'GUC_UNIT_MS',
  variable => 'Log_autoanalyze_min_duration',
  boot_val => '600000',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'log_parameter_max_length', type => 'int', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Sets the maximum length in bytes of data logged for bind parameter values when logging statements.',
  long_desc => '-1 means log values in full.',
  flags => 'GUC_UNIT_BYTE',
  variable => 'log_parameter_max_length',
  boot_val => '-1',
  min => '-1',
  max => 'INT_MAX / 2',
},

{ name => 'log_parameter_max_length_on_error', type => 'int', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Sets the maximum length in bytes of data logged for bind parameter values when logging statements, on error.',
  long_desc => '-1 means log values in full.',
  flags => 'GUC_UNIT_BYTE',
  variable => 'log_parameter_max_length_on_error',
  boot_val => '0',
  min => '-1',
  max => 'INT_MAX / 2',
},

{ name => 'bgwriter_delay', type => 'int', context => 'PGC_SIGHUP', group => 'RESOURCES_BGWRITER',
  short_desc => 'Background writer sleep time between rounds.',
  flags => 'GUC_UNIT_MS',
  variable => 'BgWriterDelay',
  boot_val => '200',
  min => '10',
  max => '10000',
},

# Same upper limit as shared_buffers
{ name => 'bgwriter_lru_maxpages', type => 'int', context => 'PGC_SIGHUP', group => 'RESOURCES_BGWRITER',
  short_desc => 'Background writer maximum number of LRU pages to flush per round.',
  long_desc => '0 disables background writing.',
  variable => 'bgwriter_lru_maxpages',
  boot_val => '100',
  min => '0',
  max => 'INT_MAX / 2',
},

{ name => 'bgwriter_flush_after', type => 'int', context => 'PGC_SIGHUP', group => 'RESOURCES_BGWRITER',
  short_desc => 'Number of pages after which previously performed writes are flushed to disk.',
  long_desc => '0 disables forced writeback.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'bgwriter_flush_after',
  boot_val => 'DEFAULT_BGWRITER_FLUSH_AFTER',
  min => '0',
  max => 'WRITEBACK_MAX_PENDING_FLUSHES',
},

{ name => 'effective_io_concurrency', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_IO',
  short_desc => 'Number of simultaneous requests that can be handled efficiently by the disk subsystem.',
  long_desc => '0 disables simultaneous requests.',
  flags => 'GUC_EXPLAIN',
  variable => 'effective_io_concurrency',
  boot_val => 'DEFAULT_EFFECTIVE_IO_CONCURRENCY',
  min => '0',
  max => 'MAX_IO_CONCURRENCY',
},

{ name => 'maintenance_io_concurrency', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_IO',
  short_desc => 'A variant of "effective_io_concurrency" that is used for maintenance work.',
  long_desc => '0 disables simultaneous requests.',
  flags => 'GUC_EXPLAIN',
  variable => 'maintenance_io_concurrency',
  boot_val => 'DEFAULT_MAINTENANCE_IO_CONCURRENCY',
  min => '0',
  max => 'MAX_IO_CONCURRENCY',
  assign_hook => 'assign_maintenance_io_concurrency',
},

{ name => 'io_max_combine_limit', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_IO',
  short_desc => 'Server-wide limit that clamps io_combine_limit.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'io_max_combine_limit',
  boot_val => 'DEFAULT_IO_COMBINE_LIMIT',
  min => '1',
  max => 'MAX_IO_COMBINE_LIMIT',
  assign_hook => 'assign_io_max_combine_limit',
},

{ name => 'io_combine_limit', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_IO',
  short_desc => 'Limit on the size of data reads and writes.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'io_combine_limit_guc',
  boot_val => 'DEFAULT_IO_COMBINE_LIMIT',
  min => '1',
  max => 'MAX_IO_COMBINE_LIMIT',
  assign_hook => 'assign_io_combine_limit',
},

{ name => 'io_max_concurrency', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_IO',
  short_desc => 'Max number of IOs that one process can execute simultaneously.',
  variable => 'io_max_concurrency',
  boot_val => '-1',
  min => '-1',
  max => '1024',
  check_hook => 'check_io_max_concurrency',
},

{ name => 'io_workers', type => 'int', context => 'PGC_SIGHUP', group => 'RESOURCES_IO',
  short_desc => 'Number of IO worker processes, for io_method=worker.',
  variable => 'io_workers',
  boot_val => '3',
  min => '1',
  max => 'MAX_IO_WORKERS',
},

{ name => 'backend_flush_after', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_IO',
  short_desc => 'Number of pages after which previously performed writes are flushed to disk.',
  long_desc => '0 disables forced writeback.',
  flags => 'GUC_UNIT_BLOCKS',
  variable => 'backend_flush_after',
  boot_val => 'DEFAULT_BACKEND_FLUSH_AFTER',
  min => '0',
  max => 'WRITEBACK_MAX_PENDING_FLUSHES',
},

{ name => 'max_worker_processes', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_WORKER_PROCESSES',
  short_desc => 'Maximum number of concurrent worker processes.',
  variable => 'max_worker_processes',
  boot_val => '8',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'max_logical_replication_workers', type => 'int', context => 'PGC_POSTMASTER', group => 'REPLICATION_SUBSCRIBERS',
  short_desc => 'Maximum number of logical replication worker processes.',
  variable => 'max_logical_replication_workers',
  boot_val => '4',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'max_sync_workers_per_subscription', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_SUBSCRIBERS',
  short_desc => 'Maximum number of table synchronization workers per subscription.',
  variable => 'max_sync_workers_per_subscription',
  boot_val => '2',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'max_parallel_apply_workers_per_subscription', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_SUBSCRIBERS',
  short_desc => 'Maximum number of parallel apply workers per subscription.',
  variable => 'max_parallel_apply_workers_per_subscription',
  boot_val => '2',
  min => '0',
  max => 'MAX_PARALLEL_WORKER_LIMIT',
},

{ name => 'max_active_replication_origins', type => 'int', context => 'PGC_POSTMASTER', group => 'REPLICATION_SUBSCRIBERS',
  short_desc => 'Sets the maximum number of active replication origins.',
  variable => 'max_active_replication_origins',
  boot_val => '10',
  min => '0',
  max => 'MAX_BACKENDS',
},

{ name => 'log_rotation_age', type => 'int', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the amount of time to wait before forcing log file rotation.',
  long_desc => '0 disables time-based creation of new log files.',
  flags => 'GUC_UNIT_MIN',
  variable => 'Log_RotationAge',
  boot_val => 'HOURS_PER_DAY * MINS_PER_HOUR',
  min => '0',
  max => 'INT_MAX / SECS_PER_MINUTE',
},

{ name => 'log_rotation_size', type => 'int', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the maximum size a log file can reach before being rotated.',
  long_desc => '0 disables size-based creation of new log files.',
  flags => 'GUC_UNIT_KB',
  variable => 'Log_RotationSize',
  boot_val => '10 * 1024',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'max_function_args', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the maximum number of function arguments.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'max_function_args',
  boot_val => 'FUNC_MAX_ARGS',
  min => 'FUNC_MAX_ARGS',
  max => 'FUNC_MAX_ARGS',
},

{ name => 'max_index_keys', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the maximum number of index keys.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'max_index_keys',
  boot_val => 'INDEX_MAX_KEYS',
  min => 'INDEX_MAX_KEYS',
  max => 'INDEX_MAX_KEYS',
},

{ name => 'max_identifier_length', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the maximum identifier length.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'max_identifier_length',
  boot_val => 'NAMEDATALEN - 1',
  min => 'NAMEDATALEN - 1',
  max => 'NAMEDATALEN - 1',
},

{ name => 'block_size', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the size of a disk block.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'block_size',
  boot_val => 'BLCKSZ',
  min => 'BLCKSZ',
  max => 'BLCKSZ',
},

{ name => 'segment_size', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the number of pages per disk file.',
  flags => 'GUC_UNIT_BLOCKS | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'segment_size',
  boot_val => 'RELSEG_SIZE',
  min => 'RELSEG_SIZE',
  max => 'RELSEG_SIZE',
},

{ name => 'wal_block_size', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the block size in the write ahead log.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'wal_block_size',
  boot_val => 'XLOG_BLCKSZ',
  min => 'XLOG_BLCKSZ',
  max => 'XLOG_BLCKSZ',
},

{ name => 'wal_retrieve_retry_interval', type => 'int', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the time to wait before retrying to retrieve WAL after a failed attempt.',
  flags => 'GUC_UNIT_MS',
  variable => 'wal_retrieve_retry_interval',
  boot_val => '5000',
  min => '1',
  max => 'INT_MAX',
},

{ name => 'wal_segment_size', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the size of write ahead log segments.',
  flags => 'GUC_UNIT_BYTE | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_RUNTIME_COMPUTED',
  variable => 'wal_segment_size',
  boot_val => 'DEFAULT_XLOG_SEG_SIZE',
  min => 'WalSegMinSize',
  max => 'WalSegMaxSize',
  check_hook => 'check_wal_segment_size',
},

{ name => 'wal_summary_keep_time', type => 'int', context => 'PGC_SIGHUP', group => 'WAL_SUMMARIZATION',
  short_desc => 'Time for which WAL summary files should be kept.',
  long_desc => '0 disables automatic summary file deletion.',
  flags => 'GUC_UNIT_MIN',
  variable => 'wal_summary_keep_time',
  boot_val => '10 * HOURS_PER_DAY * MINS_PER_HOUR /* 10 days */',
  min => '0',
  max => 'INT_MAX / SECS_PER_MINUTE',
},

{ name => 'autovacuum_naptime', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Time to sleep between autovacuum runs.',
  flags => 'GUC_UNIT_S',
  variable => 'autovacuum_naptime',
  boot_val => '60',
  min => '1',
  max => 'INT_MAX / 1000',
},

{ name => 'autovacuum_vacuum_threshold', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Minimum number of tuple updates or deletes prior to vacuum.',
  variable => 'autovacuum_vac_thresh',
  boot_val => '50',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'autovacuum_vacuum_max_threshold', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Maximum number of tuple updates or deletes prior to vacuum.',
  long_desc => '-1 disables the maximum threshold.',
  variable => 'autovacuum_vac_max_thresh',
  boot_val => '100000000',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'autovacuum_vacuum_insert_threshold', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Minimum number of tuple inserts prior to vacuum.',
  long_desc => '-1 disables insert vacuums.',
  variable => 'autovacuum_vac_ins_thresh',
  boot_val => '1000',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'autovacuum_analyze_threshold', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Minimum number of tuple inserts, updates, or deletes prior to analyze.',
  variable => 'autovacuum_anl_thresh',
  boot_val => '50',
  min => '0',
  max => 'INT_MAX',
},

# see varsup.c for why this is PGC_POSTMASTER not PGC_SIGHUP
# see vacuum_failsafe_age if you change the upper-limit value.
{ name => 'autovacuum_freeze_max_age', type => 'int', context => 'PGC_POSTMASTER', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Age at which to autovacuum a table to prevent transaction ID wraparound.',
  variable => 'autovacuum_freeze_max_age',
  boot_val => '200000000',
  min => '100000',
  max => '2000000000',
},

# see multixact.c for why this is PGC_POSTMASTER not PGC_SIGHUP
{ name => 'autovacuum_multixact_freeze_max_age', type => 'int', context => 'PGC_POSTMASTER', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Multixact age at which to autovacuum a table to prevent multixact wraparound.',
  variable => 'autovacuum_multixact_freeze_max_age',
  boot_val => '400000000',
  min => '10000',
  max => '2000000000',
},

# see max_connections
{ name => 'autovacuum_worker_slots', type => 'int', context => 'PGC_POSTMASTER', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Sets the number of backend slots to allocate for autovacuum workers.',
  variable => 'autovacuum_worker_slots',
  boot_val => '16',
  min => '1',
  max => 'MAX_BACKENDS',
},

{ name => 'autovacuum_max_workers', type => 'int', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Sets the maximum number of simultaneously running autovacuum worker processes.',
  variable => 'autovacuum_max_workers',
  boot_val => '3',
  min => '1',
  max => 'MAX_BACKENDS',
},

{ name => 'max_parallel_maintenance_workers', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_WORKER_PROCESSES',
  short_desc => 'Sets the maximum number of parallel processes per maintenance operation.',
  variable => 'max_parallel_maintenance_workers',
  boot_val => '2',
  min => '0',
  max => 'MAX_PARALLEL_WORKER_LIMIT',
},

{ name => 'max_parallel_workers_per_gather', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_WORKER_PROCESSES',
  short_desc => 'Sets the maximum number of parallel processes per executor node.',
  flags => 'GUC_EXPLAIN',
  variable => 'max_parallel_workers_per_gather',
  boot_val => '2',
  min => '0',
  max => 'MAX_PARALLEL_WORKER_LIMIT',
},

{ name => 'max_parallel_workers', type => 'int', context => 'PGC_USERSET', group => 'RESOURCES_WORKER_PROCESSES',
  short_desc => 'Sets the maximum number of parallel workers that can be active at one time.',
  flags => 'GUC_EXPLAIN',
  variable => 'max_parallel_workers',
  boot_val => '8',
  min => '0',
  max => 'MAX_PARALLEL_WORKER_LIMIT',
},

{ name => 'autovacuum_work_mem', type => 'int', context => 'PGC_SIGHUP', group => 'RESOURCES_MEM',
  short_desc => 'Sets the maximum memory to be used by each autovacuum worker process.',
  long_desc => '-1 means use "maintenance_work_mem".',
  flags => 'GUC_UNIT_KB',
  variable => 'autovacuum_work_mem',
  boot_val => '-1',
  min => '-1',
  max => 'MAX_KILOBYTES',
  check_hook => 'check_autovacuum_work_mem',
},

{ name => 'tcp_keepalives_idle', type => 'int', context => 'PGC_USERSET', group => 'CONN_AUTH_TCP',
  short_desc => 'Time between issuing TCP keepalives.',
  long_desc => '0 means use the system default.',
  flags => 'GUC_UNIT_S',
  variable => 'tcp_keepalives_idle',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  assign_hook => 'assign_tcp_keepalives_idle',
  show_hook => 'show_tcp_keepalives_idle',
},

{ name => 'tcp_keepalives_interval', type => 'int', context => 'PGC_USERSET', group => 'CONN_AUTH_TCP',
  short_desc => 'Time between TCP keepalive retransmits.',
  long_desc => '0 means use the system default.',
  flags => 'GUC_UNIT_S',
  variable => 'tcp_keepalives_interval',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  assign_hook => 'assign_tcp_keepalives_interval',
  show_hook => 'show_tcp_keepalives_interval',
},

{ name => 'ssl_renegotiation_limit', type => 'int', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'SSL renegotiation is no longer supported; this can only be 0.',
  flags => 'GUC_NO_SHOW_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'ssl_renegotiation_limit',
  boot_val => '0',
  min => '0',
  max => '0',
},

{ name => 'tcp_keepalives_count', type => 'int', context => 'PGC_USERSET', group => 'CONN_AUTH_TCP',
  short_desc => 'Maximum number of TCP keepalive retransmits.',
  long_desc => 'Number of consecutive keepalive retransmits that can be lost before a connection is considered dead. 0 means use the system default.',
  variable => 'tcp_keepalives_count',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  assign_hook => 'assign_tcp_keepalives_count',
  show_hook => 'show_tcp_keepalives_count',
},

{ name => 'gin_fuzzy_search_limit', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_OTHER',
  short_desc => 'Sets the maximum allowed result for exact search by GIN.',
  long_desc => '0 means no limit.',
  variable => 'GinFuzzySearchLimit',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'effective_cache_size', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s assumption about the total size of the data caches.',
  long_desc => 'That is, the total size of the caches (kernel cache and shared buffers) used for PostgreSQL data files. This is measured in disk pages, which are normally 8 kB each.',
  flags => 'GUC_UNIT_BLOCKS | GUC_EXPLAIN',
  variable => 'effective_cache_size',
  boot_val => 'DEFAULT_EFFECTIVE_CACHE_SIZE',
  min => '1',
  max => 'INT_MAX',
},

{ name => 'min_parallel_table_scan_size', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the minimum amount of table data for a parallel scan.',
  long_desc => 'If the planner estimates that it will read a number of table pages too small to reach this limit, a parallel scan will not be considered.',
  flags => 'GUC_UNIT_BLOCKS | GUC_EXPLAIN',
  variable => 'min_parallel_table_scan_size',
  boot_val => '(8 * 1024 * 1024) / BLCKSZ',
  min => '0',
  max => 'INT_MAX / 3',
},

{ name => 'min_parallel_index_scan_size', type => 'int', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the minimum amount of index data for a parallel scan.',
  long_desc => 'If the planner estimates that it will read a number of index pages too small to reach this limit, a parallel scan will not be considered.',
  flags => 'GUC_UNIT_BLOCKS | GUC_EXPLAIN',
  variable => 'min_parallel_index_scan_size',
  boot_val => '(512 * 1024) / BLCKSZ',
  min => '0',
  max => 'INT_MAX / 3',
},

# Can't be set in postgresql.conf
{ name => 'server_version_num', type => 'int', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the server version as an integer.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'server_version_num',
  boot_val => 'PG_VERSION_NUM',
  min => 'PG_VERSION_NUM',
  max => 'PG_VERSION_NUM',
},

{ name => 'log_temp_files', type => 'int', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Log the use of temporary files larger than this number of kilobytes.',
  long_desc => '-1 disables logging temporary files. 0 means log all temporary files.',
  flags => 'GUC_UNIT_KB',
  variable => 'log_temp_files',
  boot_val => '-1',
  min => '-1',
  max => 'INT_MAX',
},

{ name => 'track_activity_query_size', type => 'int', context => 'PGC_POSTMASTER', group => 'STATS_CUMULATIVE',
  short_desc => 'Sets the size reserved for pg_stat_activity.query, in bytes.',
  flags => 'GUC_UNIT_BYTE',
  variable => 'pgstat_track_activity_query_size',
  boot_val => '1024',
  min => '100',
  max => '1048576',
},

{ name => 'gin_pending_list_limit', type => 'int', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the maximum size of the pending list for GIN index.',
  flags => 'GUC_UNIT_KB',
  variable => 'gin_pending_list_limit',
  boot_val => '4096',
  min => '64',
  max => 'MAX_KILOBYTES',
},

{ name => 'tcp_user_timeout', type => 'int', context => 'PGC_USERSET', group => 'CONN_AUTH_TCP',
  short_desc => 'TCP user timeout.',
  long_desc => '0 means use the system default.',
  flags => 'GUC_UNIT_MS',
  variable => 'tcp_user_timeout',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  assign_hook => 'assign_tcp_user_timeout',
  show_hook => 'show_tcp_user_timeout',
},

{ name => 'huge_page_size', type => 'int', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'The size of huge page that should be requested.',
  long_desc => '0 means use the system default.',
  flags => 'GUC_UNIT_KB',
  variable => 'huge_page_size',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  check_hook => 'check_huge_page_size',
},

{ name => 'debug_discard_caches', type => 'int', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Aggressively flush system caches for debugging purposes.',
  long_desc => '0 means use normal caching behavior.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'debug_discard_caches',
  boot_val => 'DEFAULT_DEBUG_DISCARD_CACHES',
  min => 'MIN_DEBUG_DISCARD_CACHES',
  max => 'MAX_DEBUG_DISCARD_CACHES',
},

{ name => 'client_connection_check_interval', type => 'int', context => 'PGC_USERSET', group => 'CONN_AUTH_TCP',
  short_desc => 'Sets the time interval between checks for disconnection while running queries.',
  long_desc => '0 disables connection checks.',
  flags => 'GUC_UNIT_MS',
  variable => 'client_connection_check_interval',
  boot_val => '0',
  min => '0',
  max => 'INT_MAX',
  check_hook => 'check_client_connection_check_interval',
},

{ name => 'log_startup_progress_interval', type => 'int', context => 'PGC_SIGHUP', group => 'LOGGING_WHEN',
  short_desc => 'Time between progress updates for long-running startup operations.',
  long_desc => '0 disables progress updates.',
  flags => 'GUC_UNIT_MS',
  variable => 'log_startup_progress_interval',
  boot_val => '10000',
  min => '0',
  max => 'INT_MAX',
},

{ name => 'scram_iterations', type => 'int', context => 'PGC_USERSET', group => 'CONN_AUTH_AUTH',
  short_desc => 'Sets the iteration count for SCRAM secret generation.',
  flags => 'GUC_REPORT',
  variable => 'scram_sha_256_iterations',
  boot_val => 'SCRAM_SHA_256_DEFAULT_ITERATIONS',
  min => '1',
  max => 'INT_MAX',
},


{ name => 'seq_page_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of a sequentially fetched disk page.',
  flags => 'GUC_EXPLAIN',
  variable => 'seq_page_cost',
  boot_val => 'DEFAULT_SEQ_PAGE_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'random_page_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of a nonsequentially fetched disk page.',
  flags => 'GUC_EXPLAIN',
  variable => 'random_page_cost',
  boot_val => 'DEFAULT_RANDOM_PAGE_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'cpu_tuple_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of processing each tuple (row).',
  flags => 'GUC_EXPLAIN',
  variable => 'cpu_tuple_cost',
  boot_val => 'DEFAULT_CPU_TUPLE_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'cpu_index_tuple_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of processing each index entry during an index scan.',
  flags => 'GUC_EXPLAIN',
  variable => 'cpu_index_tuple_cost',
  boot_val => 'DEFAULT_CPU_INDEX_TUPLE_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'cpu_operator_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of processing each operator or function call.',
  flags => 'GUC_EXPLAIN',
  variable => 'cpu_operator_cost',
  boot_val => 'DEFAULT_CPU_OPERATOR_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'parallel_tuple_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of passing each tuple (row) from worker to leader backend.',
  flags => 'GUC_EXPLAIN',
  variable => 'parallel_tuple_cost',
  boot_val => 'DEFAULT_PARALLEL_TUPLE_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'parallel_setup_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the planner\'s estimate of the cost of starting up worker processes for parallel query.',
  flags => 'GUC_EXPLAIN',
  variable => 'parallel_setup_cost',
  boot_val => 'DEFAULT_PARALLEL_SETUP_COST',
  min => '0',
  max => 'DBL_MAX',
},

{ name => 'jit_above_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Perform JIT compilation if query is more expensive.',
  long_desc => '-1 disables JIT compilation.',
  flags => 'GUC_EXPLAIN',
  variable => 'jit_above_cost',
  boot_val => '100000',
  min => '-1',
  max => 'DBL_MAX',
},

{ name => 'jit_optimize_above_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Optimize JIT-compiled functions if query is more expensive.',
  long_desc => '-1 disables optimization.',
  flags => 'GUC_EXPLAIN',
  variable => 'jit_optimize_above_cost',
  boot_val => '500000',
  min => '-1',
  max => 'DBL_MAX',
},

{ name => 'jit_inline_above_cost', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Perform JIT inlining if query is more expensive.',
  long_desc => '-1 disables inlining.',
  flags => 'GUC_EXPLAIN',
  variable => 'jit_inline_above_cost',
  boot_val => '500000',
  min => '-1',
  max => 'DBL_MAX',
},

{ name => 'min_eager_agg_group_size', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_COST',
  short_desc => 'Sets the minimum average group size required to consider applying eager aggregation.',
  flags => 'GUC_EXPLAIN',
  variable => 'min_eager_agg_group_size',
  boot_val => '8.0',
  min => '0.0',
  max => 'DBL_MAX',
},

{ name => 'cursor_tuple_fraction', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Sets the planner\'s estimate of the fraction of a cursor\'s rows that will be retrieved.',
  flags => 'GUC_EXPLAIN',
  variable => 'cursor_tuple_fraction',
  boot_val => 'DEFAULT_CURSOR_TUPLE_FRACTION',
  min => '0.0',
  max => '1.0',
},

{ name => 'recursive_worktable_factor', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Sets the planner\'s estimate of the average size of a recursive query\'s working table.',
  flags => 'GUC_EXPLAIN',
  variable => 'recursive_worktable_factor',
  boot_val => 'DEFAULT_RECURSIVE_WORKTABLE_FACTOR',
  min => '0.001',
  max => '1000000.0',
},

{ name => 'geqo_selection_bias', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'GEQO: selective pressure within the population.',
  flags => 'GUC_EXPLAIN',
  variable => 'Geqo_selection_bias',
  boot_val => 'DEFAULT_GEQO_SELECTION_BIAS',
  min => 'MIN_GEQO_SELECTION_BIAS',
  max => 'MAX_GEQO_SELECTION_BIAS',
},

{ name => 'geqo_seed', type => 'real', context => 'PGC_USERSET', group => 'QUERY_TUNING_GEQO',
  short_desc => 'GEQO: seed for random path selection.',
  flags => 'GUC_EXPLAIN',
  variable => 'Geqo_seed',
  boot_val => '0.0',
  min => '0.0',
  max => '1.0',
},

{ name => 'hash_mem_multiplier', type => 'real', context => 'PGC_USERSET', group => 'RESOURCES_MEM',
  short_desc => 'Multiple of "work_mem" to use for hash tables.',
  flags => 'GUC_EXPLAIN',
  variable => 'hash_mem_multiplier',
  boot_val => '2.0',
  min => '1.0',
  max => '1000.0',
},

{ name => 'bgwriter_lru_multiplier', type => 'real', context => 'PGC_SIGHUP', group => 'RESOURCES_BGWRITER',
  short_desc => 'Multiple of the average buffer usage to free per round.',
  variable => 'bgwriter_lru_multiplier',
  boot_val => '2.0',
  min => '0.0',
  max => '10.0',
},

{ name => 'seed', type => 'real', context => 'PGC_USERSET', group => 'UNGROUPED',
  short_desc => 'Sets the seed for random-number generation.',
  flags => 'GUC_NO_SHOW_ALL | GUC_NO_RESET | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'phony_random_seed',
  boot_val => '0.0',
  min => '-1.0',
  max => '1.0',
  check_hook => 'check_random_seed',
  assign_hook => 'assign_random_seed',
  show_hook => 'show_random_seed',
},

{ name => 'vacuum_cost_delay', type => 'real', context => 'PGC_USERSET', group => 'VACUUM_COST_DELAY',
  short_desc => 'Vacuum cost delay in milliseconds.',
  flags => 'GUC_UNIT_MS',
  variable => 'VacuumCostDelay',
  boot_val => '0',
  min => '0',
  max => '100',
},

{ name => 'autovacuum_vacuum_cost_delay', type => 'real', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Vacuum cost delay in milliseconds, for autovacuum.',
  long_desc => '-1 means use "vacuum_cost_delay".',
  flags => 'GUC_UNIT_MS',
  variable => 'autovacuum_vac_cost_delay',
  boot_val => '2',
  min => '-1',
  max => '100',
},

{ name => 'autovacuum_vacuum_scale_factor', type => 'real', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Number of tuple updates or deletes prior to vacuum as a fraction of reltuples.',
  variable => 'autovacuum_vac_scale',
  boot_val => '0.2',
  min => '0.0',
  max => '100.0',
},

{ name => 'autovacuum_vacuum_insert_scale_factor', type => 'real', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Number of tuple inserts prior to vacuum as a fraction of reltuples.',
  variable => 'autovacuum_vac_ins_scale',
  boot_val => '0.2',
  min => '0.0',
  max => '100.0',
},

{ name => 'autovacuum_analyze_scale_factor', type => 'real', context => 'PGC_SIGHUP', group => 'VACUUM_AUTOVACUUM',
  short_desc => 'Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples.',
  variable => 'autovacuum_anl_scale',
  boot_val => '0.1',
  min => '0.0',
  max => '100.0',
},

{ name => 'checkpoint_completion_target', type => 'real', context => 'PGC_SIGHUP', group => 'WAL_CHECKPOINTS',
  short_desc => 'Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval.',
  variable => 'CheckPointCompletionTarget',
  boot_val => '0.9',
  min => '0.0',
  max => '1.0',
  assign_hook => 'assign_checkpoint_completion_target',
},

{ name => 'log_statement_sample_rate', type => 'real', context => 'PGC_SUSET', group => 'LOGGING_WHEN',
  short_desc => 'Fraction of statements exceeding "log_min_duration_sample" to be logged.',
  long_desc => 'Use a value between 0.0 (never log) and 1.0 (always log).',
  variable => 'log_statement_sample_rate',
  boot_val => '1.0',
  min => '0.0',
  max => '1.0',
},

{ name => 'log_transaction_sample_rate', type => 'real', context => 'PGC_SUSET', group => 'LOGGING_WHEN',
  short_desc => 'Sets the fraction of transactions from which to log all statements.',
  long_desc => 'Use a value between 0.0 (never log) and 1.0 (log all statements for all transactions).',
  variable => 'log_xact_sample_rate',
  boot_val => '0.0',
  min => '0.0',
  max => '1.0',
},

{ name => 'vacuum_max_eager_freeze_failure_rate', type => 'real', context => 'PGC_USERSET', group => 'VACUUM_FREEZING',
  short_desc => 'Fraction of pages in a relation vacuum can scan and fail to freeze before disabling eager scanning.',
  long_desc => 'A value of 0.0 disables eager scanning and a value of 1.0 will eagerly scan up to 100 percent of the all-visible pages in the relation. If vacuum successfully freezes these pages, the cap is lower than 100 percent, because the goal is to amortize page freezing across multiple vacuums.',
  variable => 'vacuum_max_eager_freeze_failure_rate',
  boot_val => '0.03',
  min => '0.0',
  max => '1.0',
},


{ name => 'archive_command', type => 'string', context => 'PGC_SIGHUP', group => 'WAL_ARCHIVING',
  short_desc => 'Sets the shell command that will be called to archive a WAL file.',
  long_desc => 'An empty string means use "archive_library".',
  variable => 'XLogArchiveCommand',
  boot_val => '""',
  show_hook => 'show_archive_command',
},

{ name => 'archive_library', type => 'string', context => 'PGC_SIGHUP', group => 'WAL_ARCHIVING',
  short_desc => 'Sets the library that will be called to archive a WAL file.',
  long_desc => 'An empty string means use "archive_command".',
  variable => 'XLogArchiveLibrary',
  boot_val => '""',
},

{ name => 'restore_command', type => 'string', context => 'PGC_SIGHUP', group => 'WAL_ARCHIVE_RECOVERY',
  short_desc => 'Sets the shell command that will be called to retrieve an archived WAL file.',
  variable => 'recoveryRestoreCommand',
  boot_val => '""',
},

{ name => 'archive_cleanup_command', type => 'string', context => 'PGC_SIGHUP', group => 'WAL_ARCHIVE_RECOVERY',
  short_desc => 'Sets the shell command that will be executed at every restart point.',
  variable => 'archiveCleanupCommand',
  boot_val => '""',
},

{ name => 'recovery_end_command', type => 'string', context => 'PGC_SIGHUP', group => 'WAL_ARCHIVE_RECOVERY',
  short_desc => 'Sets the shell command that will be executed once at the end of recovery.',
  variable => 'recoveryEndCommand',
  boot_val => '""',
},

{ name => 'recovery_target_timeline', type => 'string', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Specifies the timeline to recover into.',
  variable => 'recovery_target_timeline_string',
  boot_val => '"latest"',
  check_hook => 'check_recovery_target_timeline',
  assign_hook => 'assign_recovery_target_timeline',
},

{ name => 'recovery_target', type => 'string', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Set to "immediate" to end recovery as soon as a consistent state is reached.',
  variable => 'recovery_target_string',
  boot_val => '""',
  check_hook => 'check_recovery_target',
  assign_hook => 'assign_recovery_target',
},

{ name => 'recovery_target_xid', type => 'string', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Sets the transaction ID up to which recovery will proceed.',
  variable => 'recovery_target_xid_string',
  boot_val => '""',
  check_hook => 'check_recovery_target_xid',
  assign_hook => 'assign_recovery_target_xid',
},

{ name => 'recovery_target_time', type => 'string', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Sets the time stamp up to which recovery will proceed.',
  variable => 'recovery_target_time_string',
  boot_val => '""',
  check_hook => 'check_recovery_target_time',
  assign_hook => 'assign_recovery_target_time',
},

{ name => 'recovery_target_name', type => 'string', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Sets the named restore point up to which recovery will proceed.',
  variable => 'recovery_target_name_string',
  boot_val => '""',
  check_hook => 'check_recovery_target_name',
  assign_hook => 'assign_recovery_target_name',
},

{ name => 'recovery_target_lsn', type => 'string', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Sets the LSN of the write-ahead log location up to which recovery will proceed.',
  variable => 'recovery_target_lsn_string',
  boot_val => '""',
  check_hook => 'check_recovery_target_lsn',
  assign_hook => 'assign_recovery_target_lsn',
},

{ name => 'primary_conninfo', type => 'string', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the connection string to be used to connect to the sending server.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'PrimaryConnInfo',
  boot_val => '""',
},

{ name => 'primary_slot_name', type => 'string', context => 'PGC_SIGHUP', group => 'REPLICATION_STANDBY',
  short_desc => 'Sets the name of the replication slot to use on the sending server.',
  variable => 'PrimarySlotName',
  boot_val => '""',
  check_hook => 'check_primary_slot_name',
},

{ name => 'client_encoding', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the client\'s character set encoding.',
  flags => 'GUC_IS_NAME | GUC_REPORT',
  variable => 'client_encoding_string',
  boot_val => '"SQL_ASCII"',
  check_hook => 'check_client_encoding',
  assign_hook => 'assign_client_encoding',
},

{ name => 'log_line_prefix', type => 'string', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Controls information prefixed to each log line.',
  long_desc => 'An empty string means no prefix.',
  variable => 'Log_line_prefix',
  boot_val => '"%m [%p] "',
},

{ name => 'log_timezone', type => 'string', context => 'PGC_SIGHUP', group => 'LOGGING_WHAT',
  short_desc => 'Sets the time zone to use in log messages.',
  variable => 'log_timezone_string',
  boot_val => '"GMT"',
  check_hook => 'check_log_timezone',
  assign_hook => 'assign_log_timezone',
  show_hook => 'show_log_timezone',
},

{ name => 'DateStyle', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the display format for date and time values.',
  long_desc => 'Also controls interpretation of ambiguous date inputs.',
  flags => 'GUC_LIST_INPUT | GUC_REPORT',
  variable => 'datestyle_string',
  boot_val => '"ISO, MDY"',
  check_hook => 'check_datestyle',
  assign_hook => 'assign_datestyle',
},

{ name => 'default_table_access_method', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the default table access method for new tables.',
  flags => 'GUC_IS_NAME',
  variable => 'default_table_access_method',
  boot_val => 'DEFAULT_TABLE_ACCESS_METHOD',
  check_hook => 'check_default_table_access_method',
},

{ name => 'default_tablespace', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the default tablespace to create tables and indexes in.',
  long_desc => 'An empty string means use the database\'s default tablespace.',
  flags => 'GUC_IS_NAME',
  variable => 'default_tablespace',
  boot_val => '""',
  check_hook => 'check_default_tablespace',
},

{ name => 'temp_tablespaces', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the tablespace(s) to use for temporary tables and sort files.',
  long_desc => 'An empty string means use the database\'s default tablespace.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE',
  variable => 'temp_tablespaces',
  boot_val => '""',
  check_hook => 'check_temp_tablespaces',
  assign_hook => 'assign_temp_tablespaces',
},

{ name => 'createrole_self_grant', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets whether a CREATEROLE user automatically grants the role to themselves, and with which options.',
  long_desc => 'An empty string disables automatic self grants.',
  flags => 'GUC_LIST_INPUT',
  variable => 'createrole_self_grant',
  boot_val => '""',
  check_hook => 'check_createrole_self_grant',
  assign_hook => 'assign_createrole_self_grant',
},

{ name => 'dynamic_library_path', type => 'string', context => 'PGC_SUSET', group => 'CLIENT_CONN_OTHER',
  short_desc => 'Sets the path for dynamically loadable modules.',
  long_desc => 'If a dynamically loadable module needs to be opened and the specified name does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the specified file.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'Dynamic_library_path',
  boot_val => '"$libdir"',
},

{ name => 'extension_control_path', type => 'string', context => 'PGC_SUSET', group => 'CLIENT_CONN_OTHER',
  short_desc => 'Sets the path for extension control files.',
  long_desc => 'The remaining extension script and secondary control files are then loaded from the same directory where the primary control file was found.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'Extension_control_path',
  boot_val => '"$system"',
},

{ name => 'krb_server_keyfile', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_AUTH',
  short_desc => 'Sets the location of the Kerberos server key file.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'pg_krb_server_keyfile',
  boot_val => 'PG_KRB_SRVTAB',
},

{ name => 'bonjour_name', type => 'string', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the Bonjour service name.',
  long_desc => 'An empty string means use the computer name.',
  variable => 'bonjour_name',
  boot_val => '""',
},

{ name => 'lc_messages', type => 'string', context => 'PGC_SUSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the language in which messages are displayed.',
  long_desc => 'An empty string means use the operating system setting.',
  variable => 'locale_messages',
  boot_val => '""',
  check_hook => 'check_locale_messages',
  assign_hook => 'assign_locale_messages',
},

{ name => 'lc_monetary', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the locale for formatting monetary amounts.',
  long_desc => 'An empty string means use the operating system setting.',
  variable => 'locale_monetary',
  boot_val => '"C"',
  check_hook => 'check_locale_monetary',
  assign_hook => 'assign_locale_monetary',
},

{ name => 'lc_numeric', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the locale for formatting numbers.',
  long_desc => 'An empty string means use the operating system setting.',
  variable => 'locale_numeric',
  boot_val => '"C"',
  check_hook => 'check_locale_numeric',
  assign_hook => 'assign_locale_numeric',
},

{ name => 'lc_time', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the locale for formatting date and time values.',
  long_desc => 'An empty string means use the operating system setting.',
  variable => 'locale_time',
  boot_val => '"C"',
  check_hook => 'check_locale_time',
  assign_hook => 'assign_locale_time',
},

{ name => 'session_preload_libraries', type => 'string', context => 'PGC_SUSET', group => 'CLIENT_CONN_PRELOAD',
  short_desc => 'Lists shared libraries to preload into each backend.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY',
  variable => 'session_preload_libraries_string',
  boot_val => '""',
},

{ name => 'shared_preload_libraries', type => 'string', context => 'PGC_POSTMASTER', group => 'CLIENT_CONN_PRELOAD',
  short_desc => 'Lists shared libraries to preload into server.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY',
  variable => 'shared_preload_libraries_string',
  boot_val => '""',
},

{ name => 'local_preload_libraries', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_PRELOAD',
  short_desc => 'Lists unprivileged shared libraries to preload into each backend.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE',
  variable => 'local_preload_libraries_string',
  boot_val => '""',
},

{ name => 'search_path', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the schema search order for names that are not schema-qualified.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_EXPLAIN | GUC_REPORT',
  variable => 'namespace_search_path',
  boot_val => '"\"$user\", public"',
  check_hook => 'check_search_path',
  assign_hook => 'assign_search_path',
},

# Can't be set in postgresql.conf
{ name => 'server_encoding', type => 'string', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the server (database) character set encoding.',
  flags => 'GUC_IS_NAME | GUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'server_encoding_string',
  boot_val => '"SQL_ASCII"',
},

# Can't be set in postgresql.conf
{ name => 'server_version', type => 'string', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the server version.',
  flags => 'GUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'server_version_string',
  boot_val => 'PG_VERSION',
},

# Not for general use --- used by SET ROLE
{ name => 'role', type => 'string', context => 'PGC_USERSET', group => 'UNGROUPED',
  short_desc => 'Sets the current role.',
  flags => 'GUC_IS_NAME | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_NOT_WHILE_SEC_REST',
  variable => 'role_string',
  boot_val => '"none"',
  check_hook => 'check_role',
  assign_hook => 'assign_role',
  show_hook => 'show_role',
},

# Not for general use --- used by SET SESSION AUTHORIZATION
{ name => 'session_authorization', type => 'string', context => 'PGC_USERSET', group => 'UNGROUPED',
  short_desc => 'Sets the session user name.',
  flags => 'GUC_IS_NAME | GUC_REPORT | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_NOT_WHILE_SEC_REST',
  variable => 'session_authorization_string',
  boot_val => 'NULL',
  check_hook => 'check_session_authorization',
  assign_hook => 'assign_session_authorization',
},

{ name => 'log_destination', type => 'string', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the destination for server log output.',
  long_desc => 'Valid values are combinations of "stderr", "syslog", "csvlog", "jsonlog", and "eventlog", depending on the platform.',
  flags => 'GUC_LIST_INPUT',
  variable => 'Log_destination_string',
  boot_val => '"stderr"',
  check_hook => 'check_log_destination',
  assign_hook => 'assign_log_destination',
},

{ name => 'log_directory', type => 'string', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the destination directory for log files.',
  long_desc => 'Can be specified as relative to the data directory or as absolute path.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'Log_directory',
  boot_val => '"log"',
  check_hook => 'check_canonical_path',
},

{ name => 'log_filename', type => 'string', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the file name pattern for log files.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'Log_filename',
  boot_val => '"postgresql-%Y-%m-%d_%H%M%S.log"',
},

{ name => 'syslog_ident', type => 'string', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the program name used to identify PostgreSQL messages in syslog.',
  variable => 'syslog_ident_str',
  boot_val => '"postgres"',
  assign_hook => 'assign_syslog_ident',
},

{ name => 'event_source', type => 'string', context => 'PGC_POSTMASTER', group => 'LOGGING_WHERE',
  short_desc => 'Sets the application name used to identify PostgreSQL messages in the event log.',
  variable => 'event_source',
  boot_val => 'DEFAULT_EVENT_SOURCE',
},

{ name => 'TimeZone', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the time zone for displaying and interpreting time stamps.',
  flags => 'GUC_REPORT',
  variable => 'timezone_string',
  boot_val => '"GMT"',
  check_hook => 'check_timezone',
  assign_hook => 'assign_timezone',
  show_hook => 'show_timezone',
},

{ name => 'timezone_abbreviations', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Selects a file of time zone abbreviations.',
  variable => 'timezone_abbreviations_string',
  boot_val => 'NULL',
  check_hook => 'check_timezone_abbreviations',
  assign_hook => 'assign_timezone_abbreviations',
},

{ name => 'unix_socket_group', type => 'string', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the owning group of the Unix-domain socket.',
  long_desc => 'The owning user of the socket is always the user that starts the server. An empty string means use the user\'s default group.',
  variable => 'Unix_socket_group',
  boot_val => '""',
},

{ name => 'unix_socket_directories', type => 'string', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the directories where Unix-domain sockets will be created.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY',
  variable => 'Unix_socket_directories',
  boot_val => 'DEFAULT_PGSOCKET_DIR',
},

{ name => 'listen_addresses', type => 'string', context => 'PGC_POSTMASTER', group => 'CONN_AUTH_SETTINGS',
  short_desc => 'Sets the host name or IP address(es) to listen to.',
  flags => 'GUC_LIST_INPUT',
  variable => 'ListenAddresses',
  boot_val => '"localhost"',
},

# Can't be set by ALTER SYSTEM as it can lead to recursive definition
# of data_directory.
{ name => 'data_directory', type => 'string', context => 'PGC_POSTMASTER', group => 'FILE_LOCATIONS',
  short_desc => 'Sets the server\'s data directory.',
  flags => 'GUC_SUPERUSER_ONLY | GUC_DISALLOW_IN_AUTO_FILE',
  variable => 'data_directory',
  boot_val => 'NULL',
},

{ name => 'config_file', type => 'string', context => 'PGC_POSTMASTER', group => 'FILE_LOCATIONS',
  short_desc => 'Sets the server\'s main configuration file.',
  flags => 'GUC_DISALLOW_IN_FILE | GUC_SUPERUSER_ONLY',
  variable => 'ConfigFileName',
  boot_val => 'NULL',
},

{ name => 'hba_file', type => 'string', context => 'PGC_POSTMASTER', group => 'FILE_LOCATIONS',
  short_desc => 'Sets the server\'s "hba" configuration file.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'HbaFileName',
  boot_val => 'NULL',
},

{ name => 'ident_file', type => 'string', context => 'PGC_POSTMASTER', group => 'FILE_LOCATIONS',
  short_desc => 'Sets the server\'s "ident" configuration file.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'IdentFileName',
  boot_val => 'NULL',
},

{ name => 'external_pid_file', type => 'string', context => 'PGC_POSTMASTER', group => 'FILE_LOCATIONS',
  short_desc => 'Writes the postmaster PID to the specified file.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'external_pid_file',
  boot_val => 'NULL',
  check_hook => 'check_canonical_path',
},

{ name => 'ssl_library', type => 'string', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Shows the name of the SSL library.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'ssl_library',
  boot_val => 'SSL_LIBRARY',
},

{ name => 'ssl_cert_file', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Location of the SSL server certificate file.',
  variable => 'ssl_cert_file',
  boot_val => '"server.crt"',
},

{ name => 'ssl_key_file', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Location of the SSL server private key file.',
  variable => 'ssl_key_file',
  boot_val => '"server.key"',
},

{ name => 'ssl_ca_file', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Location of the SSL certificate authority file.',
  variable => 'ssl_ca_file',
  boot_val => '""',
},

{ name => 'ssl_crl_file', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Location of the SSL certificate revocation list file.',
  variable => 'ssl_crl_file',
  boot_val => '""',
},

{ name => 'ssl_crl_dir', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Location of the SSL certificate revocation list directory.',
  variable => 'ssl_crl_dir',
  boot_val => '""',
},

{ name => 'synchronous_standby_names', type => 'string', context => 'PGC_SIGHUP', group => 'REPLICATION_PRIMARY',
  short_desc => 'Number of synchronous standbys and list of names of potential synchronous ones.',
  flags => 'GUC_LIST_INPUT',
  variable => 'SyncRepStandbyNames',
  boot_val => '""',
  check_hook => 'check_synchronous_standby_names',
  assign_hook => 'assign_synchronous_standby_names',
},

{ name => 'default_text_search_config', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets default text search configuration.',
  variable => 'TSCurrentConfig',
  boot_val => '"pg_catalog.simple"',
  check_hook => 'check_default_text_search_config',
  assign_hook => 'assign_default_text_search_config',
},

{ name => 'ssl_tls13_ciphers', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Sets the list of allowed TLSv1.3 cipher suites.',
  long_desc => 'An empty string means use the default cipher suites.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'SSLCipherSuites',
  boot_val => '""',
},

{ name => 'ssl_ciphers', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Sets the list of allowed TLSv1.2 (and lower) ciphers.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'SSLCipherList',
  boot_val => 'DEFAULT_SSL_CIPHERS',
},

{ name => 'ssl_groups', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Sets the group(s) to use for Diffie-Hellman key exchange.',
  long_desc => 'Multiple groups can be specified using a colon-separated list.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'SSLECDHCurve',
  boot_val => 'DEFAULT_SSL_GROUPS',
},

{ name => 'ssl_dh_params_file', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Location of the SSL DH parameters file.',
  long_desc => 'An empty string means use compiled-in default parameters.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'ssl_dh_params_file',
  boot_val => '""',
},

{ name => 'ssl_passphrase_command', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Command to obtain passphrases for SSL.',
  long_desc => 'An empty string means use the built-in prompting mechanism.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'ssl_passphrase_command',
  boot_val => '""',
},

{ name => 'application_name', type => 'string', context => 'PGC_USERSET', group => 'LOGGING_WHAT',
  short_desc => 'Sets the application name to be reported in statistics and logs.',
  flags => 'GUC_IS_NAME | GUC_REPORT | GUC_NOT_IN_SAMPLE',
  variable => 'application_name',
  boot_val => '""',
  check_hook => 'check_application_name',
  assign_hook => 'assign_application_name',
},

{ name => 'cluster_name', type => 'string', context => 'PGC_POSTMASTER', group => 'PROCESS_TITLE',
  short_desc => 'Sets the name of the cluster, which is included in the process title.',
  flags => 'GUC_IS_NAME',
  variable => 'cluster_name',
  boot_val => '""',
  check_hook => 'check_cluster_name',
},

{ name => 'wal_consistency_checking', type => 'string', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Sets the WAL resource managers for which WAL consistency checks are done.',
  long_desc => 'Full-page images will be logged for all data blocks and cross-checked against the results of WAL replay.',
  flags => 'GUC_LIST_INPUT | GUC_NOT_IN_SAMPLE',
  variable => 'wal_consistency_checking_string',
  boot_val => '""',
  check_hook => 'check_wal_consistency_checking',
  assign_hook => 'assign_wal_consistency_checking',
},

{ name => 'jit_provider', type => 'string', context => 'PGC_POSTMASTER', group => 'CLIENT_CONN_PRELOAD',
  short_desc => 'JIT provider to use.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'jit_provider',
  boot_val => '"llvmjit"',
},

{ name => 'backtrace_functions', type => 'string', context => 'PGC_SUSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Log backtrace for errors in these functions.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'backtrace_functions',
  boot_val => '""',
  check_hook => 'check_backtrace_functions',
  assign_hook => 'assign_backtrace_functions',
},

{ name => 'debug_io_direct', type => 'string', context => 'PGC_POSTMASTER', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Use direct I/O for file access.',
  long_desc => 'An empty string disables direct I/O.',
  flags => 'GUC_LIST_INPUT | GUC_NOT_IN_SAMPLE',
  variable => 'debug_io_direct_string',
  boot_val => '""',
  check_hook => 'check_debug_io_direct',
  assign_hook => 'assign_debug_io_direct',
},

{ name => 'synchronized_standby_slots', type => 'string', context => 'PGC_SIGHUP', group => 'REPLICATION_PRIMARY',
  short_desc => 'Lists streaming replication standby server replication slot names that logical WAL sender processes will wait for.',
  long_desc => 'Logical WAL sender processes will send decoded changes to output plugins only after the specified replication slots have confirmed receiving WAL.',
  flags => 'GUC_LIST_INPUT',
  variable => 'synchronized_standby_slots',
  boot_val => '""',
  check_hook => 'check_synchronized_standby_slots',
  assign_hook => 'assign_synchronized_standby_slots',
},

{ name => 'restrict_nonsystem_relation_kind', type => 'string', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Prohibits access to non-system relations of specified kinds.',
  flags => 'GUC_LIST_INPUT | GUC_NOT_IN_SAMPLE',
  variable => 'restrict_nonsystem_relation_kind_string',
  boot_val => '""',
  check_hook => 'check_restrict_nonsystem_relation_kind',
  assign_hook => 'assign_restrict_nonsystem_relation_kind',
},

{ name => 'oauth_validator_libraries', type => 'string', context => 'PGC_SIGHUP', group => 'CONN_AUTH_AUTH',
  short_desc => 'Lists libraries that may be called to validate OAuth v2 bearer tokens.',
  flags => 'GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY',
  variable => 'oauth_validator_libraries_string',
  boot_val => '""',
},

{ name => 'log_connections', type => 'string', context => 'PGC_SU_BACKEND', group => 'LOGGING_WHAT',
  short_desc => 'Logs specified aspects of connection establishment and setup.',
  flags => 'GUC_LIST_INPUT',
  variable => 'log_connections_string',
  boot_val => '""',
  check_hook => 'check_log_connections',
  assign_hook => 'assign_log_connections',
},

{ name => 'backslash_quote', type => 'enum', context => 'PGC_USERSET', group => 'COMPAT_OPTIONS_PREVIOUS',
  short_desc => 'Sets whether "\\\\\'" is allowed in string literals.',
  variable => 'backslash_quote',
  boot_val => 'BACKSLASH_QUOTE_SAFE_ENCODING',
  options => 'backslash_quote_options',
},

{ name => 'bytea_output', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the output format for bytea.',
  variable => 'bytea_output',
  boot_val => 'BYTEA_OUTPUT_HEX',
  options => 'bytea_output_options',
},

{ name => 'client_min_messages', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the message levels that are sent to the client.',
  long_desc => 'Each level includes all the levels that follow it. The later the level, the fewer messages are sent.',
  variable => 'client_min_messages',
  boot_val => 'NOTICE',
  options => 'client_message_level_options',
},

{ name => 'compute_query_id', type => 'enum', context => 'PGC_SUSET', group => 'STATS_MONITORING',
  short_desc => 'Enables in-core computation of query identifiers.',
  variable => 'compute_query_id',
  boot_val => 'COMPUTE_QUERY_ID_AUTO',
  options => 'compute_query_id_options',
},

{ name => 'constraint_exclusion', type => 'enum', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Enables the planner to use constraints to optimize queries.',
  long_desc => 'Table scans will be skipped if their constraints guarantee that no rows match the query.',
  flags => 'GUC_EXPLAIN',
  variable => 'constraint_exclusion',
  boot_val => 'CONSTRAINT_EXCLUSION_PARTITION',
  options => 'constraint_exclusion_options',
},

{ name => 'default_toast_compression', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the default compression method for compressible values.',
  variable => 'default_toast_compression',
  boot_val => 'TOAST_PGLZ_COMPRESSION',
  options => 'default_toast_compression_options',
},

{ name => 'default_transaction_isolation', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the transaction isolation level of each new transaction.',
  variable => 'DefaultXactIsoLevel',
  boot_val => 'XACT_READ_COMMITTED',
  options => 'isolation_level_options',
},

{ name => 'transaction_isolation', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the current transaction\'s isolation level.',
  flags => 'GUC_NO_RESET | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'XactIsoLevel',
  boot_val => 'XACT_READ_COMMITTED',
  options => 'isolation_level_options',
  check_hook => 'check_transaction_isolation',
},

{ name => 'IntervalStyle', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Sets the display format for interval values.',
  flags => 'GUC_REPORT',
  variable => 'IntervalStyle',
  boot_val => 'INTSTYLE_POSTGRES',
  options => 'intervalstyle_options',
},

{ name => 'icu_validation_level', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_LOCALE',
  short_desc => 'Log level for reporting invalid ICU locale strings.',
  variable => 'icu_validation_level',
  boot_val => 'WARNING',
  options => 'icu_validation_level_options',
},

{ name => 'log_error_verbosity', type => 'enum', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Sets the verbosity of logged messages.',
  variable => 'Log_error_verbosity',
  boot_val => 'PGERROR_DEFAULT',
  options => 'log_error_verbosity_options',
},

{ name => 'log_min_messages', type => 'enum', context => 'PGC_SUSET', group => 'LOGGING_WHEN',
  short_desc => 'Sets the message levels that are logged.',
  long_desc => 'Each level includes all the levels that follow it. The later the level, the fewer messages are sent.',
  variable => 'log_min_messages',
  boot_val => 'WARNING',
  options => 'server_message_level_options',
},

{ name => 'log_min_error_statement', type => 'enum', context => 'PGC_SUSET', group => 'LOGGING_WHEN',
  short_desc => 'Causes all statements generating error at or above this level to be logged.',
  long_desc => 'Each level includes all the levels that follow it. The later the level, the fewer messages are sent.',
  variable => 'log_min_error_statement',
  boot_val => 'ERROR',
  options => 'server_message_level_options',
},

{ name => 'log_statement', type => 'enum', context => 'PGC_SUSET', group => 'LOGGING_WHAT',
  short_desc => 'Sets the type of statements logged.',
  variable => 'log_statement',
  boot_val => 'LOGSTMT_NONE',
  options => 'log_statement_options',
},

{ name => 'syslog_facility', type => 'enum', context => 'PGC_SIGHUP', group => 'LOGGING_WHERE',
  short_desc => 'Sets the syslog "facility" to be used when syslog enabled.',
  variable => 'syslog_facility',
  boot_val => 'DEFAULT_SYSLOG_FACILITY',
  options => 'syslog_facility_options',
  assign_hook => 'assign_syslog_facility',
},

{ name => 'session_replication_role', type => 'enum', context => 'PGC_SUSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets the session\'s behavior for triggers and rewrite rules.',
  variable => 'SessionReplicationRole',
  boot_val => 'SESSION_REPLICATION_ROLE_ORIGIN',
  options => 'session_replication_role_options',
  assign_hook => 'assign_session_replication_role',
},

{ name => 'synchronous_commit', type => 'enum', context => 'PGC_USERSET', group => 'WAL_SETTINGS',
  short_desc => 'Sets the current transaction\'s synchronization level.',
  variable => 'synchronous_commit',
  boot_val => 'SYNCHRONOUS_COMMIT_ON',
  options => 'synchronous_commit_options',
  assign_hook => 'assign_synchronous_commit',
},

{ name => 'archive_mode', type => 'enum', context => 'PGC_POSTMASTER', group => 'WAL_ARCHIVING',
  short_desc => 'Allows archiving of WAL files using "archive_command".',
  variable => 'XLogArchiveMode',
  boot_val => 'ARCHIVE_MODE_OFF',
  options => 'archive_mode_options',
},

{ name => 'recovery_target_action', type => 'enum', context => 'PGC_POSTMASTER', group => 'WAL_RECOVERY_TARGET',
  short_desc => 'Sets the action to perform upon reaching the recovery target.',
  variable => 'recoveryTargetAction',
  boot_val => 'RECOVERY_TARGET_ACTION_PAUSE',
  options => 'recovery_target_action_options',
},

{ name => 'track_functions', type => 'enum', context => 'PGC_SUSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Collects function-level statistics on database activity.',
  variable => 'pgstat_track_functions',
  boot_val => 'TRACK_FUNC_OFF',
  options => 'track_function_options',
},

{ name => 'stats_fetch_consistency', type => 'enum', context => 'PGC_USERSET', group => 'STATS_CUMULATIVE',
  short_desc => 'Sets the consistency of accesses to statistics data.',
  variable => 'pgstat_fetch_consistency',
  boot_val => 'PGSTAT_FETCH_CONSISTENCY_CACHE',
  options => 'stats_fetch_consistency',
  assign_hook => 'assign_stats_fetch_consistency',
},

{ name => 'wal_compression', type => 'enum', context => 'PGC_SUSET', group => 'WAL_SETTINGS',
  short_desc => 'Compresses full-page writes written in WAL file with specified method.',
  variable => 'wal_compression',
  boot_val => 'WAL_COMPRESSION_NONE',
  options => 'wal_compression_options',
},

{ name => 'wal_level', type => 'enum', context => 'PGC_POSTMASTER', group => 'WAL_SETTINGS',
  short_desc => 'Sets the level of information written to the WAL.',
  variable => 'wal_level',
  boot_val => 'WAL_LEVEL_REPLICA',
  options => 'wal_level_options',
},

{ name => 'dynamic_shared_memory_type', type => 'enum', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Selects the dynamic shared memory implementation used.',
  variable => 'dynamic_shared_memory_type',
  boot_val => 'DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE',
  options => 'dynamic_shared_memory_options',
},

{ name => 'shared_memory_type', type => 'enum', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Selects the shared memory implementation used for the main shared memory region.',
  variable => 'shared_memory_type',
  boot_val => 'DEFAULT_SHARED_MEMORY_TYPE',
  options => 'shared_memory_options',
},

{ name => 'file_copy_method', type => 'enum', context => 'PGC_USERSET', group => 'RESOURCES_DISK',
  short_desc => 'Selects the file copy method.',
  variable => 'file_copy_method',
  boot_val => 'FILE_COPY_METHOD_COPY',
  options => 'file_copy_method_options',
},

{ name => 'wal_sync_method', type => 'enum', context => 'PGC_SIGHUP', group => 'WAL_SETTINGS',
  short_desc => 'Selects the method used for forcing WAL updates to disk.',
  variable => 'wal_sync_method',
  boot_val => 'DEFAULT_WAL_SYNC_METHOD',
  options => 'wal_sync_method_options',
  assign_hook => 'assign_wal_sync_method',
},

{ name => 'xmlbinary', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets how binary values are to be encoded in XML.',
  variable => 'xmlbinary',
  boot_val => 'XMLBINARY_BASE64',
  options => 'xmlbinary_options',
},

{ name => 'xmloption', type => 'enum', context => 'PGC_USERSET', group => 'CLIENT_CONN_STATEMENT',
  short_desc => 'Sets whether XML data in implicit parsing and serialization operations is to be considered as documents or content fragments.',
  variable => 'xmloption',
  boot_val => 'XMLOPTION_CONTENT',
  options => 'xmloption_options',
},

{ name => 'huge_pages', type => 'enum', context => 'PGC_POSTMASTER', group => 'RESOURCES_MEM',
  short_desc => 'Use of huge pages on Linux or Windows.',
  variable => 'huge_pages',
  boot_val => 'HUGE_PAGES_TRY',
  options => 'huge_pages_options',
},

{ name => 'huge_pages_status', type => 'enum', context => 'PGC_INTERNAL', group => 'PRESET_OPTIONS',
  short_desc => 'Indicates the status of huge pages.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE',
  variable => 'huge_pages_status',
  boot_val => 'HUGE_PAGES_UNKNOWN',
  options => 'huge_pages_status_options',
},

{ name => 'recovery_prefetch', type => 'enum', context => 'PGC_SIGHUP', group => 'WAL_RECOVERY',
  short_desc => 'Prefetch referenced blocks during recovery.',
  long_desc => 'Look ahead in the WAL to find references to uncached data.',
  variable => 'recovery_prefetch',
  boot_val => 'RECOVERY_PREFETCH_TRY',
  options => 'recovery_prefetch_options',
  check_hook => 'check_recovery_prefetch',
  assign_hook => 'assign_recovery_prefetch',
},

{ name => 'debug_parallel_query', type => 'enum', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Forces the planner\'s use parallel query nodes.',
  long_desc => 'This can be useful for testing the parallel query infrastructure by forcing the planner to generate plans that contain nodes that perform tuple communication between workers and the main process.',
  flags => 'GUC_NOT_IN_SAMPLE | GUC_EXPLAIN',
  variable => 'debug_parallel_query',
  boot_val => 'DEBUG_PARALLEL_OFF',
  options => 'debug_parallel_query_options',
},

{ name => 'password_encryption', type => 'enum', context => 'PGC_USERSET', group => 'CONN_AUTH_AUTH',
  short_desc => 'Chooses the algorithm for encrypting passwords.',
  variable => 'Password_encryption',
  boot_val => 'PASSWORD_TYPE_SCRAM_SHA_256',
  options => 'password_encryption_options',
},

{ name => 'plan_cache_mode', type => 'enum', context => 'PGC_USERSET', group => 'QUERY_TUNING_OTHER',
  short_desc => 'Controls the planner\'s selection of custom or generic plan.',
  long_desc => 'Prepared statements can have custom and generic plans, and the planner will attempt to choose which is better.  This can be set to override the default behavior.',
  flags => 'GUC_EXPLAIN',
  variable => 'plan_cache_mode',
  boot_val => 'PLAN_CACHE_MODE_AUTO',
  options => 'plan_cache_mode_options',
},

{ name => 'ssl_min_protocol_version', type => 'enum', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Sets the minimum SSL/TLS protocol version to use.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'ssl_min_protocol_version',
  boot_val => 'PG_TLS1_2_VERSION',
  options => 'ssl_protocol_versions_info + 1', # don't allow PG_TLS_ANY
},

{ name => 'ssl_max_protocol_version', type => 'enum', context => 'PGC_SIGHUP', group => 'CONN_AUTH_SSL',
  short_desc => 'Sets the maximum SSL/TLS protocol version to use.',
  flags => 'GUC_SUPERUSER_ONLY',
  variable => 'ssl_max_protocol_version',
  boot_val => 'PG_TLS_ANY',
  options => 'ssl_protocol_versions_info',
},

{ name => 'recovery_init_sync_method', type => 'enum', context => 'PGC_SIGHUP', group => 'ERROR_HANDLING_OPTIONS',
  short_desc => 'Sets the method for synchronizing the data directory before crash recovery.',
  variable => 'recovery_init_sync_method',
  boot_val => 'DATA_DIR_SYNC_METHOD_FSYNC',
  options => 'recovery_init_sync_method_options',
},

{ name => 'debug_logical_replication_streaming', type => 'enum', context => 'PGC_USERSET', group => 'DEVELOPER_OPTIONS',
  short_desc => 'Forces immediate streaming or serialization of changes in large transactions.',
  long_desc => 'On the publisher, it allows streaming or serializing each change in logical decoding. On the subscriber, it allows serialization of all changes to files and notifies the parallel apply workers to read and apply them at the end of the transaction.',
  flags => 'GUC_NOT_IN_SAMPLE',
  variable => 'debug_logical_replication_streaming',
  boot_val => 'DEBUG_LOGICAL_REP_STREAMING_BUFFERED',
  options => 'debug_logical_replication_streaming_options',
},

{ name => 'io_method', type => 'enum', context => 'PGC_POSTMASTER', group => 'RESOURCES_IO',
  short_desc => 'Selects the method for executing asynchronous I/O.',
  variable => 'io_method',
  boot_val => 'DEFAULT_IO_METHOD',
  options => 'io_method_options',
  assign_hook => 'assign_io_method',
},

]
