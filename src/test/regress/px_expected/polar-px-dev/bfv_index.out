-- tests index filter with outer refs
/*--EXPLAIN_QUERY_BEGIN*/
drop table if exists bfv_tab1;
NOTICE:  table "bfv_tab1" does not exist, skipping
CREATE TABLE bfv_tab1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
create index bfv_tab1_idx1 on bfv_tab1 using btree(unique1);
-- GPDB_12_MERGE_FIXME: Non default collation
explain (costs off) select * from bfv_tab1, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
    WHERE bfv_tab1.unique1 = v.i and bfv_tab1.stringu1 = v.j;
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   ->  Values Scan on "*VALUES*"
   ->  Bitmap Heap Scan on bfv_tab1
         Recheck Cond: (unique1 = "*VALUES*".column1)
         Filter: ("*VALUES*".column2 = (stringu1)::text)
         ->  Bitmap Index Scan on bfv_tab1_idx1
               Index Cond: (unique1 = "*VALUES*".column1)
(7 rows)

set polar_px_enable_relsize_collection=on;
-- GPDB_12_MERGE_FIXME: Non default collation
explain (costs off) select * from bfv_tab1, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
    WHERE bfv_tab1.unique1 = v.i and bfv_tab1.stringu1 = v.j;
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   ->  Values Scan on "*VALUES*"
   ->  Bitmap Heap Scan on bfv_tab1
         Recheck Cond: (unique1 = "*VALUES*".column1)
         Filter: ("*VALUES*".column2 = (stringu1)::text)
         ->  Bitmap Index Scan on bfv_tab1_idx1
               Index Cond: (unique1 = "*VALUES*".column1)
(7 rows)

-- Test that we do not choose to perform an index scan if indisvalid=false.
create table bfv_tab1_with_invalid_index (like bfv_tab1 including indexes);
set allow_system_table_mods=on;
update pg_index set indisvalid=false where indrelid='bfv_tab1_with_invalid_index'::regclass;
reset allow_system_table_mods;
explain (costs off) select * from bfv_tab1_with_invalid_index where unique1>42;
               QUERY PLAN                
-----------------------------------------
 Seq Scan on bfv_tab1_with_invalid_index
   Filter: (unique1 > 42)
(2 rows)

-- Cannot currently upgrade table with invalid index
-- (see https://github.com/greenplum-db/gpdb/issues/10805).
drop table bfv_tab1_with_invalid_index;
reset polar_px_enable_relsize_collection;
--start_ignore
DROP TABLE IF EXISTS bfv_tab2_facttable1;
NOTICE:  table "bfv_tab2_facttable1" does not exist, skipping
DROP TABLE IF EXISTS bfv_tab2_dimdate;
NOTICE:  table "bfv_tab2_dimdate" does not exist, skipping
DROP TABLE IF EXISTS bfv_tab2_dimtabl1;
NOTICE:  table "bfv_tab2_dimtabl1" does not exist, skipping
--end_ignore
-- Bug-fix verification for MPP-25537: PANIC when bitmap index used in ORCA select
CREATE TABLE bfv_tab2_facttable1 (
col1 integer,
wk_id smallint,
id integer
)
partition by range (wk_id);
CREATE TABLE bfv_tab2_facttable1_1 PARTITION of bfv_tab2_facttable1 for values from (1) to (2);
CREATE TABLE bfv_tab2_facttable1_2 PARTITION of bfv_tab2_facttable1 for values from (2) to (3);
CREATE TABLE bfv_tab2_facttable1_3 PARTITION of bfv_tab2_facttable1 for values from (3) to (4);
CREATE TABLE bfv_tab2_facttable1_4 PARTITION of bfv_tab2_facttable1 for values from (4) to (5);
CREATE TABLE bfv_tab2_facttable1_5 PARTITION of bfv_tab2_facttable1 for values from (5) to (6);
CREATE TABLE bfv_tab2_facttable1_6 PARTITION of bfv_tab2_facttable1 for values from (6) to (7);
CREATE TABLE bfv_tab2_facttable1_7 PARTITION of bfv_tab2_facttable1 for values from (7) to (8);
CREATE TABLE bfv_tab2_facttable1_8 PARTITION of bfv_tab2_facttable1 for values from (8) to (9);
CREATE TABLE bfv_tab2_facttable1_9 PARTITION of bfv_tab2_facttable1 for values from (9) to (10);
CREATE TABLE bfv_tab2_facttable1_10 PARTITION of bfv_tab2_facttable1 for values from (10) to (11);
CREATE TABLE bfv_tab2_facttable1_11 PARTITION of bfv_tab2_facttable1 for values from (11) to (12);
CREATE TABLE bfv_tab2_facttable1_12 PARTITION of bfv_tab2_facttable1 for values from (12) to (13);
CREATE TABLE bfv_tab2_facttable1_13 PARTITION of bfv_tab2_facttable1 for values from (13) to (14);
CREATE TABLE bfv_tab2_facttable1_14 PARTITION of bfv_tab2_facttable1 for values from (14) to (15);
CREATE TABLE bfv_tab2_facttable1_15 PARTITION of bfv_tab2_facttable1 for values from (15) to (16);
CREATE TABLE bfv_tab2_facttable1_16 PARTITION of bfv_tab2_facttable1 for values from (16) to (17);
CREATE TABLE bfv_tab2_facttable1_17 PARTITION of bfv_tab2_facttable1 for values from (17) to (18);
CREATE TABLE bfv_tab2_facttable1_18 PARTITION of bfv_tab2_facttable1 for values from (18) to (19);
CREATE TABLE bfv_tab2_facttable1_19 PARTITION of bfv_tab2_facttable1 for values from (19) to (20);
CREATE TABLE bfv_tab2_facttable1_20 PARTITION of bfv_tab2_facttable1 default;
insert into bfv_tab2_facttable1 select col1, col1, col1 from (select generate_series(1,20) col1)a;
CREATE TABLE bfv_tab2_dimdate (
wk_id smallint,
col2 date
)
;
insert into bfv_tab2_dimdate select col1, current_date - col1 from (select generate_series(1,20,2) col1)a;
CREATE TABLE bfv_tab2_dimtabl1 (
id integer,
col2 integer
)
;
insert into bfv_tab2_dimtabl1 select col1, col1 from (select generate_series(1,20,3) col1)a;
CREATE INDEX idx_bfv_tab2_facttable1 on bfv_tab2_facttable1 (id); 
--start_ignore
set optimizer_analyze_root_partition to on;
ERROR:  unrecognized configuration parameter "optimizer_analyze_root_partition"
--end_ignore
ANALYZE bfv_tab2_facttable1;
ANALYZE bfv_tab2_dimdate;
ANALYZE bfv_tab2_dimtabl1;
SELECT count(*) 
FROM bfv_tab2_facttable1 ft, bfv_tab2_dimdate dt, bfv_tab2_dimtabl1 dt1
WHERE ft.wk_id = dt.wk_id
AND ft.id = dt1.id;
 count 
-------
     4
(1 row)

                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Hash Join
               Hash Cond: (bfv_tab2_dimdate.wk_id = bfv_tab2_facttable1_1.wk_id)
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: bfv_tab2_dimdate.wk_id
                     Hash Key: bfv_tab2_dimdate.wk_id
                     ->  Partial Seq Scan on public.bfv_tab2_dimdate
                           Output: bfv_tab2_dimdate.wk_id
               ->  Hash
                     Output: bfv_tab2_facttable1_1.wk_id
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: bfv_tab2_facttable1_1.wk_id
                           Hash Key: bfv_tab2_facttable1_1.wk_id
                           ->  Nested Loop
                                 Output: bfv_tab2_facttable1_1.wk_id
                                 Join Filter: true
                                 ->  PX Broadcast 6:6  (slice4; segments: 6)
                                       Output: bfv_tab2_dimtabl1.id
                                       ->  Partial Seq Scan on public.bfv_tab2_dimtabl1
                                             Output: bfv_tab2_dimtabl1.id
                                 ->  Append
                                       ->  Partial Index Scan using bfv_tab2_facttable1_1_id_idx on public.bfv_tab2_facttable1_1
                                             Output: bfv_tab2_facttable1_1.wk_id, bfv_tab2_facttable1_1.id
                                             Index Cond: (bfv_tab2_facttable1_1.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_2_id_idx on public.bfv_tab2_facttable1_2
                                             Output: bfv_tab2_facttable1_2.wk_id, bfv_tab2_facttable1_2.id
                                             Index Cond: (bfv_tab2_facttable1_2.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_3_id_idx on public.bfv_tab2_facttable1_3
                                             Output: bfv_tab2_facttable1_3.wk_id, bfv_tab2_facttable1_3.id
                                             Index Cond: (bfv_tab2_facttable1_3.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_4_id_idx on public.bfv_tab2_facttable1_4
                                             Output: bfv_tab2_facttable1_4.wk_id, bfv_tab2_facttable1_4.id
                                             Index Cond: (bfv_tab2_facttable1_4.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_5_id_idx on public.bfv_tab2_facttable1_5
                                             Output: bfv_tab2_facttable1_5.wk_id, bfv_tab2_facttable1_5.id
                                             Index Cond: (bfv_tab2_facttable1_5.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_6_id_idx on public.bfv_tab2_facttable1_6
                                             Output: bfv_tab2_facttable1_6.wk_id, bfv_tab2_facttable1_6.id
                                             Index Cond: (bfv_tab2_facttable1_6.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_7_id_idx on public.bfv_tab2_facttable1_7
                                             Output: bfv_tab2_facttable1_7.wk_id, bfv_tab2_facttable1_7.id
                                             Index Cond: (bfv_tab2_facttable1_7.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_8_id_idx on public.bfv_tab2_facttable1_8
                                             Output: bfv_tab2_facttable1_8.wk_id, bfv_tab2_facttable1_8.id
                                             Index Cond: (bfv_tab2_facttable1_8.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_9_id_idx on public.bfv_tab2_facttable1_9
                                             Output: bfv_tab2_facttable1_9.wk_id, bfv_tab2_facttable1_9.id
                                             Index Cond: (bfv_tab2_facttable1_9.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_10_id_idx on public.bfv_tab2_facttable1_10
                                             Output: bfv_tab2_facttable1_10.wk_id, bfv_tab2_facttable1_10.id
                                             Index Cond: (bfv_tab2_facttable1_10.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_11_id_idx on public.bfv_tab2_facttable1_11
                                             Output: bfv_tab2_facttable1_11.wk_id, bfv_tab2_facttable1_11.id
                                             Index Cond: (bfv_tab2_facttable1_11.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_12_id_idx on public.bfv_tab2_facttable1_12
                                             Output: bfv_tab2_facttable1_12.wk_id, bfv_tab2_facttable1_12.id
                                             Index Cond: (bfv_tab2_facttable1_12.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_13_id_idx on public.bfv_tab2_facttable1_13
                                             Output: bfv_tab2_facttable1_13.wk_id, bfv_tab2_facttable1_13.id
                                             Index Cond: (bfv_tab2_facttable1_13.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_14_id_idx on public.bfv_tab2_facttable1_14
                                             Output: bfv_tab2_facttable1_14.wk_id, bfv_tab2_facttable1_14.id
                                             Index Cond: (bfv_tab2_facttable1_14.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_15_id_idx on public.bfv_tab2_facttable1_15
                                             Output: bfv_tab2_facttable1_15.wk_id, bfv_tab2_facttable1_15.id
                                             Index Cond: (bfv_tab2_facttable1_15.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_16_id_idx on public.bfv_tab2_facttable1_16
                                             Output: bfv_tab2_facttable1_16.wk_id, bfv_tab2_facttable1_16.id
                                             Index Cond: (bfv_tab2_facttable1_16.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_17_id_idx on public.bfv_tab2_facttable1_17
                                             Output: bfv_tab2_facttable1_17.wk_id, bfv_tab2_facttable1_17.id
                                             Index Cond: (bfv_tab2_facttable1_17.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_18_id_idx on public.bfv_tab2_facttable1_18
                                             Output: bfv_tab2_facttable1_18.wk_id, bfv_tab2_facttable1_18.id
                                             Index Cond: (bfv_tab2_facttable1_18.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_19_id_idx on public.bfv_tab2_facttable1_19
                                             Output: bfv_tab2_facttable1_19.wk_id, bfv_tab2_facttable1_19.id
                                             Index Cond: (bfv_tab2_facttable1_19.id = bfv_tab2_dimtabl1.id)
                                       ->  Partial Index Scan using bfv_tab2_facttable1_20_id_idx on public.bfv_tab2_facttable1_20
                                             Output: bfv_tab2_facttable1_20.wk_id, bfv_tab2_facttable1_20.id
                                             Index Cond: (bfv_tab2_facttable1_20.id = bfv_tab2_dimtabl1.id)
 Optimizer: PolarDB PX Optimizer
(84 rows)

explain (costs off) select count(*) 
FROM bfv_tab2_facttable1 ft, bfv_tab2_dimdate dt, bfv_tab2_dimtabl1 dt1
WHERE ft.wk_id = dt.wk_id
AND ft.id = dt1.id;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (ft.wk_id = dt.wk_id)
         ->  Hash Join
               Hash Cond: (ft.id = dt1.id)
               ->  Append
                     ->  Seq Scan on bfv_tab2_facttable1_1 ft
                     ->  Seq Scan on bfv_tab2_facttable1_2 ft_1
                     ->  Seq Scan on bfv_tab2_facttable1_3 ft_2
                     ->  Seq Scan on bfv_tab2_facttable1_4 ft_3
                     ->  Seq Scan on bfv_tab2_facttable1_5 ft_4
                     ->  Seq Scan on bfv_tab2_facttable1_6 ft_5
                     ->  Seq Scan on bfv_tab2_facttable1_7 ft_6
                     ->  Seq Scan on bfv_tab2_facttable1_8 ft_7
                     ->  Seq Scan on bfv_tab2_facttable1_9 ft_8
                     ->  Seq Scan on bfv_tab2_facttable1_10 ft_9
                     ->  Seq Scan on bfv_tab2_facttable1_11 ft_10
                     ->  Seq Scan on bfv_tab2_facttable1_12 ft_11
                     ->  Seq Scan on bfv_tab2_facttable1_13 ft_12
                     ->  Seq Scan on bfv_tab2_facttable1_14 ft_13
                     ->  Seq Scan on bfv_tab2_facttable1_15 ft_14
                     ->  Seq Scan on bfv_tab2_facttable1_16 ft_15
                     ->  Seq Scan on bfv_tab2_facttable1_17 ft_16
                     ->  Seq Scan on bfv_tab2_facttable1_18 ft_17
                     ->  Seq Scan on bfv_tab2_facttable1_19 ft_18
                     ->  Seq Scan on bfv_tab2_facttable1_20 ft_19
               ->  Hash
                     ->  Seq Scan on bfv_tab2_dimtabl1 dt1
         ->  Hash
               ->  Seq Scan on bfv_tab2_dimdate dt
(30 rows)

explain (costs off) select count(*)
FROM bfv_tab2_facttable1 ft, bfv_tab2_dimdate dt, bfv_tab2_dimtabl1 dt1
WHERE ft.wk_id = dt.wk_id
AND ft.id = dt1.id;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (ft.wk_id = dt.wk_id)
         ->  Hash Join
               Hash Cond: (ft.id = dt1.id)
               ->  Append
                     ->  Seq Scan on bfv_tab2_facttable1_1 ft
                     ->  Seq Scan on bfv_tab2_facttable1_2 ft_1
                     ->  Seq Scan on bfv_tab2_facttable1_3 ft_2
                     ->  Seq Scan on bfv_tab2_facttable1_4 ft_3
                     ->  Seq Scan on bfv_tab2_facttable1_5 ft_4
                     ->  Seq Scan on bfv_tab2_facttable1_6 ft_5
                     ->  Seq Scan on bfv_tab2_facttable1_7 ft_6
                     ->  Seq Scan on bfv_tab2_facttable1_8 ft_7
                     ->  Seq Scan on bfv_tab2_facttable1_9 ft_8
                     ->  Seq Scan on bfv_tab2_facttable1_10 ft_9
                     ->  Seq Scan on bfv_tab2_facttable1_11 ft_10
                     ->  Seq Scan on bfv_tab2_facttable1_12 ft_11
                     ->  Seq Scan on bfv_tab2_facttable1_13 ft_12
                     ->  Seq Scan on bfv_tab2_facttable1_14 ft_13
                     ->  Seq Scan on bfv_tab2_facttable1_15 ft_14
                     ->  Seq Scan on bfv_tab2_facttable1_16 ft_15
                     ->  Seq Scan on bfv_tab2_facttable1_17 ft_16
                     ->  Seq Scan on bfv_tab2_facttable1_18 ft_17
                     ->  Seq Scan on bfv_tab2_facttable1_19 ft_18
                     ->  Seq Scan on bfv_tab2_facttable1_20 ft_19
               ->  Hash
                     ->  Seq Scan on bfv_tab2_dimtabl1 dt1
         ->  Hash
               ->  Seq Scan on bfv_tab2_dimdate dt
(30 rows)

-- start_ignore
create language plpython3u;
ERROR:  language "plpython3u" already exists
-- end_ignore
create or replace function count_index_scans(explain_query text) returns int as
$$
rv = plpy.execute(explain_query)
search_text = 'Index Scan'
result = 0
for i in range(len(rv)):
    cur_line = rv[i]['QUERY PLAN']
    if search_text.lower() in cur_line.lower():
        result = result+1
return result
$$
language plpython3u;
DROP TABLE bfv_tab1;
DROP TABLE bfv_tab2_facttable1;
DROP TABLE bfv_tab2_dimdate;
DROP TABLE bfv_tab2_dimtabl1;
-- pick index scan when query has a relabel on the index key: non partitioned tables
set enable_seqscan = off;
-- start_ignore
drop table if exists Tab23383;
NOTICE:  table "tab23383" does not exist, skipping
-- end_ignore
create table Tab23383(a int, b varchar(20));
insert into Tab23383 select g,g from generate_series(1,1000) g;
create index Tab23383_b on Tab23383(b);
-- start_ignore
select disable_xform('CXformGet2TableScan');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformGet2TableScan');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
select count_index_scans('explain (costs off) select * from Tab23383 where b=''1'';');
 count_index_scans 
-------------------
                 1
(1 row)

select * from Tab23383 where b='1';
 a | b 
---+---
 1 | 1
(1 row)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Index Scan using tab23383_b on public.tab23383
         Output: a, b
         Index Cond: ((tab23383.b)::text = '1'::text)
 Optimizer: PolarDB PX Optimizer
(6 rows)

select count_index_scans('explain (costs off) select * from Tab23383 where ''1''=b;');
 count_index_scans 
-------------------
                 1
(1 row)

select * from Tab23383 where '1'=b;
 a | b 
---+---
 1 | 1
(1 row)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Index Scan using tab23383_b on public.tab23383
         Output: a, b
         Index Cond: ((tab23383.b)::text = '1'::text)
 Optimizer: PolarDB PX Optimizer
(6 rows)

select count_index_scans('explain (costs off) select * from Tab23383 where ''2''> b order by a limit 10;');
 count_index_scans 
-------------------
                 1
(1 row)

select * from Tab23383 where '2'> b order by a limit 10;
 a  | b  
----+----
  1 | 1
 10 | 10
 11 | 11
 12 | 12
 13 | 13
 14 | 14
 15 | 15
 16 | 16
 17 | 17
 18 | 18
(10 rows)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Limit
   Output: a, b
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         Merge Key: a
         ->  Limit
               Output: a, b
               ->  Sort
                     Output: a, b
                     Sort Key: tab23383.a
                     ->  Partial Index Scan using tab23383_b on public.tab23383
                           Output: a, b
                           Index Cond: ((tab23383.b)::text < '2'::text)
 Optimizer: PolarDB PX Optimizer
(14 rows)

select count_index_scans('explain (costs off) select * from Tab23383 where b between ''1'' and ''2'' order by a limit 10;');
 count_index_scans 
-------------------
                 1
(1 row)

select * from Tab23383 where b between '1' and '2' order by a limit 10;
 a  | b  
----+----
  1 | 1
  2 | 2
 10 | 10
 11 | 11
 12 | 12
 13 | 13
 14 | 14
 15 | 15
 16 | 16
 17 | 17
(10 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Limit
   Output: a, b
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         Merge Key: a
         ->  Limit
               Output: a, b
               ->  Sort
                     Output: a, b
                     Sort Key: tab23383.a
                     ->  Partial Index Scan using tab23383_b on public.tab23383
                           Output: a, b
                           Index Cond: (((tab23383.b)::text >= '1'::text) AND ((tab23383.b)::text <= '2'::text))
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- predicates on both index and non-index key
select count_index_scans('explain (costs off) select * from Tab23383 where b=''1'' and a=''1'';');
 count_index_scans 
-------------------
                 1
(1 row)

select * from Tab23383 where b='1' and a='1';
 a | b 
---+---
 1 | 1
(1 row)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Index Scan using tab23383_b on public.tab23383
         Output: a, b
         Index Cond: ((tab23383.b)::text = '1'::text)
         Filter: (tab23383.a = 1)
 Optimizer: PolarDB PX Optimizer
(7 rows)

--negative tests: no index scan plan possible, fall back to planner
select count_index_scans('explain (costs off) select * from Tab23383 where b::int=''1'';');
 count_index_scans 
-------------------
                 0
(1 row)

drop table Tab23383;
-- pick index scan when query has a relabel on the index key: partitioned tables
-- start_ignore
drop table if exists Tbl23383_partitioned;
NOTICE:  table "tbl23383_partitioned" does not exist, skipping
-- end_ignore
create table Tbl23383_partitioned(a int, b varchar(20), c varchar(20), d varchar(20))
partition by range(a);
CREATE TABLE Tbl23383_partitioned_1 PARTITION of Tbl23383_partitioned for values from (1) to (500);
CREATE TABLE Tbl23383_partitioned_2 PARTITION of Tbl23383_partitioned for values from (500) to (1001);
insert into Tbl23383_partitioned select g,g,g,g from generate_series(1,1000) g;
create index idx23383_b on Tbl23383_partitioned(b);
-- heterogenous indexes
create index idx23383_c on Tbl23383_partitioned_1(c);
create index idx23383_cd on Tbl23383_partitioned_2(c,d);
set polar_px_optimizer_enable_dynamictablescan = off;
select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where b=''1''');
 count_index_scans 
-------------------
                 2
(1 row)

select * from Tbl23383_partitioned where b='1';
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 1
(1 row)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
   ->  Append
         ->  Partial Index Scan using tbl23383_partitioned_1_b_idx on public.tbl23383_partitioned_1
               Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
               Index Cond: ((tbl23383_partitioned_1.b)::text = '1'::text)
         ->  Partial Index Scan using tbl23383_partitioned_2_b_idx on public.tbl23383_partitioned_2
               Output: tbl23383_partitioned_2.a, tbl23383_partitioned_2.b, tbl23383_partitioned_2.c, tbl23383_partitioned_2.d
               Index Cond: ((tbl23383_partitioned_2.b)::text = '1'::text)
 Optimizer: PolarDB PX Optimizer
(10 rows)

select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where ''1''=b');
 count_index_scans 
-------------------
                 2
(1 row)

select * from Tbl23383_partitioned where '1'=b;
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 1
(1 row)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
   ->  Append
         ->  Partial Index Scan using tbl23383_partitioned_1_b_idx on public.tbl23383_partitioned_1
               Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
               Index Cond: ((tbl23383_partitioned_1.b)::text = '1'::text)
         ->  Partial Index Scan using tbl23383_partitioned_2_b_idx on public.tbl23383_partitioned_2
               Output: tbl23383_partitioned_2.a, tbl23383_partitioned_2.b, tbl23383_partitioned_2.c, tbl23383_partitioned_2.d
               Index Cond: ((tbl23383_partitioned_2.b)::text = '1'::text)
 Optimizer: PolarDB PX Optimizer
(10 rows)

select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where ''2''> b order by a limit 10;');
 count_index_scans 
-------------------
                 2
(1 row)

select * from Tbl23383_partitioned where '2'> b order by a limit 10;
 a  | b  | c  | d  
----+----+----+----
  1 | 1  | 1  | 1
 10 | 10 | 10 | 10
 11 | 11 | 11 | 11
 12 | 12 | 12 | 12
 13 | 13 | 13 | 13
 14 | 14 | 14 | 14
 15 | 15 | 15 | 15
 16 | 16 | 16 | 16
 17 | 17 | 17 | 17
 18 | 18 | 18 | 18
(10 rows)

                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
         Merge Key: tbl23383_partitioned_1.a
         ->  Limit
               Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
               ->  Sort
                     Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
                     Sort Key: tbl23383_partitioned_1.a
                     ->  Append
                           ->  Partial Index Scan using tbl23383_partitioned_1_b_idx on public.tbl23383_partitioned_1
                                 Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
                                 Index Cond: ((tbl23383_partitioned_1.b)::text < '2'::text)
                           ->  Partial Index Scan using tbl23383_partitioned_2_b_idx on public.tbl23383_partitioned_2
                                 Output: tbl23383_partitioned_2.a, tbl23383_partitioned_2.b, tbl23383_partitioned_2.c, tbl23383_partitioned_2.d
                                 Index Cond: ((tbl23383_partitioned_2.b)::text < '2'::text)
 Optimizer: PolarDB PX Optimizer
(18 rows)

select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where b between ''1'' and ''2'' order by a limit 10;');
 count_index_scans 
-------------------
                 2
(1 row)

select * from Tbl23383_partitioned where b between '1' and '2' order by a limit 10;
 a  | b  | c  | d  
----+----+----+----
  1 | 1  | 1  | 1
  2 | 2  | 2  | 2
 10 | 10 | 10 | 10
 11 | 11 | 11 | 11
 12 | 12 | 12 | 12
 13 | 13 | 13 | 13
 14 | 14 | 14 | 14
 15 | 15 | 15 | 15
 16 | 16 | 16 | 16
 17 | 17 | 17 | 17
(10 rows)

                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
         Merge Key: tbl23383_partitioned_1.a
         ->  Limit
               Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
               ->  Sort
                     Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
                     Sort Key: tbl23383_partitioned_1.a
                     ->  Append
                           ->  Partial Index Scan using tbl23383_partitioned_1_b_idx on public.tbl23383_partitioned_1
                                 Output: tbl23383_partitioned_1.a, tbl23383_partitioned_1.b, tbl23383_partitioned_1.c, tbl23383_partitioned_1.d
                                 Index Cond: (((tbl23383_partitioned_1.b)::text >= '1'::text) AND ((tbl23383_partitioned_1.b)::text <= '2'::text))
                           ->  Partial Index Scan using tbl23383_partitioned_2_b_idx on public.tbl23383_partitioned_2
                                 Output: tbl23383_partitioned_2.a, tbl23383_partitioned_2.b, tbl23383_partitioned_2.c, tbl23383_partitioned_2.d
                                 Index Cond: (((tbl23383_partitioned_2.b)::text >= '1'::text) AND ((tbl23383_partitioned_2.b)::text <= '2'::text))
 Optimizer: PolarDB PX Optimizer
(18 rows)

-- predicates on both index and non-index key
select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where b=''1'' and a=''1'';');
 count_index_scans 
-------------------
                 1
(1 row)

select * from Tbl23383_partitioned where b='1' and a='1';
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 1
(1 row)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b, c, d
   ->  Append
         ->  Partial Index Scan using tbl23383_partitioned_1_b_idx on public.tbl23383_partitioned_1
               Output: a, b, c, d
               Index Cond: ((tbl23383_partitioned_1.b)::text = '1'::text)
               Filter: (((tbl23383_partitioned_1.b)::text = '1'::text) AND (tbl23383_partitioned_1.a = 1))
 Optimizer: PolarDB PX Optimizer
(8 rows)

--negative tests: no index scan plan possible, fall back to planner
select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where b::int=''1'';');
 count_index_scans 
-------------------
                 0
(1 row)

-- heterogenous indexes
select count_index_scans('explain (costs off) select * from Tbl23383_partitioned where c=''1'';');
 count_index_scans 
-------------------
                 2
(1 row)

select * from Tbl23383_partitioned where c='1';
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 1
(1 row)

-- start_ignore
drop table Tbl23383_partitioned;
-- end_ignore
reset enable_seqscan;
-- negative test: due to non compatible cast and CXformGet2TableScan disabled no index plan possible, fallback to planner
-- start_ignore
drop table if exists tbl_ab;
NOTICE:  table "tbl_ab" does not exist, skipping
-- end_ignore
create table tbl_ab(a int, b int);
create index idx_ab_b on tbl_ab(b);
-- start_ignore
select disable_xform('CXformGet2TableScan');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformGet2TableScan');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
explain (costs off) select * from tbl_ab where b::oid=1;
           QUERY PLAN            
---------------------------------
 Seq Scan on tbl_ab
   Filter: ((b)::oid = '1'::oid)
(2 rows)

drop table tbl_ab;
drop function count_index_scans(text);
-- start_ignore
select enable_xform('CXformGet2TableScan');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformGet2TableScan');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
--
-- Check that ORCA can use an index for joins on quals like:
--
-- indexkey CMP expr
-- expr CMP indexkey
--
-- where expr is a scalar expression free of index keys and may have outer
-- references.
--
create table nestloop_x (i int, j int);
create table nestloop_y (i int, j int);
insert into nestloop_x select g, g from generate_series(1, 20) g;
insert into nestloop_y select g, g from generate_series(1, 7) g;
create index nestloop_y_idx on nestloop_y (j);
-- Coerce the Postgres planner to produce a similar plan. Nested loop joins
-- are not enabled by default. And to dissuade it from choosing a sequential
-- scan, bump up the cost. enable_seqscan=off  won't help, because there is
-- no other way to scan table 'x', and once the planner chooses a seqscan for
-- one table, it will happily use a seqscan for other tables as well, despite
-- enable_seqscan=off. (On PostgreSQL, enable_seqscan works differently, and
-- just bumps up the cost of a seqscan, so it would work there.)
set seq_page_cost=10000000;
set enable_indexscan=on;
set enable_nestloop=on;
explain (costs off) select * from nestloop_x as x, nestloop_y as y where x.i + x.j < y.j;
                      QUERY PLAN                       
-------------------------------------------------------
 Nested Loop
   ->  Seq Scan on nestloop_x x
   ->  Index Scan using nestloop_y_idx on nestloop_y y
         Index Cond: ((x.i + x.j) < j)
(4 rows)

select * from nestloop_x as x, nestloop_y as y where x.i + x.j < y.j;
 i | j | i | j 
---+---+---+---
 1 | 1 | 3 | 3
 1 | 1 | 4 | 4
 1 | 1 | 5 | 5
 1 | 1 | 6 | 6
 1 | 1 | 7 | 7
 2 | 2 | 5 | 5
 2 | 2 | 6 | 6
 2 | 2 | 7 | 7
 3 | 3 | 7 | 7
(9 rows)

                                QUERY PLAN                                
--------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: nestloop_x.i, nestloop_x.j, nestloop_y.i, nestloop_y.j
   ->  Nested Loop
         Output: nestloop_x.i, nestloop_x.j, nestloop_y.i, nestloop_y.j
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: nestloop_x.i, nestloop_x.j
               ->  Partial Seq Scan on public.nestloop_x
                     Output: nestloop_x.i, nestloop_x.j
         ->  Partial Index Scan using nestloop_y_idx on public.nestloop_y
               Output: nestloop_y.i, nestloop_y.j
               Index Cond: (nestloop_y.j > (nestloop_x.i + nestloop_x.j))
 Optimizer: PolarDB PX Optimizer
(13 rows)

explain (costs off) select * from nestloop_x as x, nestloop_y as y where y.j > x.i + x.j + 2;
                      QUERY PLAN                       
-------------------------------------------------------
 Nested Loop
   ->  Seq Scan on nestloop_x x
   ->  Index Scan using nestloop_y_idx on nestloop_y y
         Index Cond: (j > ((x.i + x.j) + 2))
(4 rows)

select * from nestloop_x as x, nestloop_y as y where y.j > x.i + x.j + 2;
 i | j | i | j 
---+---+---+---
 1 | 1 | 5 | 5
 1 | 1 | 6 | 6
 1 | 1 | 7 | 7
 2 | 2 | 7 | 7
(4 rows)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: nestloop_x.i, nestloop_x.j, nestloop_y.i, nestloop_y.j
   ->  Nested Loop
         Output: nestloop_x.i, nestloop_x.j, nestloop_y.i, nestloop_y.j
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: nestloop_x.i, nestloop_x.j
               ->  Partial Seq Scan on public.nestloop_x
                     Output: nestloop_x.i, nestloop_x.j
         ->  Partial Index Scan using nestloop_y_idx on public.nestloop_y
               Output: nestloop_y.i, nestloop_y.j
               Index Cond: (nestloop_y.j > ((nestloop_x.i + nestloop_x.j) + 2))
 Optimizer: PolarDB PX Optimizer
(13 rows)

drop table nestloop_x, nestloop_y;
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
DROP TABLE IF EXISTS bpchar_ops;
NOTICE:  table "bpchar_ops" does not exist, skipping
CREATE TABLE bpchar_ops(id INT8, v char(10));
CREATE INDEX bpchar_ops_btree_idx ON bpchar_ops USING btree(v bpchar_pattern_ops);
INSERT INTO bpchar_ops VALUES (0, 'row');
SELECT * FROM bpchar_ops WHERE v = 'row '::char(20);
 id |     v      
----+------------
  0 | row       
(1 row)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: id, v
   ->  Partial Index Scan using bpchar_ops_btree_idx on public.bpchar_ops
         Output: id, v
         Index Cond: (bpchar_ops.v = 'row                 '::character(20))
 Optimizer: PolarDB PX Optimizer
(6 rows)

DROP TABLE bpchar_ops;
--
-- Test index rechecks with AO and AOCS tables (and heaps as well, for good measure)
--
create table shape_heap (c circle) ;
create table shape_ao (c circle) ;
create table shape_aocs (c circle) ;
insert into shape_heap values ('<(0,0), 5>');
insert into shape_ao   values ('<(0,0), 5>');
insert into shape_aocs values ('<(0,0), 5>');
create index shape_heap_bb_idx on shape_heap using gist(c);
create index shape_ao_bb_idx   on shape_ao   using gist(c);
create index shape_aocs_bb_idx on shape_aocs using gist(c);
select c && '<(5,5), 1>'::circle,
       c && '<(5,5), 2>'::circle,
       c && '<(5,5), 3>'::circle
from shape_heap;
 ?column? | ?column? | ?column? 
----------+----------+----------
 f        | f        | t
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((c && '<(5,5),1>'::circle)), ((c && '<(5,5),2>'::circle)), ((c && '<(5,5),3>'::circle))
   ->  Partial Seq Scan on public.shape_heap
         Output: (c && '<(5,5),1>'::circle), (c && '<(5,5),2>'::circle), (c && '<(5,5),3>'::circle)
 Optimizer: PolarDB PX Optimizer
(5 rows)

-- Test the same values ;
--
-- The first two values don't overlap with the value in the tables, <(0,0), 5>,
-- but their bounding boxes do. In a GiST index scan that uses the bounding
-- boxes, these will fetch the row from the index, but filtered out by the
-- recheck using the actual overlap operator. The third entry is sanity check
-- that the index returns any rows.
set enable_seqscan=off;
set enable_indexscan=off;
set enable_bitmapscan=on;
-- Use EXPLAIN to verify that these use a bitmap index scan
explain (costs off) select * from shape_heap where c && '<(5,5), 1>'::circle;
                   QUERY PLAN                   
------------------------------------------------
 Bitmap Heap Scan on shape_heap
   Recheck Cond: (c && '<(5,5),1>'::circle)
   ->  Bitmap Index Scan on shape_heap_bb_idx
         Index Cond: (c && '<(5,5),1>'::circle)
(4 rows)

explain (costs off) select * from shape_ao   where c && '<(5,5), 1>'::circle;
                   QUERY PLAN                   
------------------------------------------------
 Bitmap Heap Scan on shape_ao
   Recheck Cond: (c && '<(5,5),1>'::circle)
   ->  Bitmap Index Scan on shape_ao_bb_idx
         Index Cond: (c && '<(5,5),1>'::circle)
(4 rows)

explain (costs off) select * from shape_aocs where c && '<(5,5), 1>'::circle;
                   QUERY PLAN                   
------------------------------------------------
 Bitmap Heap Scan on shape_aocs
   Recheck Cond: (c && '<(5,5),1>'::circle)
   ->  Bitmap Index Scan on shape_aocs_bb_idx
         Index Cond: (c && '<(5,5),1>'::circle)
(4 rows)

-- Test that they return correct results.
select * from shape_heap where c && '<(5,5), 1>'::circle;
 c 
---
(0 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_heap_bb_idx on public.shape_heap
         Output: c
         Index Cond: (shape_heap.c && '<(5,5),1>'::circle)
         Filter: (shape_heap.c && '<(5,5),1>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_ao   where c && '<(5,5), 1>'::circle;
 c 
---
(0 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_ao_bb_idx on public.shape_ao
         Output: c
         Index Cond: (shape_ao.c && '<(5,5),1>'::circle)
         Filter: (shape_ao.c && '<(5,5),1>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_aocs where c && '<(5,5), 1>'::circle;
 c 
---
(0 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_aocs_bb_idx on public.shape_aocs
         Output: c
         Index Cond: (shape_aocs.c && '<(5,5),1>'::circle)
         Filter: (shape_aocs.c && '<(5,5),1>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_heap where c && '<(5,5), 2>'::circle;
 c 
---
(0 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_heap_bb_idx on public.shape_heap
         Output: c
         Index Cond: (shape_heap.c && '<(5,5),2>'::circle)
         Filter: (shape_heap.c && '<(5,5),2>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_ao   where c && '<(5,5), 2>'::circle;
 c 
---
(0 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_ao_bb_idx on public.shape_ao
         Output: c
         Index Cond: (shape_ao.c && '<(5,5),2>'::circle)
         Filter: (shape_ao.c && '<(5,5),2>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_aocs where c && '<(5,5), 2>'::circle;
 c 
---
(0 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_aocs_bb_idx on public.shape_aocs
         Output: c
         Index Cond: (shape_aocs.c && '<(5,5),2>'::circle)
         Filter: (shape_aocs.c && '<(5,5),2>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_heap where c && '<(5,5), 3>'::circle;
     c     
-----------
 <(0,0),5>
(1 row)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_heap_bb_idx on public.shape_heap
         Output: c
         Index Cond: (shape_heap.c && '<(5,5),3>'::circle)
         Filter: (shape_heap.c && '<(5,5),3>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_ao   where c && '<(5,5), 3>'::circle;
     c     
-----------
 <(0,0),5>
(1 row)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_ao_bb_idx on public.shape_ao
         Output: c
         Index Cond: (shape_ao.c && '<(5,5),3>'::circle)
         Filter: (shape_ao.c && '<(5,5),3>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from shape_aocs where c && '<(5,5), 3>'::circle;
     c     
-----------
 <(0,0),5>
(1 row)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c
   ->  Partial Index Scan using shape_aocs_bb_idx on public.shape_aocs
         Output: c
         Index Cond: (shape_aocs.c && '<(5,5),3>'::circle)
         Filter: (shape_aocs.c && '<(5,5),3>'::circle)
 Optimizer: PolarDB PX Optimizer
(7 rows)

--
-- Given a table with different column types
--
CREATE TABLE table_with_reversed_index(a int, b bool, c text);
--
-- And it has an index that is ordered differently than columns on the table.
--
CREATE INDEX ON table_with_reversed_index(c, a);
INSERT INTO table_with_reversed_index VALUES (10, true, 'ab');
--
-- Then an index only scan should succeed. (i.e. varattno is set up correctly)
--
SET enable_seqscan=off;
SET enable_bitmapscan=off;
SET polar_px_optimizer_enable_seqscan=off;
SET polar_px_optimizer_enable_indexscan=off;
SET polar_px_optimizer_enable_indexonlyscan=on;
explain (costs off) select c, a FROM table_with_reversed_index WHERE a > 5;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Index Only Scan using table_with_reversed_index_c_a_idx on table_with_reversed_index
   Index Cond: (a > 5)
(2 rows)

SELECT c, a FROM table_with_reversed_index WHERE a > 5;
 c  | a  
----+----
 ab | 10
(1 row)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c, a
   ->  Partial Index Only Scan using table_with_reversed_index_c_a_idx on public.table_with_reversed_index
         Output: c, a
         Index Cond: (table_with_reversed_index.a > 5)
 Optimizer: PolarDB PX Optimizer
(6 rows)

RESET enable_seqscan;
RESET enable_bitmapscan;
RESET polar_px_optimizer_enable_seqscan;
RESET polar_px_optimizer_enable_indexscan;
RESET polar_px_optimizer_enable_indexonlyscan;
