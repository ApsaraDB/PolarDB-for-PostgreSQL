--
-- ORCA tests
--
-- Mask out Log & timestamp for orca message that has feature not supported.
-- start_matchsubs
-- m/^LOG.*\"Feature/
-- s/^LOG.*\"Feature/\"Feature/
-- end_matchsubs
-- fix the number of segments for Orca
set polar_px_optimizer_segments = 3;
set polar_px_optimizer_enable_master_only_queries = on;
-- master only tables
/*--EXPLAIN_QUERY_BEGIN*/
create schema orca;
-- start_ignore
GRANT ALL ON SCHEMA orca TO PUBLIC;
SET search_path to orca, public;
-- end_ignore
create table orca.r();
set allow_system_table_mods=true;
delete from gp_distribution_policy where localoid='orca.r'::regclass;
ERROR:  relation "gp_distribution_policy" does not exist
LINE 1: delete from gp_distribution_policy where localoid='orca.r'::...
                    ^
reset allow_system_table_mods;
alter table orca.r add column a int;
alter table orca.r add column b int;
insert into orca.r select i, i/3 from generate_series(1,20) i;
create table orca.s();
set allow_system_table_mods=true;
delete from gp_distribution_policy where localoid='orca.s'::regclass;
ERROR:  relation "gp_distribution_policy" does not exist
LINE 1: delete from gp_distribution_policy where localoid='orca.s'::...
                    ^
reset allow_system_table_mods;
alter table orca.s add column c int;
alter table orca.s add column d int;
insert into orca.s select i, i/2 from generate_series(1,30) i;
set polar_px_optimizer_enable_indexjoin=on;
set polar_px_optimizer_trace_fallback = on;
-- expected fall back to the planner
select sum(distinct a), count(distinct b) from orca.r;
 sum | count 
-----+-------
 210 |     7
(1 row)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Multiple Distinct Qualified Aggregates are disabled in the optimizer
select * from orca.r;
 a  | b 
----+---
  1 | 0
  2 | 0
  3 | 1
  4 | 1
  5 | 1
  6 | 2
  7 | 2
  8 | 2
  9 | 3
 10 | 3
 11 | 3
 12 | 4
 13 | 4
 14 | 4
 15 | 5
 16 | 5
 17 | 5
 18 | 6
 19 | 6
 20 | 6
(20 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Seq Scan on orca.r
         Output: a, b
 Optimizer: PolarDB PX Optimizer
(5 rows)

select * from orca.r, orca.s where r.a=s.c;
 a  | b | c  | d  
----+---+----+----
  1 | 0 |  1 |  0
  2 | 0 |  2 |  1
  3 | 1 |  3 |  1
  4 | 1 |  4 |  2
  5 | 1 |  5 |  2
  6 | 2 |  6 |  3
  7 | 2 |  7 |  3
  8 | 2 |  8 |  4
  9 | 3 |  9 |  4
 10 | 3 | 10 |  5
 11 | 3 | 11 |  5
 12 | 4 | 12 |  6
 13 | 4 | 13 |  6
 14 | 4 | 14 |  7
 15 | 5 | 15 |  7
 16 | 5 | 16 |  8
 17 | 5 | 17 |  8
 18 | 6 | 18 |  9
 19 | 6 | 19 |  9
 20 | 6 | 20 | 10
(20 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   ->  Hash Join
         Output: r.a, r.b, s.c, s.d
         Hash Cond: (s.c = r.a)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: s.c, s.d
               Hash Key: s.c
               ->  Partial Seq Scan on orca.s
                     Output: s.c, s.d
         ->  Hash
               Output: r.a, r.b
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: r.a, r.b
                     Hash Key: r.a
                     ->  Partial Seq Scan on orca.r
                           Output: r.a, r.b
 Optimizer: PolarDB PX Optimizer
(18 rows)

select * from orca.r, orca.s where r.a<s.c+1 or r.a>s.c;
 a  | b | c  | d  
----+---+----+----
  1 | 0 |  1 |  0
  2 | 0 |  1 |  0
  3 | 1 |  1 |  0
  4 | 1 |  1 |  0
  5 | 1 |  1 |  0
  6 | 2 |  1 |  0
  7 | 2 |  1 |  0
  8 | 2 |  1 |  0
  9 | 3 |  1 |  0
 10 | 3 |  1 |  0
 11 | 3 |  1 |  0
 12 | 4 |  1 |  0
 13 | 4 |  1 |  0
 14 | 4 |  1 |  0
 15 | 5 |  1 |  0
 16 | 5 |  1 |  0
 17 | 5 |  1 |  0
 18 | 6 |  1 |  0
 19 | 6 |  1 |  0
 20 | 6 |  1 |  0
  1 | 0 |  2 |  1
  2 | 0 |  2 |  1
  3 | 1 |  2 |  1
  4 | 1 |  2 |  1
  5 | 1 |  2 |  1
  6 | 2 |  2 |  1
  7 | 2 |  2 |  1
  8 | 2 |  2 |  1
  9 | 3 |  2 |  1
 10 | 3 |  2 |  1
 11 | 3 |  2 |  1
 12 | 4 |  2 |  1
 13 | 4 |  2 |  1
 14 | 4 |  2 |  1
 15 | 5 |  2 |  1
 16 | 5 |  2 |  1
 17 | 5 |  2 |  1
 18 | 6 |  2 |  1
 19 | 6 |  2 |  1
 20 | 6 |  2 |  1
  1 | 0 |  3 |  1
  2 | 0 |  3 |  1
  3 | 1 |  3 |  1
  4 | 1 |  3 |  1
  5 | 1 |  3 |  1
  6 | 2 |  3 |  1
  7 | 2 |  3 |  1
  8 | 2 |  3 |  1
  9 | 3 |  3 |  1
 10 | 3 |  3 |  1
 11 | 3 |  3 |  1
 12 | 4 |  3 |  1
 13 | 4 |  3 |  1
 14 | 4 |  3 |  1
 15 | 5 |  3 |  1
 16 | 5 |  3 |  1
 17 | 5 |  3 |  1
 18 | 6 |  3 |  1
 19 | 6 |  3 |  1
 20 | 6 |  3 |  1
  1 | 0 |  4 |  2
  2 | 0 |  4 |  2
  3 | 1 |  4 |  2
  4 | 1 |  4 |  2
  5 | 1 |  4 |  2
  6 | 2 |  4 |  2
  7 | 2 |  4 |  2
  8 | 2 |  4 |  2
  9 | 3 |  4 |  2
 10 | 3 |  4 |  2
 11 | 3 |  4 |  2
 12 | 4 |  4 |  2
 13 | 4 |  4 |  2
 14 | 4 |  4 |  2
 15 | 5 |  4 |  2
 16 | 5 |  4 |  2
 17 | 5 |  4 |  2
 18 | 6 |  4 |  2
 19 | 6 |  4 |  2
 20 | 6 |  4 |  2
  1 | 0 |  5 |  2
  2 | 0 |  5 |  2
  3 | 1 |  5 |  2
  4 | 1 |  5 |  2
  5 | 1 |  5 |  2
  6 | 2 |  5 |  2
  7 | 2 |  5 |  2
  8 | 2 |  5 |  2
  9 | 3 |  5 |  2
 10 | 3 |  5 |  2
 11 | 3 |  5 |  2
 12 | 4 |  5 |  2
 13 | 4 |  5 |  2
 14 | 4 |  5 |  2
 15 | 5 |  5 |  2
 16 | 5 |  5 |  2
 17 | 5 |  5 |  2
 18 | 6 |  5 |  2
 19 | 6 |  5 |  2
 20 | 6 |  5 |  2
  1 | 0 |  6 |  3
  2 | 0 |  6 |  3
  3 | 1 |  6 |  3
  4 | 1 |  6 |  3
  5 | 1 |  6 |  3
  6 | 2 |  6 |  3
  7 | 2 |  6 |  3
  8 | 2 |  6 |  3
  9 | 3 |  6 |  3
 10 | 3 |  6 |  3
 11 | 3 |  6 |  3
 12 | 4 |  6 |  3
 13 | 4 |  6 |  3
 14 | 4 |  6 |  3
 15 | 5 |  6 |  3
 16 | 5 |  6 |  3
 17 | 5 |  6 |  3
 18 | 6 |  6 |  3
 19 | 6 |  6 |  3
 20 | 6 |  6 |  3
  1 | 0 |  7 |  3
  2 | 0 |  7 |  3
  3 | 1 |  7 |  3
  4 | 1 |  7 |  3
  5 | 1 |  7 |  3
  6 | 2 |  7 |  3
  7 | 2 |  7 |  3
  8 | 2 |  7 |  3
  9 | 3 |  7 |  3
 10 | 3 |  7 |  3
 11 | 3 |  7 |  3
 12 | 4 |  7 |  3
 13 | 4 |  7 |  3
 14 | 4 |  7 |  3
 15 | 5 |  7 |  3
 16 | 5 |  7 |  3
 17 | 5 |  7 |  3
 18 | 6 |  7 |  3
 19 | 6 |  7 |  3
 20 | 6 |  7 |  3
  1 | 0 |  8 |  4
  2 | 0 |  8 |  4
  3 | 1 |  8 |  4
  4 | 1 |  8 |  4
  5 | 1 |  8 |  4
  6 | 2 |  8 |  4
  7 | 2 |  8 |  4
  8 | 2 |  8 |  4
  9 | 3 |  8 |  4
 10 | 3 |  8 |  4
 11 | 3 |  8 |  4
 12 | 4 |  8 |  4
 13 | 4 |  8 |  4
 14 | 4 |  8 |  4
 15 | 5 |  8 |  4
 16 | 5 |  8 |  4
 17 | 5 |  8 |  4
 18 | 6 |  8 |  4
 19 | 6 |  8 |  4
 20 | 6 |  8 |  4
  1 | 0 |  9 |  4
  2 | 0 |  9 |  4
  3 | 1 |  9 |  4
  4 | 1 |  9 |  4
  5 | 1 |  9 |  4
  6 | 2 |  9 |  4
  7 | 2 |  9 |  4
  8 | 2 |  9 |  4
  9 | 3 |  9 |  4
 10 | 3 |  9 |  4
 11 | 3 |  9 |  4
 12 | 4 |  9 |  4
 13 | 4 |  9 |  4
 14 | 4 |  9 |  4
 15 | 5 |  9 |  4
 16 | 5 |  9 |  4
 17 | 5 |  9 |  4
 18 | 6 |  9 |  4
 19 | 6 |  9 |  4
 20 | 6 |  9 |  4
  1 | 0 | 10 |  5
  2 | 0 | 10 |  5
  3 | 1 | 10 |  5
  4 | 1 | 10 |  5
  5 | 1 | 10 |  5
  6 | 2 | 10 |  5
  7 | 2 | 10 |  5
  8 | 2 | 10 |  5
  9 | 3 | 10 |  5
 10 | 3 | 10 |  5
 11 | 3 | 10 |  5
 12 | 4 | 10 |  5
 13 | 4 | 10 |  5
 14 | 4 | 10 |  5
 15 | 5 | 10 |  5
 16 | 5 | 10 |  5
 17 | 5 | 10 |  5
 18 | 6 | 10 |  5
 19 | 6 | 10 |  5
 20 | 6 | 10 |  5
  1 | 0 | 11 |  5
  2 | 0 | 11 |  5
  3 | 1 | 11 |  5
  4 | 1 | 11 |  5
  5 | 1 | 11 |  5
  6 | 2 | 11 |  5
  7 | 2 | 11 |  5
  8 | 2 | 11 |  5
  9 | 3 | 11 |  5
 10 | 3 | 11 |  5
 11 | 3 | 11 |  5
 12 | 4 | 11 |  5
 13 | 4 | 11 |  5
 14 | 4 | 11 |  5
 15 | 5 | 11 |  5
 16 | 5 | 11 |  5
 17 | 5 | 11 |  5
 18 | 6 | 11 |  5
 19 | 6 | 11 |  5
 20 | 6 | 11 |  5
  1 | 0 | 12 |  6
  2 | 0 | 12 |  6
  3 | 1 | 12 |  6
  4 | 1 | 12 |  6
  5 | 1 | 12 |  6
  6 | 2 | 12 |  6
  7 | 2 | 12 |  6
  8 | 2 | 12 |  6
  9 | 3 | 12 |  6
 10 | 3 | 12 |  6
 11 | 3 | 12 |  6
 12 | 4 | 12 |  6
 13 | 4 | 12 |  6
 14 | 4 | 12 |  6
 15 | 5 | 12 |  6
 16 | 5 | 12 |  6
 17 | 5 | 12 |  6
 18 | 6 | 12 |  6
 19 | 6 | 12 |  6
 20 | 6 | 12 |  6
  1 | 0 | 13 |  6
  2 | 0 | 13 |  6
  3 | 1 | 13 |  6
  4 | 1 | 13 |  6
  5 | 1 | 13 |  6
  6 | 2 | 13 |  6
  7 | 2 | 13 |  6
  8 | 2 | 13 |  6
  9 | 3 | 13 |  6
 10 | 3 | 13 |  6
 11 | 3 | 13 |  6
 12 | 4 | 13 |  6
 13 | 4 | 13 |  6
 14 | 4 | 13 |  6
 15 | 5 | 13 |  6
 16 | 5 | 13 |  6
 17 | 5 | 13 |  6
 18 | 6 | 13 |  6
 19 | 6 | 13 |  6
 20 | 6 | 13 |  6
  1 | 0 | 14 |  7
  2 | 0 | 14 |  7
  3 | 1 | 14 |  7
  4 | 1 | 14 |  7
  5 | 1 | 14 |  7
  6 | 2 | 14 |  7
  7 | 2 | 14 |  7
  8 | 2 | 14 |  7
  9 | 3 | 14 |  7
 10 | 3 | 14 |  7
 11 | 3 | 14 |  7
 12 | 4 | 14 |  7
 13 | 4 | 14 |  7
 14 | 4 | 14 |  7
 15 | 5 | 14 |  7
 16 | 5 | 14 |  7
 17 | 5 | 14 |  7
 18 | 6 | 14 |  7
 19 | 6 | 14 |  7
 20 | 6 | 14 |  7
  1 | 0 | 15 |  7
  2 | 0 | 15 |  7
  3 | 1 | 15 |  7
  4 | 1 | 15 |  7
  5 | 1 | 15 |  7
  6 | 2 | 15 |  7
  7 | 2 | 15 |  7
  8 | 2 | 15 |  7
  9 | 3 | 15 |  7
 10 | 3 | 15 |  7
 11 | 3 | 15 |  7
 12 | 4 | 15 |  7
 13 | 4 | 15 |  7
 14 | 4 | 15 |  7
 15 | 5 | 15 |  7
 16 | 5 | 15 |  7
 17 | 5 | 15 |  7
 18 | 6 | 15 |  7
 19 | 6 | 15 |  7
 20 | 6 | 15 |  7
  1 | 0 | 16 |  8
  2 | 0 | 16 |  8
  3 | 1 | 16 |  8
  4 | 1 | 16 |  8
  5 | 1 | 16 |  8
  6 | 2 | 16 |  8
  7 | 2 | 16 |  8
  8 | 2 | 16 |  8
  9 | 3 | 16 |  8
 10 | 3 | 16 |  8
 11 | 3 | 16 |  8
 12 | 4 | 16 |  8
 13 | 4 | 16 |  8
 14 | 4 | 16 |  8
 15 | 5 | 16 |  8
 16 | 5 | 16 |  8
 17 | 5 | 16 |  8
 18 | 6 | 16 |  8
 19 | 6 | 16 |  8
 20 | 6 | 16 |  8
  1 | 0 | 17 |  8
  2 | 0 | 17 |  8
  3 | 1 | 17 |  8
  4 | 1 | 17 |  8
  5 | 1 | 17 |  8
  6 | 2 | 17 |  8
  7 | 2 | 17 |  8
  8 | 2 | 17 |  8
  9 | 3 | 17 |  8
 10 | 3 | 17 |  8
 11 | 3 | 17 |  8
 12 | 4 | 17 |  8
 13 | 4 | 17 |  8
 14 | 4 | 17 |  8
 15 | 5 | 17 |  8
 16 | 5 | 17 |  8
 17 | 5 | 17 |  8
 18 | 6 | 17 |  8
 19 | 6 | 17 |  8
 20 | 6 | 17 |  8
  1 | 0 | 18 |  9
  2 | 0 | 18 |  9
  3 | 1 | 18 |  9
  4 | 1 | 18 |  9
  5 | 1 | 18 |  9
  6 | 2 | 18 |  9
  7 | 2 | 18 |  9
  8 | 2 | 18 |  9
  9 | 3 | 18 |  9
 10 | 3 | 18 |  9
 11 | 3 | 18 |  9
 12 | 4 | 18 |  9
 13 | 4 | 18 |  9
 14 | 4 | 18 |  9
 15 | 5 | 18 |  9
 16 | 5 | 18 |  9
 17 | 5 | 18 |  9
 18 | 6 | 18 |  9
 19 | 6 | 18 |  9
 20 | 6 | 18 |  9
  1 | 0 | 19 |  9
  2 | 0 | 19 |  9
  3 | 1 | 19 |  9
  4 | 1 | 19 |  9
  5 | 1 | 19 |  9
  6 | 2 | 19 |  9
  7 | 2 | 19 |  9
  8 | 2 | 19 |  9
  9 | 3 | 19 |  9
 10 | 3 | 19 |  9
 11 | 3 | 19 |  9
 12 | 4 | 19 |  9
 13 | 4 | 19 |  9
 14 | 4 | 19 |  9
 15 | 5 | 19 |  9
 16 | 5 | 19 |  9
 17 | 5 | 19 |  9
 18 | 6 | 19 |  9
 19 | 6 | 19 |  9
 20 | 6 | 19 |  9
  1 | 0 | 20 | 10
  2 | 0 | 20 | 10
  3 | 1 | 20 | 10
  4 | 1 | 20 | 10
  5 | 1 | 20 | 10
  6 | 2 | 20 | 10
  7 | 2 | 20 | 10
  8 | 2 | 20 | 10
  9 | 3 | 20 | 10
 10 | 3 | 20 | 10
 11 | 3 | 20 | 10
 12 | 4 | 20 | 10
 13 | 4 | 20 | 10
 14 | 4 | 20 | 10
 15 | 5 | 20 | 10
 16 | 5 | 20 | 10
 17 | 5 | 20 | 10
 18 | 6 | 20 | 10
 19 | 6 | 20 | 10
 20 | 6 | 20 | 10
  1 | 0 | 21 | 10
  2 | 0 | 21 | 10
  3 | 1 | 21 | 10
  4 | 1 | 21 | 10
  5 | 1 | 21 | 10
  6 | 2 | 21 | 10
  7 | 2 | 21 | 10
  8 | 2 | 21 | 10
  9 | 3 | 21 | 10
 10 | 3 | 21 | 10
 11 | 3 | 21 | 10
 12 | 4 | 21 | 10
 13 | 4 | 21 | 10
 14 | 4 | 21 | 10
 15 | 5 | 21 | 10
 16 | 5 | 21 | 10
 17 | 5 | 21 | 10
 18 | 6 | 21 | 10
 19 | 6 | 21 | 10
 20 | 6 | 21 | 10
  1 | 0 | 22 | 11
  2 | 0 | 22 | 11
  3 | 1 | 22 | 11
  4 | 1 | 22 | 11
  5 | 1 | 22 | 11
  6 | 2 | 22 | 11
  7 | 2 | 22 | 11
  8 | 2 | 22 | 11
  9 | 3 | 22 | 11
 10 | 3 | 22 | 11
 11 | 3 | 22 | 11
 12 | 4 | 22 | 11
 13 | 4 | 22 | 11
 14 | 4 | 22 | 11
 15 | 5 | 22 | 11
 16 | 5 | 22 | 11
 17 | 5 | 22 | 11
 18 | 6 | 22 | 11
 19 | 6 | 22 | 11
 20 | 6 | 22 | 11
  1 | 0 | 23 | 11
  2 | 0 | 23 | 11
  3 | 1 | 23 | 11
  4 | 1 | 23 | 11
  5 | 1 | 23 | 11
  6 | 2 | 23 | 11
  7 | 2 | 23 | 11
  8 | 2 | 23 | 11
  9 | 3 | 23 | 11
 10 | 3 | 23 | 11
 11 | 3 | 23 | 11
 12 | 4 | 23 | 11
 13 | 4 | 23 | 11
 14 | 4 | 23 | 11
 15 | 5 | 23 | 11
 16 | 5 | 23 | 11
 17 | 5 | 23 | 11
 18 | 6 | 23 | 11
 19 | 6 | 23 | 11
 20 | 6 | 23 | 11
  1 | 0 | 24 | 12
  2 | 0 | 24 | 12
  3 | 1 | 24 | 12
  4 | 1 | 24 | 12
  5 | 1 | 24 | 12
  6 | 2 | 24 | 12
  7 | 2 | 24 | 12
  8 | 2 | 24 | 12
  9 | 3 | 24 | 12
 10 | 3 | 24 | 12
 11 | 3 | 24 | 12
 12 | 4 | 24 | 12
 13 | 4 | 24 | 12
 14 | 4 | 24 | 12
 15 | 5 | 24 | 12
 16 | 5 | 24 | 12
 17 | 5 | 24 | 12
 18 | 6 | 24 | 12
 19 | 6 | 24 | 12
 20 | 6 | 24 | 12
  1 | 0 | 25 | 12
  2 | 0 | 25 | 12
  3 | 1 | 25 | 12
  4 | 1 | 25 | 12
  5 | 1 | 25 | 12
  6 | 2 | 25 | 12
  7 | 2 | 25 | 12
  8 | 2 | 25 | 12
  9 | 3 | 25 | 12
 10 | 3 | 25 | 12
 11 | 3 | 25 | 12
 12 | 4 | 25 | 12
 13 | 4 | 25 | 12
 14 | 4 | 25 | 12
 15 | 5 | 25 | 12
 16 | 5 | 25 | 12
 17 | 5 | 25 | 12
 18 | 6 | 25 | 12
 19 | 6 | 25 | 12
 20 | 6 | 25 | 12
  1 | 0 | 26 | 13
  2 | 0 | 26 | 13
  3 | 1 | 26 | 13
  4 | 1 | 26 | 13
  5 | 1 | 26 | 13
  6 | 2 | 26 | 13
  7 | 2 | 26 | 13
  8 | 2 | 26 | 13
  9 | 3 | 26 | 13
 10 | 3 | 26 | 13
 11 | 3 | 26 | 13
 12 | 4 | 26 | 13
 13 | 4 | 26 | 13
 14 | 4 | 26 | 13
 15 | 5 | 26 | 13
 16 | 5 | 26 | 13
 17 | 5 | 26 | 13
 18 | 6 | 26 | 13
 19 | 6 | 26 | 13
 20 | 6 | 26 | 13
  1 | 0 | 27 | 13
  2 | 0 | 27 | 13
  3 | 1 | 27 | 13
  4 | 1 | 27 | 13
  5 | 1 | 27 | 13
  6 | 2 | 27 | 13
  7 | 2 | 27 | 13
  8 | 2 | 27 | 13
  9 | 3 | 27 | 13
 10 | 3 | 27 | 13
 11 | 3 | 27 | 13
 12 | 4 | 27 | 13
 13 | 4 | 27 | 13
 14 | 4 | 27 | 13
 15 | 5 | 27 | 13
 16 | 5 | 27 | 13
 17 | 5 | 27 | 13
 18 | 6 | 27 | 13
 19 | 6 | 27 | 13
 20 | 6 | 27 | 13
  1 | 0 | 28 | 14
  2 | 0 | 28 | 14
  3 | 1 | 28 | 14
  4 | 1 | 28 | 14
  5 | 1 | 28 | 14
  6 | 2 | 28 | 14
  7 | 2 | 28 | 14
  8 | 2 | 28 | 14
  9 | 3 | 28 | 14
 10 | 3 | 28 | 14
 11 | 3 | 28 | 14
 12 | 4 | 28 | 14
 13 | 4 | 28 | 14
 14 | 4 | 28 | 14
 15 | 5 | 28 | 14
 16 | 5 | 28 | 14
 17 | 5 | 28 | 14
 18 | 6 | 28 | 14
 19 | 6 | 28 | 14
 20 | 6 | 28 | 14
  1 | 0 | 29 | 14
  2 | 0 | 29 | 14
  3 | 1 | 29 | 14
  4 | 1 | 29 | 14
  5 | 1 | 29 | 14
  6 | 2 | 29 | 14
  7 | 2 | 29 | 14
  8 | 2 | 29 | 14
  9 | 3 | 29 | 14
 10 | 3 | 29 | 14
 11 | 3 | 29 | 14
 12 | 4 | 29 | 14
 13 | 4 | 29 | 14
 14 | 4 | 29 | 14
 15 | 5 | 29 | 14
 16 | 5 | 29 | 14
 17 | 5 | 29 | 14
 18 | 6 | 29 | 14
 19 | 6 | 29 | 14
 20 | 6 | 29 | 14
  1 | 0 | 30 | 15
  2 | 0 | 30 | 15
  3 | 1 | 30 | 15
  4 | 1 | 30 | 15
  5 | 1 | 30 | 15
  6 | 2 | 30 | 15
  7 | 2 | 30 | 15
  8 | 2 | 30 | 15
  9 | 3 | 30 | 15
 10 | 3 | 30 | 15
 11 | 3 | 30 | 15
 12 | 4 | 30 | 15
 13 | 4 | 30 | 15
 14 | 4 | 30 | 15
 15 | 5 | 30 | 15
 16 | 5 | 30 | 15
 17 | 5 | 30 | 15
 18 | 6 | 30 | 15
 19 | 6 | 30 | 15
 20 | 6 | 30 | 15
(600 rows)

                       QUERY PLAN                        
---------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   ->  Nested Loop
         Output: r.a, r.b, s.c, s.d
         Join Filter: ((r.a < (s.c + 1)) OR (r.a > s.c))
         ->  Partial Seq Scan on orca.s
               Output: s.c, s.d
         ->  Full Seq Scan on orca.r
               Output: r.a, r.b
 Optimizer: PolarDB PX Optimizer
(10 rows)

select sum(r.a) from orca.r;
 sum 
-----
 210
(1 row)

                   QUERY PLAN                    
-------------------------------------------------
 Finalize Aggregate
   Output: sum(a)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL sum(a))
         ->  Partial Aggregate
               Output: PARTIAL sum(a)
               ->  Partial Seq Scan on orca.r
                     Output: a
 Optimizer: PolarDB PX Optimizer
(9 rows)

select count(*) from orca.r;
 count 
-------
    20
(1 row)

                   QUERY PLAN                    
-------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(8 rows)

select a, b from orca.r, orca.s group by a,b;
 a  | b 
----+---
  4 | 1
 19 | 6
 10 | 3
 16 | 5
  2 | 0
 14 | 4
 15 | 5
  7 | 2
 11 | 3
  6 | 2
 18 | 6
  5 | 1
 17 | 5
 13 | 4
  8 | 2
  1 | 0
 20 | 6
  3 | 1
  9 | 3
 12 | 4
(20 rows)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b
   ->  GroupAggregate
         Output: r.a, r.b
         Group Key: r.a, r.b
         ->  Sort
               Output: r.a, r.b
               Sort Key: r.a, r.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: r.a, r.b
                     Hash Key: r.a, r.b
                     ->  HashAggregate
                           Output: r.a, r.b
                           Group Key: r.a, r.b
                           ->  Nested Loop
                                 Output: r.a, r.b
                                 Join Filter: true
                                 ->  Partial Seq Scan on orca.r
                                       Output: r.a, r.b
                                 ->  Materialize
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             ->  Partial Seq Scan on orca.s
 Optimizer: PolarDB PX Optimizer
(23 rows)

select r.a+1 from orca.r;
 ?column? 
----------
        2
        3
        4
        5
        6
        7
        8
        9
       10
       11
       12
       13
       14
       15
       16
       17
       18
       19
       20
       21
(20 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((a + 1))
   ->  Partial Seq Scan on orca.r
         Output: (a + 1)
 Optimizer: PolarDB PX Optimizer
(5 rows)

select * from orca.r, orca.s where r.a<s.c or (r.b<s.d and r.b>s.c);
 a  | b | c  | d  
----+---+----+----
  1 | 0 |  2 |  1
  1 | 0 |  3 |  1
  2 | 0 |  3 |  1
  1 | 0 |  4 |  2
  2 | 0 |  4 |  2
  3 | 1 |  4 |  2
  1 | 0 |  5 |  2
  2 | 0 |  5 |  2
  3 | 1 |  5 |  2
  4 | 1 |  5 |  2
  1 | 0 |  6 |  3
  2 | 0 |  6 |  3
  3 | 1 |  6 |  3
  4 | 1 |  6 |  3
  5 | 1 |  6 |  3
  1 | 0 |  7 |  3
  2 | 0 |  7 |  3
  3 | 1 |  7 |  3
  4 | 1 |  7 |  3
  5 | 1 |  7 |  3
  6 | 2 |  7 |  3
  1 | 0 |  8 |  4
  2 | 0 |  8 |  4
  3 | 1 |  8 |  4
  4 | 1 |  8 |  4
  5 | 1 |  8 |  4
  6 | 2 |  8 |  4
  7 | 2 |  8 |  4
  1 | 0 |  9 |  4
  2 | 0 |  9 |  4
  3 | 1 |  9 |  4
  4 | 1 |  9 |  4
  5 | 1 |  9 |  4
  6 | 2 |  9 |  4
  7 | 2 |  9 |  4
  8 | 2 |  9 |  4
  1 | 0 | 10 |  5
  2 | 0 | 10 |  5
  3 | 1 | 10 |  5
  4 | 1 | 10 |  5
  5 | 1 | 10 |  5
  6 | 2 | 10 |  5
  7 | 2 | 10 |  5
  8 | 2 | 10 |  5
  9 | 3 | 10 |  5
  1 | 0 | 11 |  5
  2 | 0 | 11 |  5
  3 | 1 | 11 |  5
  4 | 1 | 11 |  5
  5 | 1 | 11 |  5
  6 | 2 | 11 |  5
  7 | 2 | 11 |  5
  8 | 2 | 11 |  5
  9 | 3 | 11 |  5
 10 | 3 | 11 |  5
  1 | 0 | 12 |  6
  2 | 0 | 12 |  6
  3 | 1 | 12 |  6
  4 | 1 | 12 |  6
  5 | 1 | 12 |  6
  6 | 2 | 12 |  6
  7 | 2 | 12 |  6
  8 | 2 | 12 |  6
  9 | 3 | 12 |  6
 10 | 3 | 12 |  6
 11 | 3 | 12 |  6
  1 | 0 | 13 |  6
  2 | 0 | 13 |  6
  3 | 1 | 13 |  6
  4 | 1 | 13 |  6
  5 | 1 | 13 |  6
  6 | 2 | 13 |  6
  7 | 2 | 13 |  6
  8 | 2 | 13 |  6
  9 | 3 | 13 |  6
 10 | 3 | 13 |  6
 11 | 3 | 13 |  6
 12 | 4 | 13 |  6
  1 | 0 | 14 |  7
  2 | 0 | 14 |  7
  3 | 1 | 14 |  7
  4 | 1 | 14 |  7
  5 | 1 | 14 |  7
  6 | 2 | 14 |  7
  7 | 2 | 14 |  7
  8 | 2 | 14 |  7
  9 | 3 | 14 |  7
 10 | 3 | 14 |  7
 11 | 3 | 14 |  7
 12 | 4 | 14 |  7
 13 | 4 | 14 |  7
  1 | 0 | 15 |  7
  2 | 0 | 15 |  7
  3 | 1 | 15 |  7
  4 | 1 | 15 |  7
  5 | 1 | 15 |  7
  6 | 2 | 15 |  7
  7 | 2 | 15 |  7
  8 | 2 | 15 |  7
  9 | 3 | 15 |  7
 10 | 3 | 15 |  7
 11 | 3 | 15 |  7
 12 | 4 | 15 |  7
 13 | 4 | 15 |  7
 14 | 4 | 15 |  7
  1 | 0 | 16 |  8
  2 | 0 | 16 |  8
  3 | 1 | 16 |  8
  4 | 1 | 16 |  8
  5 | 1 | 16 |  8
  6 | 2 | 16 |  8
  7 | 2 | 16 |  8
  8 | 2 | 16 |  8
  9 | 3 | 16 |  8
 10 | 3 | 16 |  8
 11 | 3 | 16 |  8
 12 | 4 | 16 |  8
 13 | 4 | 16 |  8
 14 | 4 | 16 |  8
 15 | 5 | 16 |  8
  1 | 0 | 17 |  8
  2 | 0 | 17 |  8
  3 | 1 | 17 |  8
  4 | 1 | 17 |  8
  5 | 1 | 17 |  8
  6 | 2 | 17 |  8
  7 | 2 | 17 |  8
  8 | 2 | 17 |  8
  9 | 3 | 17 |  8
 10 | 3 | 17 |  8
 11 | 3 | 17 |  8
 12 | 4 | 17 |  8
 13 | 4 | 17 |  8
 14 | 4 | 17 |  8
 15 | 5 | 17 |  8
 16 | 5 | 17 |  8
  1 | 0 | 18 |  9
  2 | 0 | 18 |  9
  3 | 1 | 18 |  9
  4 | 1 | 18 |  9
  5 | 1 | 18 |  9
  6 | 2 | 18 |  9
  7 | 2 | 18 |  9
  8 | 2 | 18 |  9
  9 | 3 | 18 |  9
 10 | 3 | 18 |  9
 11 | 3 | 18 |  9
 12 | 4 | 18 |  9
 13 | 4 | 18 |  9
 14 | 4 | 18 |  9
 15 | 5 | 18 |  9
 16 | 5 | 18 |  9
 17 | 5 | 18 |  9
  1 | 0 | 19 |  9
  2 | 0 | 19 |  9
  3 | 1 | 19 |  9
  4 | 1 | 19 |  9
  5 | 1 | 19 |  9
  6 | 2 | 19 |  9
  7 | 2 | 19 |  9
  8 | 2 | 19 |  9
  9 | 3 | 19 |  9
 10 | 3 | 19 |  9
 11 | 3 | 19 |  9
 12 | 4 | 19 |  9
 13 | 4 | 19 |  9
 14 | 4 | 19 |  9
 15 | 5 | 19 |  9
 16 | 5 | 19 |  9
 17 | 5 | 19 |  9
 18 | 6 | 19 |  9
  1 | 0 | 20 | 10
  2 | 0 | 20 | 10
  3 | 1 | 20 | 10
  4 | 1 | 20 | 10
  5 | 1 | 20 | 10
  6 | 2 | 20 | 10
  7 | 2 | 20 | 10
  8 | 2 | 20 | 10
  9 | 3 | 20 | 10
 10 | 3 | 20 | 10
 11 | 3 | 20 | 10
 12 | 4 | 20 | 10
 13 | 4 | 20 | 10
 14 | 4 | 20 | 10
 15 | 5 | 20 | 10
 16 | 5 | 20 | 10
 17 | 5 | 20 | 10
 18 | 6 | 20 | 10
 19 | 6 | 20 | 10
  1 | 0 | 21 | 10
  2 | 0 | 21 | 10
  3 | 1 | 21 | 10
  4 | 1 | 21 | 10
  5 | 1 | 21 | 10
  6 | 2 | 21 | 10
  7 | 2 | 21 | 10
  8 | 2 | 21 | 10
  9 | 3 | 21 | 10
 10 | 3 | 21 | 10
 11 | 3 | 21 | 10
 12 | 4 | 21 | 10
 13 | 4 | 21 | 10
 14 | 4 | 21 | 10
 15 | 5 | 21 | 10
 16 | 5 | 21 | 10
 17 | 5 | 21 | 10
 18 | 6 | 21 | 10
 19 | 6 | 21 | 10
 20 | 6 | 21 | 10
  1 | 0 | 22 | 11
  2 | 0 | 22 | 11
  3 | 1 | 22 | 11
  4 | 1 | 22 | 11
  5 | 1 | 22 | 11
  6 | 2 | 22 | 11
  7 | 2 | 22 | 11
  8 | 2 | 22 | 11
  9 | 3 | 22 | 11
 10 | 3 | 22 | 11
 11 | 3 | 22 | 11
 12 | 4 | 22 | 11
 13 | 4 | 22 | 11
 14 | 4 | 22 | 11
 15 | 5 | 22 | 11
 16 | 5 | 22 | 11
 17 | 5 | 22 | 11
 18 | 6 | 22 | 11
 19 | 6 | 22 | 11
 20 | 6 | 22 | 11
  1 | 0 | 23 | 11
  2 | 0 | 23 | 11
  3 | 1 | 23 | 11
  4 | 1 | 23 | 11
  5 | 1 | 23 | 11
  6 | 2 | 23 | 11
  7 | 2 | 23 | 11
  8 | 2 | 23 | 11
  9 | 3 | 23 | 11
 10 | 3 | 23 | 11
 11 | 3 | 23 | 11
 12 | 4 | 23 | 11
 13 | 4 | 23 | 11
 14 | 4 | 23 | 11
 15 | 5 | 23 | 11
 16 | 5 | 23 | 11
 17 | 5 | 23 | 11
 18 | 6 | 23 | 11
 19 | 6 | 23 | 11
 20 | 6 | 23 | 11
  1 | 0 | 24 | 12
  2 | 0 | 24 | 12
  3 | 1 | 24 | 12
  4 | 1 | 24 | 12
  5 | 1 | 24 | 12
  6 | 2 | 24 | 12
  7 | 2 | 24 | 12
  8 | 2 | 24 | 12
  9 | 3 | 24 | 12
 10 | 3 | 24 | 12
 11 | 3 | 24 | 12
 12 | 4 | 24 | 12
 13 | 4 | 24 | 12
 14 | 4 | 24 | 12
 15 | 5 | 24 | 12
 16 | 5 | 24 | 12
 17 | 5 | 24 | 12
 18 | 6 | 24 | 12
 19 | 6 | 24 | 12
 20 | 6 | 24 | 12
  1 | 0 | 25 | 12
  2 | 0 | 25 | 12
  3 | 1 | 25 | 12
  4 | 1 | 25 | 12
  5 | 1 | 25 | 12
  6 | 2 | 25 | 12
  7 | 2 | 25 | 12
  8 | 2 | 25 | 12
  9 | 3 | 25 | 12
 10 | 3 | 25 | 12
 11 | 3 | 25 | 12
 12 | 4 | 25 | 12
 13 | 4 | 25 | 12
 14 | 4 | 25 | 12
 15 | 5 | 25 | 12
 16 | 5 | 25 | 12
 17 | 5 | 25 | 12
 18 | 6 | 25 | 12
 19 | 6 | 25 | 12
 20 | 6 | 25 | 12
  1 | 0 | 26 | 13
  2 | 0 | 26 | 13
  3 | 1 | 26 | 13
  4 | 1 | 26 | 13
  5 | 1 | 26 | 13
  6 | 2 | 26 | 13
  7 | 2 | 26 | 13
  8 | 2 | 26 | 13
  9 | 3 | 26 | 13
 10 | 3 | 26 | 13
 11 | 3 | 26 | 13
 12 | 4 | 26 | 13
 13 | 4 | 26 | 13
 14 | 4 | 26 | 13
 15 | 5 | 26 | 13
 16 | 5 | 26 | 13
 17 | 5 | 26 | 13
 18 | 6 | 26 | 13
 19 | 6 | 26 | 13
 20 | 6 | 26 | 13
  1 | 0 | 27 | 13
  2 | 0 | 27 | 13
  3 | 1 | 27 | 13
  4 | 1 | 27 | 13
  5 | 1 | 27 | 13
  6 | 2 | 27 | 13
  7 | 2 | 27 | 13
  8 | 2 | 27 | 13
  9 | 3 | 27 | 13
 10 | 3 | 27 | 13
 11 | 3 | 27 | 13
 12 | 4 | 27 | 13
 13 | 4 | 27 | 13
 14 | 4 | 27 | 13
 15 | 5 | 27 | 13
 16 | 5 | 27 | 13
 17 | 5 | 27 | 13
 18 | 6 | 27 | 13
 19 | 6 | 27 | 13
 20 | 6 | 27 | 13
  1 | 0 | 28 | 14
  2 | 0 | 28 | 14
  3 | 1 | 28 | 14
  4 | 1 | 28 | 14
  5 | 1 | 28 | 14
  6 | 2 | 28 | 14
  7 | 2 | 28 | 14
  8 | 2 | 28 | 14
  9 | 3 | 28 | 14
 10 | 3 | 28 | 14
 11 | 3 | 28 | 14
 12 | 4 | 28 | 14
 13 | 4 | 28 | 14
 14 | 4 | 28 | 14
 15 | 5 | 28 | 14
 16 | 5 | 28 | 14
 17 | 5 | 28 | 14
 18 | 6 | 28 | 14
 19 | 6 | 28 | 14
 20 | 6 | 28 | 14
  1 | 0 | 29 | 14
  2 | 0 | 29 | 14
  3 | 1 | 29 | 14
  4 | 1 | 29 | 14
  5 | 1 | 29 | 14
  6 | 2 | 29 | 14
  7 | 2 | 29 | 14
  8 | 2 | 29 | 14
  9 | 3 | 29 | 14
 10 | 3 | 29 | 14
 11 | 3 | 29 | 14
 12 | 4 | 29 | 14
 13 | 4 | 29 | 14
 14 | 4 | 29 | 14
 15 | 5 | 29 | 14
 16 | 5 | 29 | 14
 17 | 5 | 29 | 14
 18 | 6 | 29 | 14
 19 | 6 | 29 | 14
 20 | 6 | 29 | 14
  1 | 0 | 30 | 15
  2 | 0 | 30 | 15
  3 | 1 | 30 | 15
  4 | 1 | 30 | 15
  5 | 1 | 30 | 15
  6 | 2 | 30 | 15
  7 | 2 | 30 | 15
  8 | 2 | 30 | 15
  9 | 3 | 30 | 15
 10 | 3 | 30 | 15
 11 | 3 | 30 | 15
 12 | 4 | 30 | 15
 13 | 4 | 30 | 15
 14 | 4 | 30 | 15
 15 | 5 | 30 | 15
 16 | 5 | 30 | 15
 17 | 5 | 30 | 15
 18 | 6 | 30 | 15
 19 | 6 | 30 | 15
 20 | 6 | 30 | 15
(390 rows)

                             QUERY PLAN                              
---------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   ->  Nested Loop
         Output: r.a, r.b, s.c, s.d
         Join Filter: ((r.a < s.c) OR ((r.b < s.d) AND (r.b > s.c)))
         ->  Partial Seq Scan on orca.r
               Output: r.a, r.b
         ->  Full Seq Scan on orca.s
               Output: s.c, s.d
 Optimizer: PolarDB PX Optimizer
(10 rows)

select case when r.a<s.c then r.a<s.c else r.a<s.c end from orca.r, orca.s;
 case 
------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
(600 rows)

                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (CASE WHEN (r.a < s.c) THEN (r.a < s.c) ELSE (r.a < s.c) END)
   ->  Nested Loop
         Output: CASE WHEN (r.a < s.c) THEN (r.a < s.c) ELSE (r.a < s.c) END
         Join Filter: true
         ->  Partial Seq Scan on orca.s
               Output: s.c
         ->  Full Seq Scan on orca.r
               Output: r.a
 Optimizer: PolarDB PX Optimizer
(10 rows)

select case r.b<s.c when true then r.b else s.c end from orca.r, orca.s where r.a = s.d;
 c 
---
 0
 0
 0
 0
 1
 1
 1
 1
 1
 1
 2
 2
 2
 2
 2
 2
 3
 3
 3
 3
 3
 3
 4
 4
 4
 4
 4
 4
 5
(29 rows)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (CASE (r.b < s.c) WHEN CASE_TEST_EXPR THEN r.b ELSE s.c END)
   ->  Hash Join
         Output: CASE (r.b < s.c) WHEN CASE_TEST_EXPR THEN r.b ELSE s.c END
         Hash Cond: (s.d = r.a)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: s.c, s.d
               Hash Key: s.d
               ->  Partial Seq Scan on orca.s
                     Output: s.c, s.d
         ->  Hash
               Output: r.a, r.b
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: r.a, r.b
                     Hash Key: r.a
                     ->  Partial Seq Scan on orca.r
                           Output: r.a, r.b
 Optimizer: PolarDB PX Optimizer
(18 rows)

select * from orca.r limit 100;
 a  | b 
----+---
  1 | 0
  2 | 0
  3 | 1
  4 | 1
  5 | 1
  6 | 2
  7 | 2
  8 | 2
  9 | 3
 10 | 3
 11 | 3
 12 | 4
 13 | 4
 14 | 4
 15 | 5
 16 | 5
 17 | 5
 18 | 6
 19 | 6
 20 | 6
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Limit
   Output: a, b
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         ->  Partial Seq Scan on orca.r
               Output: a, b
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from orca.r limit 10 offset 9;
 a  | b 
----+---
 10 | 3
 11 | 3
 12 | 4
 13 | 4
 14 | 4
 15 | 5
 16 | 5
 17 | 5
 18 | 6
 19 | 6
(10 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Limit
   Output: a, b
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         ->  Partial Seq Scan on orca.r
               Output: a, b
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from orca.r offset 10;
 a  | b 
----+---
 11 | 3
 12 | 4
 13 | 4
 14 | 4
 15 | 5
 16 | 5
 17 | 5
 18 | 6
 19 | 6
 20 | 6
(10 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Limit
   Output: a, b
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         ->  Partial Seq Scan on orca.r
               Output: a, b
 Optimizer: PolarDB PX Optimizer
(7 rows)

select sqrt(r.a) from orca.r;
       sqrt       
------------------
                1
  1.4142135623731
 1.73205080756888
                2
 2.23606797749979
 2.44948974278318
 2.64575131106459
 2.82842712474619
                3
 3.16227766016838
  3.3166247903554
 3.46410161513775
 3.60555127546399
 3.74165738677394
 3.87298334620742
                4
 4.12310562561766
 4.24264068711928
 4.35889894354067
 4.47213595499958
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: sqrt((a)::double precision)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a
         ->  Partial Seq Scan on orca.r
               Output: a
 Optimizer: PolarDB PX Optimizer
(7 rows)

select pow(r.b,r.a) from orca.r;
         pow          
----------------------
                    0
                    0
                    1
                    1
                    1
                   64
                  128
                  256
                19683
                59049
               177147
             16777216
             67108864
            268435456
          30517578125
         152587890625
         762939453125
      101559956668416
      609359740010496
 3.65615844006298e+15
(20 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (pow((b)::double precision, (a)::double precision))
   ->  Partial Seq Scan on orca.r
         Output: pow((b)::double precision, (a)::double precision)
 Optimizer: PolarDB PX Optimizer
(5 rows)

select b from orca.r group by b having  count(*) > 2;
 b 
---
 1
 5
 4
 2
 6
 3
(6 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: b
   ->  Result
         Output: b
         Filter: ((count()) > 2)
         ->  GroupAggregate
               Output: count(), b
               Group Key: r.b
               ->  Sort
                     Output: b
                     Sort Key: r.b
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: b
                           Hash Key: b
                           ->  Partial Seq Scan on orca.r
                                 Output: b
 Optimizer: PolarDB PX Optimizer
(17 rows)

select b from orca.r group by b having  count(*) <= avg(a) + (select count(*) from orca.s where s.c = r.b);
 b 
---
 1
 5
 4
 2
 6
 3
(6 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.b
   ->  Result
         Output: r.b
         Filter: (((count()))::numeric <= ((avg(r.a)) + (COALESCE((count()), '0'::bigint))::numeric))
         ->  Hash Right Join
               Output: (count()), r.b, (count()), (avg(r.a))
               Hash Cond: (s.c = r.b)
               ->  GroupAggregate
                     Output: count(), s.c
                     Group Key: s.c
                     ->  Sort
                           Output: s.c
                           Sort Key: s.c
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: s.c
                                 Hash Key: s.c
                                 ->  Partial Seq Scan on orca.s
                                       Output: s.c
               ->  Hash
                     Output: (count()), (avg(r.a)), r.b
                     ->  HashAggregate
                           Output: count(), avg(r.a), r.b
                           Group Key: r.b
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: r.a, r.b
                                 Hash Key: r.b
                                 ->  Partial Seq Scan on orca.r
                                       Output: r.a, r.b
 Optimizer: PolarDB PX Optimizer
(30 rows)

select sum(a) from orca.r group by b having count(*) > 2 order by b+1;
 sum 
-----
  12
  21
  30
  39
  48
  57
(6 rows)

                            QUERY PLAN                            
------------------------------------------------------------------
 Result
   Output: (sum(a))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (sum(a)), ((b + 1))
         Merge Key: ((b + 1))
         ->  Sort
               Output: (sum(a)), ((b + 1))
               Sort Key: ((r.b + 1))
               ->  Result
                     Output: (sum(a)), (b + 1)
                     Filter: ((count()) > 2)
                     ->  HashAggregate
                           Output: sum(a), count(), b
                           Group Key: r.b
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: a, b
                                 Hash Key: b
                                 ->  Partial Seq Scan on orca.r
                                       Output: a, b
 Optimizer: PolarDB PX Optimizer
(20 rows)

select sum(a) from orca.r group by b having count(*) > 2 order by b+1;
 sum 
-----
  12
  21
  30
  39
  48
  57
(6 rows)

                            QUERY PLAN                            
------------------------------------------------------------------
 Result
   Output: (sum(a))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (sum(a)), ((b + 1))
         Merge Key: ((b + 1))
         ->  Sort
               Output: (sum(a)), ((b + 1))
               Sort Key: ((r.b + 1))
               ->  Result
                     Output: (sum(a)), (b + 1)
                     Filter: ((count()) > 2)
                     ->  HashAggregate
                           Output: sum(a), count(), b
                           Group Key: r.b
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: a, b
                                 Hash Key: b
                                 ->  Partial Seq Scan on orca.r
                                       Output: a, b
 Optimizer: PolarDB PX Optimizer
(20 rows)

-- constants
select 0.001::numeric from orca.r;
 numeric 
---------
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: 0.001
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select NULL::text, NULL::int from orca.r;
 text | int4 
------+------
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: NULL::text, NULL::integer
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select 'helloworld'::text, 'helloworld2'::varchar from orca.r;
    text    |   varchar   
------------+-------------
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
(20 rows)

                           QUERY PLAN                           
----------------------------------------------------------------
 Result
   Output: 'helloworld'::text, 'helloworld2'::character varying
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select 129::bigint, 5623::int, 45::smallint from orca.r;
 int8 | int4 | int2 
------+------+------
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: '129'::bigint, 5623, '45'::smallint
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select 0.001::numeric from orca.r;
 numeric 
---------
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
   0.001
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: 0.001
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select NULL::text, NULL::int from orca.r;
 text | int4 
------+------
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
      |     
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: NULL::text, NULL::integer
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select 'helloworld'::text, 'helloworld2'::varchar from orca.r;
    text    |   varchar   
------------+-------------
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
 helloworld | helloworld2
(20 rows)

                           QUERY PLAN                           
----------------------------------------------------------------
 Result
   Output: 'helloworld'::text, 'helloworld2'::character varying
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

select 129::bigint, 5623::int, 45::smallint from orca.r;
 int8 | int4 | int2 
------+------+------
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
  129 | 5623 |   45
(20 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: '129'::bigint, 5623, '45'::smallint
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(5 rows)

--  distributed tables
create table orca.foo (x1 int, x2 int, x3 int);
create table orca.bar1 (x1 int, x2 int, x3 int);
create table orca.bar2 (x1 int, x2 int, x3 int);
insert into orca.foo select i,i+1,i+2 from generate_series(1,10) i;
insert into orca.bar1 select i,i+1,i+2 from generate_series(1,20) i;
insert into orca.bar2 select i,i+1,i+2 from generate_series(1,30) i;
analyze orca.foo;
analyze orca.bar1;
analyze orca.bar2;
-- produces result node
select x2 from orca.foo where x1 in (select x2 from orca.bar1);
 x2 
----
  3
  4
  5
  6
  7
  8
  9
 10
 11
(9 rows)

                      QUERY PLAN                       
-------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.x2
   ->  Hash Semi Join
         Output: foo.x2
         Hash Cond: (foo.x1 = bar1.x2)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.x1, foo.x2
               Hash Key: foo.x1
               ->  Partial Seq Scan on orca.foo
                     Output: foo.x1, foo.x2
         ->  Hash
               Output: bar1.x2
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: bar1.x2
                     Hash Key: bar1.x2
                     ->  Partial Seq Scan on orca.bar1
                           Output: bar1.x2
 Optimizer: PolarDB PX Optimizer
(18 rows)

select 1;
 ?column? 
----------
        1
(1 row)

SELECT 1 AS one FROM orca.foo having 1 < 2;
 one 
-----
   1
(1 row)

SELECT generate_series(1,5) AS one FROM orca.foo having 1 < 2;
 one 
-----
   1
   2
   3
   4
   5
(5 rows)

SELECT 1 AS one FROM orca.foo group by x1 having 1 < 2;
 one 
-----
   1
   1
   1
   1
   1
   1
   1
   1
   1
   1
(10 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 Result
   Output: 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  GroupAggregate
               Group Key: foo.x1
               ->  Sort
                     Output: x1
                     Sort Key: foo.x1
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: x1
                           Hash Key: x1
                           ->  Partial Seq Scan on orca.foo
                                 Output: x1
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT x1 AS one FROM orca.foo having 1 < 2;
ERROR:  column "foo.x1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT x1 AS one FROM orca.foo having 1 < 2;
               ^
-- distinct clause
select distinct 1, null;
 ?column? | ?column? 
----------+----------
        1 | 
(1 row)

select distinct 1, null from orca.foo;
 ?column? | ?column? 
----------+----------
        1 | 
(1 row)

                            QUERY PLAN                            
------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (1), (NULL::text)
   ->  GroupAggregate
         Output: (1), (NULL::text)
         Group Key: (1), (NULL::text)
         ->  Sort
               Output: (1), (NULL::text)
               Sort Key: (1), (NULL::text)
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: (1), (NULL::text)
                     Hash Key: (1), (NULL::text)
                     ->  GroupAggregate
                           Output: (1), (NULL::text)
                           Group Key: (1), (NULL::text)
                           ->  Sort
                                 Output: (1), (NULL::text)
                                 Sort Key: (1), (NULL::text)
                                 ->  Partial Seq Scan on orca.foo
                                       Output: 1, NULL::text
 Optimizer: PolarDB PX Optimizer
(20 rows)

select distinct 1, sum(x1) from orca.foo;
 ?column? | sum 
----------+-----
        1 |  55
(1 row)

                   QUERY PLAN                    
-------------------------------------------------
 Finalize Aggregate
   Output: 1, sum(x1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL sum(x1))
         ->  Partial Aggregate
               Output: PARTIAL sum(x1)
               ->  Partial Seq Scan on orca.foo
                     Output: x1
 Optimizer: PolarDB PX Optimizer
(9 rows)

select distinct x1, rank() over(order by x1) from (select x1 from orca.foo order by x1) x; --order none
 x1 | rank 
----+------
 10 |   10
  8 |    8
  2 |    2
  5 |    5
  1 |    1
  4 |    4
  7 |    7
  3 |    3
  9 |    9
  6 |    6
(10 rows)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: x1, (rank() OVER (?))
   ->  GroupAggregate
         Output: x1, (rank() OVER (?))
         Group Key: foo.x1, (rank() OVER (?))
         ->  Sort
               Output: x1, (rank() OVER (?))
               Sort Key: foo.x1, (rank() OVER (?))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: x1, (rank() OVER (?))
                     Hash Key: x1, (rank() OVER (?))
                     ->  GroupAggregate
                           Output: x1, (rank() OVER (?))
                           Group Key: foo.x1, (rank() OVER (?))
                           ->  Sort
                                 Output: x1, (rank() OVER (?))
                                 Sort Key: foo.x1, (rank() OVER (?))
                                 ->  PX Hash 1:6  (slice3)
                                       Output: x1, (rank() OVER (?))
                                       ->  WindowAgg
                                             Output: x1, rank() OVER (?)
                                             ->  PX Coordinator 6:1  (slice4; segments: 6)
                                                   Output: x1
                                                   Merge Key: x1
                                                   ->  Sort
                                                         Output: x1
                                                         Sort Key: foo.x1
                                                         ->  Partial Seq Scan on orca.foo
                                                               Output: x1
 Optimizer: PolarDB PX Optimizer
(30 rows)

select distinct x1, sum(x3) from orca.foo group by x1,x2;
 x1 | sum 
----+-----
  7 |   9
  8 |  10
  5 |   7
  9 |  11
  3 |   5
  2 |   4
  1 |   3
  6 |   8
  4 |   6
 10 |  12
(10 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: x1, (sum(x3))
   ->  GroupAggregate
         Output: x1, (sum(x3))
         Group Key: foo.x1, (sum(foo.x3))
         ->  Sort
               Output: x1, (sum(x3))
               Sort Key: foo.x1, (sum(foo.x3))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: x1, (sum(x3))
                     Hash Key: x1, (sum(x3))
                     ->  GroupAggregate
                           Output: x1, sum(x3)
                           Group Key: foo.x1, foo.x2
                           ->  Sort
                                 Output: x1, x2, x3
                                 Sort Key: foo.x1, foo.x2
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: x1, x2, x3
                                       Hash Key: x1, x2
                                       ->  Partial Seq Scan on orca.foo
                                             Output: x1, x2, x3
 Optimizer: PolarDB PX Optimizer
(23 rows)

select distinct s from (select sum(x2) s from orca.foo group by x1) x;
 s  
----
  3
  8
 11
  7
 10
  9
  5
  4
  2
  6
(10 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (sum(x2))
   ->  GroupAggregate
         Output: (sum(x2))
         Group Key: (sum(foo.x2))
         ->  Sort
               Output: (sum(x2))
               Sort Key: (sum(foo.x2))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: (sum(x2))
                     Hash Key: (sum(x2))
                     ->  GroupAggregate
                           Output: sum(x2)
                           Group Key: foo.x1
                           ->  Sort
                                 Output: x1, x2
                                 Sort Key: foo.x1
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: x1, x2
                                       Hash Key: x1
                                       ->  Partial Seq Scan on orca.foo
                                             Output: x1, x2
 Optimizer: PolarDB PX Optimizer
(23 rows)

select * from orca.foo a where a.x1 = (select distinct sum(b.x1)+avg(b.x1) sa from orca.bar1 b group by b.x3 order by sa limit 1);
 x1 | x2 | x3 
----+----+----
  2 |  3 |  4
(1 row)

                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.x1, foo.x2, foo.x3
   ->  Hash Join
         Output: foo.x1, foo.x2, foo.x3
         Hash Cond: ((foo.x1)::numeric = (((sum(bar1.x1))::numeric + avg(bar1.x1))))
         ->  Partial Seq Scan on orca.foo
               Output: foo.x1, foo.x2, foo.x3
         ->  Hash
               Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
               ->  PX Broadcast 1:6  (slice2)
                     Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                     ->  Limit
                           Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                 Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                 Merge Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                 ->  Limit
                                       Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                       ->  GroupAggregate
                                             Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                             Group Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                             ->  Sort
                                                   Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                   Sort Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                   ->  PX Hash 6:6  (slice4; segments: 6)
                                                         Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                         Hash Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                         ->  HashAggregate
                                                               Output: ((sum(bar1.x1))::numeric + avg(bar1.x1))
                                                               Group Key: bar1.x3
                                                               ->  PX Hash 6:6  (slice5; segments: 6)
                                                                     Output: bar1.x1, bar1.x3
                                                                     Hash Key: bar1.x3
                                                                     ->  Partial Seq Scan on orca.bar1
                                                                           Output: bar1.x1, bar1.x3
 Optimizer: PolarDB PX Optimizer
(36 rows)

select distinct a.x1 from orca.foo a where a.x1 <= (select distinct sum(b.x1)+avg(b.x1) sa from orca.bar1 b group by b.x3 order by sa limit 1) order by 1;
 x1 
----
  1
  2
(2 rows)

                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.x1
   Merge Key: foo.x1
   ->  GroupAggregate
         Output: foo.x1
         Group Key: foo.x1
         ->  Sort
               Output: foo.x1
               Sort Key: foo.x1
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.x1
                     Hash Key: foo.x1
                     ->  Nested Loop
                           Output: foo.x1
                           Join Filter: ((foo.x1)::numeric <= (((sum(bar1.x1))::numeric + avg(bar1.x1))))
                           ->  PX Broadcast 1:6  (slice3)
                                 Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                 ->  Limit
                                       Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                       ->  PX Coordinator 6:1  (slice4; segments: 6)
                                             Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                             Merge Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                             ->  Limit
                                                   Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                   ->  GroupAggregate
                                                         Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                         Group Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                         ->  Sort
                                                               Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                               Sort Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                               ->  PX Hash 6:6  (slice5; segments: 6)
                                                                     Output: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                                     Hash Key: (((sum(bar1.x1))::numeric + avg(bar1.x1)))
                                                                     ->  HashAggregate
                                                                           Output: ((sum(bar1.x1))::numeric + avg(bar1.x1))
                                                                           Group Key: bar1.x3
                                                                           ->  PX Hash 6:6  (slice6; segments: 6)
                                                                                 Output: bar1.x1, bar1.x3
                                                                                 Hash Key: bar1.x3
                                                                                 ->  Partial Seq Scan on orca.bar1
                                                                                       Output: bar1.x1, bar1.x3
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.x1
 Optimizer: PolarDB PX Optimizer
(44 rows)

select * from orca.foo a where a.x1 = (select distinct b.x1 from orca.bar1 b where b.x1=a.x1 limit 1);
 x1 | x2 | x3 
----+----+----
  1 |  2 |  3
  2 |  3 |  4
  3 |  4 |  5
  4 |  5 |  6
  5 |  6 |  7
  6 |  7 |  8
  7 |  8 |  9
  8 |  9 | 10
  9 | 10 | 11
 10 | 11 | 12
(10 rows)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.x1, foo.x2, foo.x3
   ->  Partial Seq Scan on orca.foo
         Output: foo.x1, foo.x2, foo.x3
         Filter: (foo.x1 = (SubPlan 1))
         SubPlan 1
           ->  Limit
                 Output: bar1.x1
                 ->  GroupAggregate
                       Output: bar1.x1
                       Group Key: bar1.x1
                       ->  Sort
                             Output: bar1.x1
                             Sort Key: bar1.x1
                             ->  Full Seq Scan on orca.bar1
                                   Output: bar1.x1
                                   Filter: (bar1.x1 = foo.x1)
 Optimizer: PolarDB PX Optimizer
(18 rows)

-- with clause
with cte1 as (select * from orca.foo) select a.x1+1 from (select * from cte1) a group by a.x1;
 ?column? 
----------
        9
       11
       10
        8
        2
        6
        5
        3
        7
        4
(10 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((x1 + 1))
   ->  GroupAggregate
         Output: (x1 + 1)
         Group Key: foo.x1
         ->  Sort
               Output: x1
               Sort Key: foo.x1
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: x1
                     Hash Key: x1
                     ->  Partial Seq Scan on orca.foo
                           Output: x1
 Optimizer: PolarDB PX Optimizer
(14 rows)

select count(*)+1 from orca.bar1 b where b.x1 < any (with cte1 as (select * from orca.foo) select a.x1+1 from (select * from cte1) a group by a.x1);
 ?column? 
----------
       11
(1 row)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count() + 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on orca.bar1
                     Output: bar1.x1
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Materialize
                             Output: ((foo.x1 + 1))
                             ->  PX Broadcast 6:6  (slice2; segments: 6)
                                   Output: ((foo.x1 + 1))
                                   ->  GroupAggregate
                                         Output: (foo.x1 + 1)
                                         Group Key: foo.x1
                                         ->  Sort
                                               Output: foo.x1
                                               Sort Key: foo.x1
                                               ->  PX Hash 6:6  (slice3; segments: 6)
                                                     Output: foo.x1
                                                     Hash Key: foo.x1
                                                     ->  Partial Seq Scan on orca.foo
                                                           Output: foo.x1
 Optimizer: PolarDB PX Optimizer
(26 rows)

select count(*)+1 from orca.bar1 b where b.x1 < any (with cte1 as (select * from orca.foo) select a.x1 from (select * from cte1) a group by a.x1);
 ?column? 
----------
       10
(1 row)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count() + 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on orca.bar1
                     Output: bar1.x1
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Materialize
                             Output: foo.x1
                             ->  PX Broadcast 6:6  (slice2; segments: 6)
                                   Output: foo.x1
                                   ->  GroupAggregate
                                         Output: foo.x1
                                         Group Key: foo.x1
                                         ->  Sort
                                               Output: foo.x1
                                               Sort Key: foo.x1
                                               ->  PX Hash 6:6  (slice3; segments: 6)
                                                     Output: foo.x1
                                                     Hash Key: foo.x1
                                                     ->  Partial Seq Scan on orca.foo
                                                           Output: foo.x1
 Optimizer: PolarDB PX Optimizer
(26 rows)

select count(*)+1 from orca.bar1 b where b.x1 < any (with cte1 as (select * from orca.foo) select a.x1 from cte1 a group by a.x1);
 ?column? 
----------
       10
(1 row)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count() + 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on orca.bar1
                     Output: bar1.x1
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Materialize
                             Output: foo.x1
                             ->  PX Broadcast 6:6  (slice2; segments: 6)
                                   Output: foo.x1
                                   ->  GroupAggregate
                                         Output: foo.x1
                                         Group Key: foo.x1
                                         ->  Sort
                                               Output: foo.x1
                                               Sort Key: foo.x1
                                               ->  PX Hash 6:6  (slice3; segments: 6)
                                                     Output: foo.x1
                                                     Hash Key: foo.x1
                                                     ->  Partial Seq Scan on orca.foo
                                                           Output: foo.x1
 Optimizer: PolarDB PX Optimizer
(26 rows)

with cte1 as (select * from orca.foo) select count(*)+1 from cte1 a where a.x1 < any (with cte2 as (select * from cte1 b where b.x1 > 10) select c.x1 from (select * from cte2) c group by c.x1);
 ?column? 
----------
        1
(1 row)

                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (((count()) + 1))
   ->  Sequence
         Output: (((count()) + 1))
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref2.x1, share0_ref2.x2, share0_ref2.x3
               ->  Partial Seq Scan on orca.foo
                     Output: foo.x1, foo.x2, foo.x3
         ->  Result
               Output: ((count()) + 1)
               ->  PX Hash 1:6  (slice2)
                     Output: (count())
                     ->  Finalize Aggregate
                           Output: count()
                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                 Output: (PARTIAL count())
                                 ->  Partial Aggregate
                                       Output: PARTIAL count()
                                       ->  Result
                                             Output: share0_ref3.x1
                                             Filter: (SubPlan 1)
                                             ->  Shared Scan (Consumer; slice3; share0)
                                                   Output: share0_ref3.x1, share0_ref3.x2, share0_ref3.x3
                                             SubPlan 1
                                               ->  Materialize
                                                     Output: share0_ref1.x1
                                                     ->  PX Broadcast 6:6  (slice4; segments: 6)
                                                           Output: share0_ref1.x1
                                                           ->  GroupAggregate
                                                                 Output: share0_ref1.x1
                                                                 Group Key: share0_ref1.x1
                                                                 ->  Sort
                                                                       Output: share0_ref1.x1
                                                                       Sort Key: share0_ref1.x1
                                                                       ->  PX Hash 6:6  (slice5; segments: 6)
                                                                             Output: share0_ref1.x1
                                                                             Hash Key: share0_ref1.x1
                                                                             ->  Result
                                                                                   Output: share0_ref1.x1
                                                                                   Filter: (share0_ref1.x1 > 10)
                                                                                   ->  Shared Scan (Consumer; slice5; share0)
                                                                                         Output: share0_ref1.x1, share0_ref1.x2, share0_ref1.x3
 Optimizer: PolarDB PX Optimizer
(43 rows)

with cte1 as (select * from orca.foo) select count(*)+1 from cte1 a where a.x1 < any (with cte2 as (select * from cte1 b where b.x1 > 10) select c.x1+1 from (select * from cte2) c group by c.x1);
 ?column? 
----------
        1
(1 row)

                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (((count()) + 1))
   ->  Sequence
         Output: (((count()) + 1))
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref2.x1, share0_ref2.x2, share0_ref2.x3
               ->  Partial Seq Scan on orca.foo
                     Output: foo.x1, foo.x2, foo.x3
         ->  Result
               Output: ((count()) + 1)
               ->  PX Hash 1:6  (slice2)
                     Output: (count())
                     ->  Finalize Aggregate
                           Output: count()
                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                 Output: (PARTIAL count())
                                 ->  Partial Aggregate
                                       Output: PARTIAL count()
                                       ->  Result
                                             Output: share0_ref3.x1
                                             Filter: (SubPlan 1)
                                             ->  Shared Scan (Consumer; slice3; share0)
                                                   Output: share0_ref3.x1, share0_ref3.x2, share0_ref3.x3
                                             SubPlan 1
                                               ->  Materialize
                                                     Output: ((share0_ref1.x1 + 1))
                                                     ->  PX Broadcast 6:6  (slice4; segments: 6)
                                                           Output: ((share0_ref1.x1 + 1))
                                                           ->  GroupAggregate
                                                                 Output: (share0_ref1.x1 + 1)
                                                                 Group Key: share0_ref1.x1
                                                                 ->  Sort
                                                                       Output: share0_ref1.x1
                                                                       Sort Key: share0_ref1.x1
                                                                       ->  PX Hash 6:6  (slice5; segments: 6)
                                                                             Output: share0_ref1.x1
                                                                             Hash Key: share0_ref1.x1
                                                                             ->  Result
                                                                                   Output: share0_ref1.x1
                                                                                   Filter: (share0_ref1.x1 > 10)
                                                                                   ->  Shared Scan (Consumer; slice5; share0)
                                                                                         Output: share0_ref1.x1, share0_ref1.x2, share0_ref1.x3
 Optimizer: PolarDB PX Optimizer
(43 rows)

with x as (select * from orca.foo) select count(*) from (select * from x) y where y.x1 <= (select count(*) from x);
 count 
-------
    10
(1 row)

                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count())
   ->  Sequence
         Output: (count())
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.x1, share0_ref1.x2, share0_ref1.x3
               ->  Partial Seq Scan on orca.foo
                     Output: foo.x1, foo.x2, foo.x3
         ->  PX Hash 1:6  (slice2)
               Output: (count())
               ->  Finalize Aggregate
                     Output: count()
                     ->  PX Coordinator 6:1  (slice3; segments: 6)
                           Output: (PARTIAL count())
                           ->  Partial Aggregate
                                 Output: PARTIAL count()
                                 ->  Nested Loop
                                       Join Filter: (share0_ref2.x1 <= (count()))
                                       ->  PX Broadcast 1:6  (slice4)
                                             Output: (count())
                                             ->  Finalize Aggregate
                                                   Output: count()
                                                   ->  PX Coordinator 6:1  (slice5; segments: 6)
                                                         Output: (PARTIAL count())
                                                         ->  Partial Aggregate
                                                               Output: PARTIAL count()
                                                               ->  Shared Scan (Consumer; slice5; share0)
                                                                     Output: share0_ref3.x1, share0_ref3.x2, share0_ref3.x3
                                       ->  Shared Scan (Consumer; slice3; share0)
                                             Output: share0_ref2.x1, share0_ref2.x2, share0_ref2.x3
 Optimizer: PolarDB PX Optimizer
(31 rows)

with x as (select * from orca.foo) select count(*)+1 from (select * from x) y where y.x1 <= (select count(*) from x);
 ?column? 
----------
       11
(1 row)

                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (((count()) + 1))
   ->  Sequence
         Output: (((count()) + 1))
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.x1, share0_ref1.x2, share0_ref1.x3
               ->  Partial Seq Scan on orca.foo
                     Output: foo.x1, foo.x2, foo.x3
         ->  Result
               Output: ((count()) + 1)
               ->  PX Hash 1:6  (slice2)
                     Output: (count())
                     ->  Finalize Aggregate
                           Output: count()
                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                 Output: (PARTIAL count())
                                 ->  Partial Aggregate
                                       Output: PARTIAL count()
                                       ->  Nested Loop
                                             Join Filter: (share0_ref2.x1 <= (count()))
                                             ->  PX Broadcast 1:6  (slice4)
                                                   Output: (count())
                                                   ->  Finalize Aggregate
                                                         Output: count()
                                                         ->  PX Coordinator 6:1  (slice5; segments: 6)
                                                               Output: (PARTIAL count())
                                                               ->  Partial Aggregate
                                                                     Output: PARTIAL count()
                                                                     ->  Shared Scan (Consumer; slice5; share0)
                                                                           Output: share0_ref3.x1, share0_ref3.x2, share0_ref3.x3
                                             ->  Shared Scan (Consumer; slice3; share0)
                                                   Output: share0_ref2.x1, share0_ref2.x2, share0_ref2.x3
 Optimizer: PolarDB PX Optimizer
(33 rows)

with x as (select * from orca.foo) select count(*) from (select * from x) y where y.x1 < (with z as (select * from x) select count(*) from z);
 count 
-------
     9
(1 row)

                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count())
   ->  Sequence
         Output: (count())
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.x1, share0_ref1.x2, share0_ref1.x3
               ->  Partial Seq Scan on orca.foo
                     Output: foo.x1, foo.x2, foo.x3
         ->  PX Hash 1:6  (slice2)
               Output: (count())
               ->  Finalize Aggregate
                     Output: count()
                     ->  PX Coordinator 6:1  (slice3; segments: 6)
                           Output: (PARTIAL count())
                           ->  Partial Aggregate
                                 Output: PARTIAL count()
                                 ->  Nested Loop
                                       Join Filter: (share0_ref2.x1 < (count()))
                                       ->  PX Broadcast 1:6  (slice4)
                                             Output: (count())
                                             ->  Finalize Aggregate
                                                   Output: count()
                                                   ->  PX Coordinator 6:1  (slice5; segments: 6)
                                                         Output: (PARTIAL count())
                                                         ->  Partial Aggregate
                                                               Output: PARTIAL count()
                                                               ->  Shared Scan (Consumer; slice5; share0)
                                                                     Output: share0_ref3.x1, share0_ref3.x2, share0_ref3.x3
                                       ->  Shared Scan (Consumer; slice3; share0)
                                             Output: share0_ref2.x1, share0_ref2.x2, share0_ref2.x3
 Optimizer: PolarDB PX Optimizer
(31 rows)

-- outer references
select count(*)+1 from orca.foo x where x.x1 > (select count(*)+1 from orca.bar1 y where y.x1 = x.x2);
 ?column? 
----------
        9
(1 row)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count() + 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Result
                     Filter: (foo.x1 > ((COALESCE((count()), '0'::bigint) + 1)))
                     ->  Hash Left Join
                           Output: (COALESCE((count()), '0'::bigint) + 1), foo.x1
                           Hash Cond: (foo.x2 = bar1.x1)
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: foo.x1, foo.x2
                                 Hash Key: foo.x2
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.x1, foo.x2
                           ->  Hash
                                 Output: (count()), bar1.x1
                                 ->  GroupAggregate
                                       Output: count(), bar1.x1
                                       Group Key: bar1.x1
                                       ->  Sort
                                             Output: bar1.x1
                                             Sort Key: bar1.x1
                                             ->  PX Hash 6:6  (slice3; segments: 6)
                                                   Output: bar1.x1
                                                   Hash Key: bar1.x1
                                                   ->  Partial Seq Scan on orca.bar1
                                                         Output: bar1.x1
 Optimizer: PolarDB PX Optimizer
(30 rows)

select count(*)+1 from orca.foo x where x.x1 > (select count(*) from orca.bar1 y where y.x1 = x.x2);
 ?column? 
----------
       10
(1 row)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count() + 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Result
                     Filter: (foo.x1 > COALESCE((count()), '0'::bigint))
                     ->  Hash Left Join
                           Output: (count()), foo.x1
                           Hash Cond: (foo.x2 = bar1.x1)
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: foo.x1, foo.x2
                                 Hash Key: foo.x2
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.x1, foo.x2
                           ->  Hash
                                 Output: (count()), bar1.x1
                                 ->  GroupAggregate
                                       Output: count(), bar1.x1
                                       Group Key: bar1.x1
                                       ->  Sort
                                             Output: bar1.x1
                                             Sort Key: bar1.x1
                                             ->  PX Hash 6:6  (slice3; segments: 6)
                                                   Output: bar1.x1
                                                   Hash Key: bar1.x1
                                                   ->  Partial Seq Scan on orca.bar1
                                                         Output: bar1.x1
 Optimizer: PolarDB PX Optimizer
(30 rows)

select count(*) from orca.foo x where x.x1 > (select count(*)+1 from orca.bar1 y where y.x1 = x.x2);
 count 
-------
     8
(1 row)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Result
                     Filter: (foo.x1 > ((COALESCE((count()), '0'::bigint) + 1)))
                     ->  Hash Left Join
                           Output: (COALESCE((count()), '0'::bigint) + 1), foo.x1
                           Hash Cond: (foo.x2 = bar1.x1)
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: foo.x1, foo.x2
                                 Hash Key: foo.x2
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.x1, foo.x2
                           ->  Hash
                                 Output: (count()), bar1.x1
                                 ->  GroupAggregate
                                       Output: count(), bar1.x1
                                       Group Key: bar1.x1
                                       ->  Sort
                                             Output: bar1.x1
                                             Sort Key: bar1.x1
                                             ->  PX Hash 6:6  (slice3; segments: 6)
                                                   Output: bar1.x1
                                                   Hash Key: bar1.x1
                                                   ->  Partial Seq Scan on orca.bar1
                                                         Output: bar1.x1
 Optimizer: PolarDB PX Optimizer
(30 rows)

-- result node with one time filter and filter
explain (costs off) select case when bar1.x2 = bar2.x2 then coalesce((select 1 from orca.foo where bar1.x2 = bar2.x2 and bar1.x2 = random() and foo.x2 = bar2.x2),0) else 1 end as col1, bar1.x1
from orca.bar1 inner join orca.bar2 on (bar1.x2 = bar2.x2) order by bar1.x1; 
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort
   Sort Key: bar1.x1
   ->  Hash Join
         Hash Cond: (bar2.x2 = bar1.x2)
         ->  Seq Scan on bar2
         ->  Hash
               ->  Seq Scan on bar1
         SubPlan 1
           ->  Result
                 One-Time Filter: (bar1.x2 = bar2.x2)
                 ->  Seq Scan on foo
                       Filter: ((x2 = bar2.x2) AND ((bar1.x2)::double precision = random()))
(12 rows)

select case when bar1.x2 = bar2.x2 then coalesce((select 1 from orca.foo where bar1.x2 = bar2.x2 and bar1.x2 = random() and foo.x2 = bar2.x2),0) else 1 end as col1, bar1.x1
from orca.bar1 inner join orca.bar2 on (bar1.x2 = bar2.x2) order by bar1.x1; 
 col1 | x1 
------+----
    0 |  1
    0 |  2
    0 |  3
    0 |  4
    0 |  5
    0 |  6
    0 |  7
    0 |  8
    0 |  9
    0 | 10
    0 | 11
    0 | 12
    0 | 13
    0 | 14
    0 | 15
    0 | 16
    0 | 17
    0 | 18
    0 | 19
    0 | 20
(20 rows)

                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (CASE WHEN (bar1.x2 = bar2.x2) THEN COALESCE((SubPlan 1), 0) ELSE 1 END), bar1.x1
   Merge Key: bar1.x1
   ->  Result
         Output: CASE WHEN (bar1.x2 = bar2.x2) THEN COALESCE((SubPlan 1), 0) ELSE 1 END, bar1.x1
         ->  Sort
               Output: bar1.x1, bar1.x2, bar2.x2
               Sort Key: bar1.x1
               ->  Hash Join
                     Output: bar1.x1, bar1.x2, bar2.x2
                     Hash Cond: (bar1.x2 = bar2.x2)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: bar1.x1, bar1.x2
                           Hash Key: bar1.x2
                           ->  Partial Seq Scan on orca.bar1
                                 Output: bar1.x1, bar1.x2
                     ->  Hash
                           Output: bar2.x2
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: bar2.x2
                                 Hash Key: bar2.x2
                                 ->  Partial Seq Scan on orca.bar2
                                       Output: bar2.x2
         SubPlan 1
           ->  Full Seq Scan on orca.foo
                 Output: 1
                 Filter: ((bar1.x2 = bar2.x2) AND ((bar1.x2)::double precision = random()) AND (foo.x2 = bar2.x2))
 Optimizer: PolarDB PX Optimizer
(28 rows)

drop table orca.r cascade;
create table orca.r(a int, b int) ;
create unique index r_a on orca.r(a);
create index r_b on orca.r(b);
insert into orca.r select i, i%3 from generate_series(1,20) i;
drop table orca.s;
create table orca.s(c int, d int) ;
insert into orca.s select i%7, i%2 from generate_series(1,30) i;
analyze orca.r;
analyze orca.s;
select * from orca.r, orca.s where r.a=s.c;
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 1
 2 | 2 | 2 | 0
 3 | 0 | 3 | 1
 4 | 1 | 4 | 0
 5 | 2 | 5 | 1
 6 | 0 | 6 | 0
 1 | 1 | 1 | 0
 2 | 2 | 2 | 1
 3 | 0 | 3 | 0
 4 | 1 | 4 | 1
 5 | 2 | 5 | 0
 6 | 0 | 6 | 1
 1 | 1 | 1 | 1
 2 | 2 | 2 | 0
 3 | 0 | 3 | 1
 4 | 1 | 4 | 0
 5 | 2 | 5 | 1
 6 | 0 | 6 | 0
 1 | 1 | 1 | 0
 2 | 2 | 2 | 1
 3 | 0 | 3 | 0
 4 | 1 | 4 | 1
 5 | 2 | 5 | 0
 6 | 0 | 6 | 1
 1 | 1 | 1 | 1
 2 | 2 | 2 | 0
(26 rows)

                     QUERY PLAN                     
----------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   ->  Nested Loop
         Output: r.a, r.b, s.c, s.d
         Join Filter: true
         ->  Full Seq Scan on orca.s
               Output: s.c, s.d
         ->  Partial Index Scan using r_a on orca.r
               Output: r.a, r.b
               Index Cond: (r.a = s.c)
 Optimizer: PolarDB PX Optimizer
(11 rows)

-- Materialize node
select * from orca.r, orca.s where r.a<s.c+1 or r.a>s.c;
 a  | b | c | d 
----+---+---+---
  1 | 1 | 1 | 1
  2 | 2 | 1 | 1
  3 | 0 | 1 | 1
  4 | 1 | 1 | 1
  5 | 2 | 1 | 1
  6 | 0 | 1 | 1
  7 | 1 | 1 | 1
  8 | 2 | 1 | 1
  9 | 0 | 1 | 1
 10 | 1 | 1 | 1
 11 | 2 | 1 | 1
 12 | 0 | 1 | 1
 13 | 1 | 1 | 1
 14 | 2 | 1 | 1
 15 | 0 | 1 | 1
 16 | 1 | 1 | 1
 17 | 2 | 1 | 1
 18 | 0 | 1 | 1
 19 | 1 | 1 | 1
 20 | 2 | 1 | 1
  1 | 1 | 2 | 0
  2 | 2 | 2 | 0
  3 | 0 | 2 | 0
  4 | 1 | 2 | 0
  5 | 2 | 2 | 0
  6 | 0 | 2 | 0
  7 | 1 | 2 | 0
  8 | 2 | 2 | 0
  9 | 0 | 2 | 0
 10 | 1 | 2 | 0
 11 | 2 | 2 | 0
 12 | 0 | 2 | 0
 13 | 1 | 2 | 0
 14 | 2 | 2 | 0
 15 | 0 | 2 | 0
 16 | 1 | 2 | 0
 17 | 2 | 2 | 0
 18 | 0 | 2 | 0
 19 | 1 | 2 | 0
 20 | 2 | 2 | 0
  1 | 1 | 3 | 1
  2 | 2 | 3 | 1
  3 | 0 | 3 | 1
  4 | 1 | 3 | 1
  5 | 2 | 3 | 1
  6 | 0 | 3 | 1
  7 | 1 | 3 | 1
  8 | 2 | 3 | 1
  9 | 0 | 3 | 1
 10 | 1 | 3 | 1
 11 | 2 | 3 | 1
 12 | 0 | 3 | 1
 13 | 1 | 3 | 1
 14 | 2 | 3 | 1
 15 | 0 | 3 | 1
 16 | 1 | 3 | 1
 17 | 2 | 3 | 1
 18 | 0 | 3 | 1
 19 | 1 | 3 | 1
 20 | 2 | 3 | 1
  1 | 1 | 4 | 0
  2 | 2 | 4 | 0
  3 | 0 | 4 | 0
  4 | 1 | 4 | 0
  5 | 2 | 4 | 0
  6 | 0 | 4 | 0
  7 | 1 | 4 | 0
  8 | 2 | 4 | 0
  9 | 0 | 4 | 0
 10 | 1 | 4 | 0
 11 | 2 | 4 | 0
 12 | 0 | 4 | 0
 13 | 1 | 4 | 0
 14 | 2 | 4 | 0
 15 | 0 | 4 | 0
 16 | 1 | 4 | 0
 17 | 2 | 4 | 0
 18 | 0 | 4 | 0
 19 | 1 | 4 | 0
 20 | 2 | 4 | 0
  1 | 1 | 5 | 1
  2 | 2 | 5 | 1
  3 | 0 | 5 | 1
  4 | 1 | 5 | 1
  5 | 2 | 5 | 1
  6 | 0 | 5 | 1
  7 | 1 | 5 | 1
  8 | 2 | 5 | 1
  9 | 0 | 5 | 1
 10 | 1 | 5 | 1
 11 | 2 | 5 | 1
 12 | 0 | 5 | 1
 13 | 1 | 5 | 1
 14 | 2 | 5 | 1
 15 | 0 | 5 | 1
 16 | 1 | 5 | 1
 17 | 2 | 5 | 1
 18 | 0 | 5 | 1
 19 | 1 | 5 | 1
 20 | 2 | 5 | 1
  1 | 1 | 6 | 0
  2 | 2 | 6 | 0
  3 | 0 | 6 | 0
  4 | 1 | 6 | 0
  5 | 2 | 6 | 0
  6 | 0 | 6 | 0
  7 | 1 | 6 | 0
  8 | 2 | 6 | 0
  9 | 0 | 6 | 0
 10 | 1 | 6 | 0
 11 | 2 | 6 | 0
 12 | 0 | 6 | 0
 13 | 1 | 6 | 0
 14 | 2 | 6 | 0
 15 | 0 | 6 | 0
 16 | 1 | 6 | 0
 17 | 2 | 6 | 0
 18 | 0 | 6 | 0
 19 | 1 | 6 | 0
 20 | 2 | 6 | 0
  1 | 1 | 0 | 1
  2 | 2 | 0 | 1
  3 | 0 | 0 | 1
  4 | 1 | 0 | 1
  5 | 2 | 0 | 1
  6 | 0 | 0 | 1
  7 | 1 | 0 | 1
  8 | 2 | 0 | 1
  9 | 0 | 0 | 1
 10 | 1 | 0 | 1
 11 | 2 | 0 | 1
 12 | 0 | 0 | 1
 13 | 1 | 0 | 1
 14 | 2 | 0 | 1
 15 | 0 | 0 | 1
 16 | 1 | 0 | 1
 17 | 2 | 0 | 1
 18 | 0 | 0 | 1
 19 | 1 | 0 | 1
 20 | 2 | 0 | 1
  1 | 1 | 1 | 0
  2 | 2 | 1 | 0
  3 | 0 | 1 | 0
  4 | 1 | 1 | 0
  5 | 2 | 1 | 0
  6 | 0 | 1 | 0
  7 | 1 | 1 | 0
  8 | 2 | 1 | 0
  9 | 0 | 1 | 0
 10 | 1 | 1 | 0
 11 | 2 | 1 | 0
 12 | 0 | 1 | 0
 13 | 1 | 1 | 0
 14 | 2 | 1 | 0
 15 | 0 | 1 | 0
 16 | 1 | 1 | 0
 17 | 2 | 1 | 0
 18 | 0 | 1 | 0
 19 | 1 | 1 | 0
 20 | 2 | 1 | 0
  1 | 1 | 2 | 1
  2 | 2 | 2 | 1
  3 | 0 | 2 | 1
  4 | 1 | 2 | 1
  5 | 2 | 2 | 1
  6 | 0 | 2 | 1
  7 | 1 | 2 | 1
  8 | 2 | 2 | 1
  9 | 0 | 2 | 1
 10 | 1 | 2 | 1
 11 | 2 | 2 | 1
 12 | 0 | 2 | 1
 13 | 1 | 2 | 1
 14 | 2 | 2 | 1
 15 | 0 | 2 | 1
 16 | 1 | 2 | 1
 17 | 2 | 2 | 1
 18 | 0 | 2 | 1
 19 | 1 | 2 | 1
 20 | 2 | 2 | 1
  1 | 1 | 3 | 0
  2 | 2 | 3 | 0
  3 | 0 | 3 | 0
  4 | 1 | 3 | 0
  5 | 2 | 3 | 0
  6 | 0 | 3 | 0
  7 | 1 | 3 | 0
  8 | 2 | 3 | 0
  9 | 0 | 3 | 0
 10 | 1 | 3 | 0
 11 | 2 | 3 | 0
 12 | 0 | 3 | 0
 13 | 1 | 3 | 0
 14 | 2 | 3 | 0
 15 | 0 | 3 | 0
 16 | 1 | 3 | 0
 17 | 2 | 3 | 0
 18 | 0 | 3 | 0
 19 | 1 | 3 | 0
 20 | 2 | 3 | 0
  1 | 1 | 4 | 1
  2 | 2 | 4 | 1
  3 | 0 | 4 | 1
  4 | 1 | 4 | 1
  5 | 2 | 4 | 1
  6 | 0 | 4 | 1
  7 | 1 | 4 | 1
  8 | 2 | 4 | 1
  9 | 0 | 4 | 1
 10 | 1 | 4 | 1
 11 | 2 | 4 | 1
 12 | 0 | 4 | 1
 13 | 1 | 4 | 1
 14 | 2 | 4 | 1
 15 | 0 | 4 | 1
 16 | 1 | 4 | 1
 17 | 2 | 4 | 1
 18 | 0 | 4 | 1
 19 | 1 | 4 | 1
 20 | 2 | 4 | 1
  1 | 1 | 5 | 0
  2 | 2 | 5 | 0
  3 | 0 | 5 | 0
  4 | 1 | 5 | 0
  5 | 2 | 5 | 0
  6 | 0 | 5 | 0
  7 | 1 | 5 | 0
  8 | 2 | 5 | 0
  9 | 0 | 5 | 0
 10 | 1 | 5 | 0
 11 | 2 | 5 | 0
 12 | 0 | 5 | 0
 13 | 1 | 5 | 0
 14 | 2 | 5 | 0
 15 | 0 | 5 | 0
 16 | 1 | 5 | 0
 17 | 2 | 5 | 0
 18 | 0 | 5 | 0
 19 | 1 | 5 | 0
 20 | 2 | 5 | 0
  1 | 1 | 6 | 1
  2 | 2 | 6 | 1
  3 | 0 | 6 | 1
  4 | 1 | 6 | 1
  5 | 2 | 6 | 1
  6 | 0 | 6 | 1
  7 | 1 | 6 | 1
  8 | 2 | 6 | 1
  9 | 0 | 6 | 1
 10 | 1 | 6 | 1
 11 | 2 | 6 | 1
 12 | 0 | 6 | 1
 13 | 1 | 6 | 1
 14 | 2 | 6 | 1
 15 | 0 | 6 | 1
 16 | 1 | 6 | 1
 17 | 2 | 6 | 1
 18 | 0 | 6 | 1
 19 | 1 | 6 | 1
 20 | 2 | 6 | 1
  1 | 1 | 0 | 0
  2 | 2 | 0 | 0
  3 | 0 | 0 | 0
  4 | 1 | 0 | 0
  5 | 2 | 0 | 0
  6 | 0 | 0 | 0
  7 | 1 | 0 | 0
  8 | 2 | 0 | 0
  9 | 0 | 0 | 0
 10 | 1 | 0 | 0
 11 | 2 | 0 | 0
 12 | 0 | 0 | 0
 13 | 1 | 0 | 0
 14 | 2 | 0 | 0
 15 | 0 | 0 | 0
 16 | 1 | 0 | 0
 17 | 2 | 0 | 0
 18 | 0 | 0 | 0
 19 | 1 | 0 | 0
 20 | 2 | 0 | 0
  1 | 1 | 1 | 1
  2 | 2 | 1 | 1
  3 | 0 | 1 | 1
  4 | 1 | 1 | 1
  5 | 2 | 1 | 1
  6 | 0 | 1 | 1
  7 | 1 | 1 | 1
  8 | 2 | 1 | 1
  9 | 0 | 1 | 1
 10 | 1 | 1 | 1
 11 | 2 | 1 | 1
 12 | 0 | 1 | 1
 13 | 1 | 1 | 1
 14 | 2 | 1 | 1
 15 | 0 | 1 | 1
 16 | 1 | 1 | 1
 17 | 2 | 1 | 1
 18 | 0 | 1 | 1
 19 | 1 | 1 | 1
 20 | 2 | 1 | 1
  1 | 1 | 2 | 0
  2 | 2 | 2 | 0
  3 | 0 | 2 | 0
  4 | 1 | 2 | 0
  5 | 2 | 2 | 0
  6 | 0 | 2 | 0
  7 | 1 | 2 | 0
  8 | 2 | 2 | 0
  9 | 0 | 2 | 0
 10 | 1 | 2 | 0
 11 | 2 | 2 | 0
 12 | 0 | 2 | 0
 13 | 1 | 2 | 0
 14 | 2 | 2 | 0
 15 | 0 | 2 | 0
 16 | 1 | 2 | 0
 17 | 2 | 2 | 0
 18 | 0 | 2 | 0
 19 | 1 | 2 | 0
 20 | 2 | 2 | 0
  1 | 1 | 3 | 1
  2 | 2 | 3 | 1
  3 | 0 | 3 | 1
  4 | 1 | 3 | 1
  5 | 2 | 3 | 1
  6 | 0 | 3 | 1
  7 | 1 | 3 | 1
  8 | 2 | 3 | 1
  9 | 0 | 3 | 1
 10 | 1 | 3 | 1
 11 | 2 | 3 | 1
 12 | 0 | 3 | 1
 13 | 1 | 3 | 1
 14 | 2 | 3 | 1
 15 | 0 | 3 | 1
 16 | 1 | 3 | 1
 17 | 2 | 3 | 1
 18 | 0 | 3 | 1
 19 | 1 | 3 | 1
 20 | 2 | 3 | 1
  1 | 1 | 4 | 0
  2 | 2 | 4 | 0
  3 | 0 | 4 | 0
  4 | 1 | 4 | 0
  5 | 2 | 4 | 0
  6 | 0 | 4 | 0
  7 | 1 | 4 | 0
  8 | 2 | 4 | 0
  9 | 0 | 4 | 0
 10 | 1 | 4 | 0
 11 | 2 | 4 | 0
 12 | 0 | 4 | 0
 13 | 1 | 4 | 0
 14 | 2 | 4 | 0
 15 | 0 | 4 | 0
 16 | 1 | 4 | 0
 17 | 2 | 4 | 0
 18 | 0 | 4 | 0
 19 | 1 | 4 | 0
 20 | 2 | 4 | 0
  1 | 1 | 5 | 1
  2 | 2 | 5 | 1
  3 | 0 | 5 | 1
  4 | 1 | 5 | 1
  5 | 2 | 5 | 1
  6 | 0 | 5 | 1
  7 | 1 | 5 | 1
  8 | 2 | 5 | 1
  9 | 0 | 5 | 1
 10 | 1 | 5 | 1
 11 | 2 | 5 | 1
 12 | 0 | 5 | 1
 13 | 1 | 5 | 1
 14 | 2 | 5 | 1
 15 | 0 | 5 | 1
 16 | 1 | 5 | 1
 17 | 2 | 5 | 1
 18 | 0 | 5 | 1
 19 | 1 | 5 | 1
 20 | 2 | 5 | 1
  1 | 1 | 6 | 0
  2 | 2 | 6 | 0
  3 | 0 | 6 | 0
  4 | 1 | 6 | 0
  5 | 2 | 6 | 0
  6 | 0 | 6 | 0
  7 | 1 | 6 | 0
  8 | 2 | 6 | 0
  9 | 0 | 6 | 0
 10 | 1 | 6 | 0
 11 | 2 | 6 | 0
 12 | 0 | 6 | 0
 13 | 1 | 6 | 0
 14 | 2 | 6 | 0
 15 | 0 | 6 | 0
 16 | 1 | 6 | 0
 17 | 2 | 6 | 0
 18 | 0 | 6 | 0
 19 | 1 | 6 | 0
 20 | 2 | 6 | 0
  1 | 1 | 0 | 1
  2 | 2 | 0 | 1
  3 | 0 | 0 | 1
  4 | 1 | 0 | 1
  5 | 2 | 0 | 1
  6 | 0 | 0 | 1
  7 | 1 | 0 | 1
  8 | 2 | 0 | 1
  9 | 0 | 0 | 1
 10 | 1 | 0 | 1
 11 | 2 | 0 | 1
 12 | 0 | 0 | 1
 13 | 1 | 0 | 1
 14 | 2 | 0 | 1
 15 | 0 | 0 | 1
 16 | 1 | 0 | 1
 17 | 2 | 0 | 1
 18 | 0 | 0 | 1
 19 | 1 | 0 | 1
 20 | 2 | 0 | 1
  1 | 1 | 1 | 0
  2 | 2 | 1 | 0
  3 | 0 | 1 | 0
  4 | 1 | 1 | 0
  5 | 2 | 1 | 0
  6 | 0 | 1 | 0
  7 | 1 | 1 | 0
  8 | 2 | 1 | 0
  9 | 0 | 1 | 0
 10 | 1 | 1 | 0
 11 | 2 | 1 | 0
 12 | 0 | 1 | 0
 13 | 1 | 1 | 0
 14 | 2 | 1 | 0
 15 | 0 | 1 | 0
 16 | 1 | 1 | 0
 17 | 2 | 1 | 0
 18 | 0 | 1 | 0
 19 | 1 | 1 | 0
 20 | 2 | 1 | 0
  1 | 1 | 2 | 1
  2 | 2 | 2 | 1
  3 | 0 | 2 | 1
  4 | 1 | 2 | 1
  5 | 2 | 2 | 1
  6 | 0 | 2 | 1
  7 | 1 | 2 | 1
  8 | 2 | 2 | 1
  9 | 0 | 2 | 1
 10 | 1 | 2 | 1
 11 | 2 | 2 | 1
 12 | 0 | 2 | 1
 13 | 1 | 2 | 1
 14 | 2 | 2 | 1
 15 | 0 | 2 | 1
 16 | 1 | 2 | 1
 17 | 2 | 2 | 1
 18 | 0 | 2 | 1
 19 | 1 | 2 | 1
 20 | 2 | 2 | 1
  1 | 1 | 3 | 0
  2 | 2 | 3 | 0
  3 | 0 | 3 | 0
  4 | 1 | 3 | 0
  5 | 2 | 3 | 0
  6 | 0 | 3 | 0
  7 | 1 | 3 | 0
  8 | 2 | 3 | 0
  9 | 0 | 3 | 0
 10 | 1 | 3 | 0
 11 | 2 | 3 | 0
 12 | 0 | 3 | 0
 13 | 1 | 3 | 0
 14 | 2 | 3 | 0
 15 | 0 | 3 | 0
 16 | 1 | 3 | 0
 17 | 2 | 3 | 0
 18 | 0 | 3 | 0
 19 | 1 | 3 | 0
 20 | 2 | 3 | 0
  1 | 1 | 4 | 1
  2 | 2 | 4 | 1
  3 | 0 | 4 | 1
  4 | 1 | 4 | 1
  5 | 2 | 4 | 1
  6 | 0 | 4 | 1
  7 | 1 | 4 | 1
  8 | 2 | 4 | 1
  9 | 0 | 4 | 1
 10 | 1 | 4 | 1
 11 | 2 | 4 | 1
 12 | 0 | 4 | 1
 13 | 1 | 4 | 1
 14 | 2 | 4 | 1
 15 | 0 | 4 | 1
 16 | 1 | 4 | 1
 17 | 2 | 4 | 1
 18 | 0 | 4 | 1
 19 | 1 | 4 | 1
 20 | 2 | 4 | 1
  1 | 1 | 5 | 0
  2 | 2 | 5 | 0
  3 | 0 | 5 | 0
  4 | 1 | 5 | 0
  5 | 2 | 5 | 0
  6 | 0 | 5 | 0
  7 | 1 | 5 | 0
  8 | 2 | 5 | 0
  9 | 0 | 5 | 0
 10 | 1 | 5 | 0
 11 | 2 | 5 | 0
 12 | 0 | 5 | 0
 13 | 1 | 5 | 0
 14 | 2 | 5 | 0
 15 | 0 | 5 | 0
 16 | 1 | 5 | 0
 17 | 2 | 5 | 0
 18 | 0 | 5 | 0
 19 | 1 | 5 | 0
 20 | 2 | 5 | 0
  1 | 1 | 6 | 1
  2 | 2 | 6 | 1
  3 | 0 | 6 | 1
  4 | 1 | 6 | 1
  5 | 2 | 6 | 1
  6 | 0 | 6 | 1
  7 | 1 | 6 | 1
  8 | 2 | 6 | 1
  9 | 0 | 6 | 1
 10 | 1 | 6 | 1
 11 | 2 | 6 | 1
 12 | 0 | 6 | 1
 13 | 1 | 6 | 1
 14 | 2 | 6 | 1
 15 | 0 | 6 | 1
 16 | 1 | 6 | 1
 17 | 2 | 6 | 1
 18 | 0 | 6 | 1
 19 | 1 | 6 | 1
 20 | 2 | 6 | 1
  1 | 1 | 0 | 0
  2 | 2 | 0 | 0
  3 | 0 | 0 | 0
  4 | 1 | 0 | 0
  5 | 2 | 0 | 0
  6 | 0 | 0 | 0
  7 | 1 | 0 | 0
  8 | 2 | 0 | 0
  9 | 0 | 0 | 0
 10 | 1 | 0 | 0
 11 | 2 | 0 | 0
 12 | 0 | 0 | 0
 13 | 1 | 0 | 0
 14 | 2 | 0 | 0
 15 | 0 | 0 | 0
 16 | 1 | 0 | 0
 17 | 2 | 0 | 0
 18 | 0 | 0 | 0
 19 | 1 | 0 | 0
 20 | 2 | 0 | 0
  1 | 1 | 1 | 1
  2 | 2 | 1 | 1
  3 | 0 | 1 | 1
  4 | 1 | 1 | 1
  5 | 2 | 1 | 1
  6 | 0 | 1 | 1
  7 | 1 | 1 | 1
  8 | 2 | 1 | 1
  9 | 0 | 1 | 1
 10 | 1 | 1 | 1
 11 | 2 | 1 | 1
 12 | 0 | 1 | 1
 13 | 1 | 1 | 1
 14 | 2 | 1 | 1
 15 | 0 | 1 | 1
 16 | 1 | 1 | 1
 17 | 2 | 1 | 1
 18 | 0 | 1 | 1
 19 | 1 | 1 | 1
 20 | 2 | 1 | 1
  1 | 1 | 2 | 0
  2 | 2 | 2 | 0
  3 | 0 | 2 | 0
  4 | 1 | 2 | 0
  5 | 2 | 2 | 0
  6 | 0 | 2 | 0
  7 | 1 | 2 | 0
  8 | 2 | 2 | 0
  9 | 0 | 2 | 0
 10 | 1 | 2 | 0
 11 | 2 | 2 | 0
 12 | 0 | 2 | 0
 13 | 1 | 2 | 0
 14 | 2 | 2 | 0
 15 | 0 | 2 | 0
 16 | 1 | 2 | 0
 17 | 2 | 2 | 0
 18 | 0 | 2 | 0
 19 | 1 | 2 | 0
 20 | 2 | 2 | 0
(600 rows)

                           QUERY PLAN                           
----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   ->  Nested Loop
         Output: r.a, r.b, s.c, s.d
         Join Filter: true
         ->  Full Seq Scan on orca.s
               Output: s.c, s.d
         ->  Partial Bitmap Heap Scan on orca.r
               Output: r.a, r.b
               Recheck Cond: ((r.a < (s.c + 1)) OR (r.a > s.c))
               ->  BitmapOr
                     ->  Partial Bitmap Index Scan on r_a
                           Index Cond: (r.a < (s.c + 1))
                     ->  Partial Bitmap Index Scan on r_a
                           Index Cond: (r.a > s.c)
 Optimizer: PolarDB PX Optimizer
(16 rows)

-- empty target list
select r.* from orca.r, orca.s where s.c=2;
 a  | b 
----+---
  1 | 1
  1 | 1
  1 | 1
  1 | 1
  1 | 1
  2 | 2
  2 | 2
  2 | 2
  2 | 2
  2 | 2
  3 | 0
  3 | 0
  3 | 0
  3 | 0
  3 | 0
  4 | 1
  4 | 1
  4 | 1
  4 | 1
  4 | 1
  5 | 2
  5 | 2
  5 | 2
  5 | 2
  5 | 2
  6 | 0
  6 | 0
  6 | 0
  6 | 0
  6 | 0
  7 | 1
  7 | 1
  7 | 1
  7 | 1
  7 | 1
  8 | 2
  8 | 2
  8 | 2
  8 | 2
  8 | 2
  9 | 0
  9 | 0
  9 | 0
  9 | 0
  9 | 0
 10 | 1
 10 | 1
 10 | 1
 10 | 1
 10 | 1
 11 | 2
 11 | 2
 11 | 2
 11 | 2
 11 | 2
 12 | 0
 12 | 0
 12 | 0
 12 | 0
 12 | 0
 13 | 1
 13 | 1
 13 | 1
 13 | 1
 13 | 1
 14 | 2
 14 | 2
 14 | 2
 14 | 2
 14 | 2
 15 | 0
 15 | 0
 15 | 0
 15 | 0
 15 | 0
 16 | 1
 16 | 1
 16 | 1
 16 | 1
 16 | 1
 17 | 2
 17 | 2
 17 | 2
 17 | 2
 17 | 2
 18 | 0
 18 | 0
 18 | 0
 18 | 0
 18 | 0
 19 | 1
 19 | 1
 19 | 1
 19 | 1
 19 | 1
 20 | 2
 20 | 2
 20 | 2
 20 | 2
 20 | 2
(100 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b
   ->  Nested Loop
         Output: r.a, r.b
         Join Filter: true
         ->  Partial Seq Scan on orca.r
               Output: r.a, r.b
         ->  Materialize
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     ->  Partial Seq Scan on orca.s
                           Filter: (s.c = 2)
 Optimizer: PolarDB PX Optimizer
(12 rows)

create table orca.m();
alter table orca.m add column a int;
alter table orca.m add column b int;
create table orca.m1();
alter table orca.m1 add column a int;
alter table orca.m1 add column b int;
insert into orca.m select i-1, i%2 from generate_series(1,35) i;
insert into orca.m1 select i-2, i%3 from generate_series(1,25) i;
insert into orca.r values (null, 1);
-- join types
select r.a, s.c from orca.r left outer join orca.s on(r.a=s.c);
 a  | c 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 5
  6 | 6
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 5
  6 | 6
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 5
  6 | 6
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 5
  6 | 6
  1 | 1
  2 | 2
    |  
 20 |  
 11 |  
 17 |  
 12 |  
 10 |  
 18 |  
 15 |  
 13 |  
 19 |  
  8 |  
 16 |  
 14 |  
  9 |  
  7 |  
(41 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, s.c
   ->  Hash Left Join
         Output: r.a, s.c
         Hash Cond: (r.a = s.c)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: r.a
               Hash Key: r.a
               ->  Partial Seq Scan on orca.r
                     Output: r.a
         ->  Hash
               Output: s.c
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: s.c
                     Hash Key: s.c
                     ->  Partial Seq Scan on orca.s
                           Output: s.c
 Optimizer: PolarDB PX Optimizer
(18 rows)

select r.a, s.c from orca.r left outer join orca.s on(r.a=s.c and r.a=r.b and s.c=s.d) order by r.a,s.c;
 a  | c 
----+---
  1 | 1
  1 | 1
  1 | 1
  2 |  
  3 |  
  4 |  
  5 |  
  6 |  
  7 |  
  8 |  
  9 |  
 10 |  
 11 |  
 12 |  
 13 |  
 14 |  
 15 |  
 16 |  
 17 |  
 18 |  
 19 |  
 20 |  
    |  
(23 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, s.c
   Merge Key: r.a, s.c
   ->  Sort
         Output: r.a, s.c
         Sort Key: r.a, s.c
         ->  Hash Left Join
               Output: r.a, s.c
               Hash Cond: (r.a = s.c)
               Join Filter: (r.a = r.b)
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: r.a, r.b
                     Hash Key: r.a
                     ->  Partial Seq Scan on orca.r
                           Output: r.a, r.b
               ->  Hash
                     Output: s.c
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: s.c
                           Hash Key: s.c
                           ->  Partial Seq Scan on orca.s
                                 Output: s.c
                                 Filter: (s.c = s.d)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select r.a, s.c from orca.r left outer join orca.s on(r.a=s.c) where s.d > 2 or s.d is null order by r.a;
 a  | c 
----+---
  7 |  
  8 |  
  9 |  
 10 |  
 11 |  
 12 |  
 13 |  
 14 |  
 15 |  
 16 |  
 17 |  
 18 |  
 19 |  
 20 |  
    |  
(15 rows)

                            QUERY PLAN                            
------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, s.c
   Merge Key: r.a
   ->  Sort
         Output: r.a, s.c
         Sort Key: r.a
         ->  Result
               Output: r.a, s.c
               Filter: ((s.d > 2) OR (s.d IS NULL))
               ->  Hash Left Join
                     Output: r.a, s.c, s.d
                     Hash Cond: (r.a = s.c)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: r.a
                           Hash Key: r.a
                           ->  Partial Seq Scan on orca.r
                                 Output: r.a
                     ->  Hash
                           Output: s.c, s.d
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: s.c, s.d
                                 Hash Key: s.c
                                 ->  Partial Seq Scan on orca.s
                                       Output: s.c, s.d
 Optimizer: PolarDB PX Optimizer
(25 rows)

select r.a, s.c from orca.r right outer join orca.s on(r.a=s.c);
 a | c 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
 5 | 5
 6 | 6
   | 0
 1 | 1
 2 | 2
 3 | 3
 4 | 4
 5 | 5
 6 | 6
   | 0
 1 | 1
 2 | 2
 3 | 3
 4 | 4
 5 | 5
 6 | 6
   | 0
 1 | 1
 2 | 2
 3 | 3
 4 | 4
 5 | 5
 6 | 6
   | 0
 1 | 1
 2 | 2
(30 rows)

                   QUERY PLAN                    
-------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, s.c
   ->  Nested Loop Left Join
         Output: r.a, s.c
         Join Filter: true
         ->  Partial Seq Scan on orca.s
               Output: s.c
         ->  Full Index Scan using r_a on orca.r
               Output: r.a
               Index Cond: (r.a = s.c)
 Optimizer: PolarDB PX Optimizer
(11 rows)

select * from orca.r where exists (select * from orca.s where s.c=r.a + 2);
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 0
 4 | 1
(4 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b
   ->  Hash Semi Join
         Output: r.a, r.b
         Hash Cond: ((r.a + 2) = s.c)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: r.a, r.b
               Hash Key: (r.a + 2)
               ->  Partial Seq Scan on orca.r
                     Output: r.a, r.b
         ->  Hash
               Output: s.c
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: s.c
                     Hash Key: s.c
                     ->  Partial Seq Scan on orca.s
                           Output: s.c
 Optimizer: PolarDB PX Optimizer
(18 rows)

select * from orca.r where exists (select * from orca.s where s.c=r.b);
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 0
  4 | 1
  5 | 2
  6 | 0
  7 | 1
  8 | 2
  9 | 0
 10 | 1
 11 | 2
 12 | 0
 13 | 1
 14 | 2
 15 | 0
 16 | 1
 17 | 2
 18 | 0
 19 | 1
 20 | 2
    | 1
(21 rows)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b
   ->  Nested Loop
         Output: r.a, r.b
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: s.c
               ->  GroupAggregate
                     Output: s.c
                     Group Key: s.c
                     ->  Sort
                           Output: s.c
                           Sort Key: s.c
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: s.c
                                 Hash Key: s.c
                                 ->  GroupAggregate
                                       Output: s.c
                                       Group Key: s.c
                                       ->  Sort
                                             Output: s.c
                                             Sort Key: s.c
                                             ->  Partial Seq Scan on orca.s
                                                   Output: s.c
         ->  Partial Index Scan using r_b on orca.r
               Output: r.a, r.b
               Index Cond: (r.b = s.c)
 Optimizer: PolarDB PX Optimizer
(28 rows)

select * from orca.m where m.a not in (select a from orca.m1 where a=5);
 a  | b 
----+---
  0 | 1
  1 | 0
  2 | 1
  3 | 0
  4 | 1
  6 | 1
  7 | 0
  8 | 1
  9 | 0
 10 | 1
 11 | 0
 12 | 1
 13 | 0
 14 | 1
 15 | 0
 16 | 1
 17 | 0
 18 | 1
 19 | 0
 20 | 1
 21 | 0
 22 | 1
 23 | 0
 24 | 1
 25 | 0
 26 | 1
 27 | 0
 28 | 1
 29 | 0
 30 | 1
 31 | 0
 32 | 1
 33 | 0
 34 | 1
(34 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: m.a, m.b
   ->  Hash Left Anti Semi (Not-In) Join
         Output: m.a, m.b
         Hash Cond: (m.a = m1.a)
         ->  Partial Seq Scan on orca.m
               Output: m.a, m.b
         ->  Hash
               Output: m1.a
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: m1.a
                     ->  Partial Seq Scan on orca.m1
                           Output: m1.a
                           Filter: (m1.a = 5)
 Optimizer: PolarDB PX Optimizer
(15 rows)

select * from orca.m where m.a not in (select a from orca.m1);
 a  | b 
----+---
 24 | 1
 25 | 0
 26 | 1
 27 | 0
 28 | 1
 29 | 0
 30 | 1
 31 | 0
 32 | 1
 33 | 0
 34 | 1
(11 rows)

                 QUERY PLAN                 
--------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: m.a, m.b
   ->  Hash Left Anti Semi (Not-In) Join
         Output: m.a, m.b
         Hash Cond: (m.a = m1.a)
         ->  Partial Seq Scan on orca.m
               Output: m.a, m.b
         ->  Hash
               Output: m1.a
               ->  Full Seq Scan on orca.m1
                     Output: m1.a
 Optimizer: PolarDB PX Optimizer
(12 rows)

select * from orca.m where m.a in (select a from orca.m1 where m1.a-1 = m.b);
 a | b 
---+---
 1 | 0
 2 | 1
(2 rows)

                        QUERY PLAN                        
----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: m.a, m.b
   ->  Hash Semi Join
         Output: m.a, m.b
         Hash Cond: ((m.b = (m1.a - 1)) AND (m.a = m1.a))
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: m.a, m.b
               Hash Key: m.b, m.a
               ->  Partial Seq Scan on orca.m
                     Output: m.a, m.b
         ->  Hash
               Output: m1.a
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: m1.a
                     Hash Key: (m1.a - 1), m1.a
                     ->  Partial Seq Scan on orca.m1
                           Output: m1.a
 Optimizer: PolarDB PX Optimizer
(18 rows)

-- enable_hashjoin=off; enable_mergejoin=on
select 1 from orca.m, orca.m1 where m.a = m1.a and m.b!=m1.b;
 ?column? 
----------
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
(16 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 Result
   Output: 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Hash Join
               Hash Cond: (m.a = m1.a)
               Join Filter: (m.b <> m1.b)
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: m.a, m.b
                     Hash Key: m.a
                     ->  Partial Seq Scan on orca.m
                           Output: m.a, m.b
               ->  Hash
                     Output: m1.a, m1.b
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: m1.a, m1.b
                           Hash Key: m1.a
                           ->  Partial Seq Scan on orca.m1
                                 Output: m1.a, m1.b
 Optimizer: PolarDB PX Optimizer
(19 rows)

-- plan.qual vs hashclauses/join quals:
select * from orca.r left outer join orca.s on (r.a=s.c and r.b<s.d) where s.d is null;
 a  | b | c | d 
----+---+---+---
  1 | 1 |   |  
  2 | 2 |   |  
  4 | 1 |   |  
  5 | 2 |   |  
  7 | 1 |   |  
  8 | 2 |   |  
  9 | 0 |   |  
 10 | 1 |   |  
 11 | 2 |   |  
 12 | 0 |   |  
 13 | 1 |   |  
 14 | 2 |   |  
 15 | 0 |   |  
 16 | 1 |   |  
 17 | 2 |   |  
 18 | 0 |   |  
 19 | 1 |   |  
 20 | 2 |   |  
    | 1 |   |  
(19 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   ->  Result
         Output: r.a, r.b, s.c, s.d
         Filter: (s.d IS NULL)
         ->  Hash Left Join
               Output: r.a, r.b, s.c, s.d
               Hash Cond: (r.a = s.c)
               Join Filter: (r.b < s.d)
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: r.a, r.b
                     Hash Key: r.a
                     ->  Partial Seq Scan on orca.r
                           Output: r.a, r.b
               ->  Hash
                     Output: s.c, s.d
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: s.c, s.d
                           Hash Key: s.c
                           ->  Partial Seq Scan on orca.s
                                 Output: s.c, s.d
 Optimizer: PolarDB PX Optimizer
(22 rows)

-- select * from orca.r m full outer join orca.r m1 on (m.a=m1.a) where m.a is null;
-- explain Hash Join with 'IS NOT DISTINCT FROM' join condition
-- force_explain
explain (costs off) select * from orca.r, orca.s where r.a is not distinct from s.c;
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop
   Join Filter: (NOT (r.a IS DISTINCT FROM s.c))
   ->  Seq Scan on s
   ->  Materialize
         ->  Seq Scan on r
(5 rows)

-- explain Hash Join with equality join condition
-- force_explain
explain (costs off) select * from orca.r, orca.s where r.a = s.c;
        QUERY PLAN         
---------------------------
 Hash Join
   Hash Cond: (s.c = r.a)
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on r
(5 rows)

-- sort
select * from orca.r join orca.s on(r.a=s.c) order by r.a, s.d;
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 0
 1 | 1 | 1 | 0
 1 | 1 | 1 | 1
 1 | 1 | 1 | 1
 1 | 1 | 1 | 1
 2 | 2 | 2 | 0
 2 | 2 | 2 | 0
 2 | 2 | 2 | 0
 2 | 2 | 2 | 1
 2 | 2 | 2 | 1
 3 | 0 | 3 | 0
 3 | 0 | 3 | 0
 3 | 0 | 3 | 1
 3 | 0 | 3 | 1
 4 | 1 | 4 | 0
 4 | 1 | 4 | 0
 4 | 1 | 4 | 1
 4 | 1 | 4 | 1
 5 | 2 | 5 | 0
 5 | 2 | 5 | 0
 5 | 2 | 5 | 1
 5 | 2 | 5 | 1
 6 | 0 | 6 | 0
 6 | 0 | 6 | 0
 6 | 0 | 6 | 1
 6 | 0 | 6 | 1
(26 rows)

                        QUERY PLAN                        
----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b, s.c, s.d
   Merge Key: r.a, s.d
   ->  Sort
         Output: r.a, r.b, s.c, s.d
         Sort Key: r.a, s.d
         ->  Nested Loop
               Output: r.a, r.b, s.c, s.d
               Join Filter: true
               ->  Full Seq Scan on orca.s
                     Output: s.c, s.d
               ->  Partial Index Scan using r_a on orca.r
                     Output: r.a, r.b
                     Index Cond: (r.a = s.c)
 Optimizer: PolarDB PX Optimizer
(15 rows)

select * from orca.r join orca.s on(r.a=s.c) order by r.a, s.d limit 10;
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 0
 1 | 1 | 1 | 0
 1 | 1 | 1 | 1
 1 | 1 | 1 | 1
 1 | 1 | 1 | 1
 2 | 2 | 2 | 0
 2 | 2 | 2 | 0
 2 | 2 | 2 | 0
 2 | 2 | 2 | 1
 2 | 2 | 2 | 1
(10 rows)

                              QUERY PLAN                              
----------------------------------------------------------------------
 Limit
   Output: r.a, r.b, s.c, s.d
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: r.a, r.b, s.c, s.d
         Merge Key: r.a, s.d
         ->  Limit
               Output: r.a, r.b, s.c, s.d
               ->  Sort
                     Output: r.a, r.b, s.c, s.d
                     Sort Key: r.a, s.d
                     ->  Nested Loop
                           Output: r.a, r.b, s.c, s.d
                           Join Filter: true
                           ->  Full Seq Scan on orca.s
                                 Output: s.c, s.d
                           ->  Partial Index Scan using r_a on orca.r
                                 Output: r.a, r.b
                                 Index Cond: (r.a = s.c)
 Optimizer: PolarDB PX Optimizer
(19 rows)

select * from orca.r join orca.s on(r.a=s.c) order by r.a + 5, s.d limit 10;
 a | b | c | d 
---+---+---+---
 1 | 1 | 1 | 0
 1 | 1 | 1 | 0
 1 | 1 | 1 | 1
 1 | 1 | 1 | 1
 1 | 1 | 1 | 1
 2 | 2 | 2 | 0
 2 | 2 | 2 | 0
 2 | 2 | 2 | 0
 2 | 2 | 2 | 1
 2 | 2 | 2 | 1
(10 rows)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Result
   Output: r.a, r.b, s.c, s.d
   ->  Limit
         Output: r.a, r.b, s.c, s.d, ((r.a + 5))
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: r.a, r.b, s.c, s.d, ((r.a + 5))
               Merge Key: ((r.a + 5)), s.d
               ->  Limit
                     Output: r.a, r.b, s.c, s.d, ((r.a + 5))
                     ->  Sort
                           Output: r.a, r.b, s.c, s.d, ((r.a + 5))
                           Sort Key: ((r.a + 5)), s.d
                           ->  Nested Loop
                                 Output: r.a, r.b, s.c, s.d, (r.a + 5)
                                 Join Filter: true
                                 ->  Full Seq Scan on orca.s
                                       Output: s.c, s.d
                                 ->  Partial Index Scan using r_a on orca.r
                                       Output: r.a, r.b
                                       Index Cond: (r.a = s.c)
 Optimizer: PolarDB PX Optimizer
(21 rows)

-- group by
select 1 from orca.m group by a+b;
 ?column? 
----------
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
(18 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 Result
   Output: 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  GroupAggregate
               Group Key: ((m.a + m.b))
               ->  Sort
                     Output: ((a + b))
                     Sort Key: ((m.a + m.b))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: ((a + b))
                           Hash Key: ((a + b))
                           ->  Partial Seq Scan on orca.m
                                 Output: (a + b)
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- join with const table
--select * from orca.r where a = (select 1);
-- union with const table
select * from ((select a as x from orca.r) union (select 1 as x )) as foo order by x;
 x  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
   
(21 rows)

insert into orca.m values (1,-1), (1,2), (1,1);
-- computed columns
select a,a,a+b from orca.m;
 a  | a  | ?column? 
----+----+----------
  0 |  0 |        1
  1 |  1 |        1
  2 |  2 |        3
  3 |  3 |        3
  4 |  4 |        5
  5 |  5 |        5
  6 |  6 |        7
  7 |  7 |        7
  8 |  8 |        9
  9 |  9 |        9
 10 | 10 |       11
 11 | 11 |       11
 12 | 12 |       13
 13 | 13 |       13
 14 | 14 |       15
 15 | 15 |       15
 16 | 16 |       17
 17 | 17 |       17
 18 | 18 |       19
 19 | 19 |       19
 20 | 20 |       21
 21 | 21 |       21
 22 | 22 |       23
 23 | 23 |       23
 24 | 24 |       25
 25 | 25 |       25
 26 | 26 |       27
 27 | 27 |       27
 28 | 28 |       29
 29 | 29 |       29
 30 | 30 |       31
 31 | 31 |       31
 32 | 32 |       33
 33 | 33 |       33
 34 | 34 |       35
  1 |  1 |        0
  1 |  1 |        3
  1 |  1 |        2
(38 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, a, ((a + b))
   ->  Partial Seq Scan on orca.m
         Output: a, a, (a + b)
 Optimizer: PolarDB PX Optimizer
(5 rows)

select a,a+b,a+b from orca.m;
 a  | ?column? | ?column? 
----+----------+----------
  0 |        1 |        1
  1 |        1 |        1
  2 |        3 |        3
  3 |        3 |        3
  4 |        5 |        5
  5 |        5 |        5
  6 |        7 |        7
  7 |        7 |        7
  8 |        9 |        9
  9 |        9 |        9
 10 |       11 |       11
 11 |       11 |       11
 12 |       13 |       13
 13 |       13 |       13
 14 |       15 |       15
 15 |       15 |       15
 16 |       17 |       17
 17 |       17 |       17
 18 |       19 |       19
 19 |       19 |       19
 20 |       21 |       21
 21 |       21 |       21
 22 |       23 |       23
 23 |       23 |       23
 24 |       25 |       25
 25 |       25 |       25
 26 |       27 |       27
 27 |       27 |       27
 28 |       29 |       29
 29 |       29 |       29
 30 |       31 |       31
 31 |       31 |       31
 32 |       33 |       33
 33 |       33 |       33
 34 |       35 |       35
  1 |        0 |        0
  1 |        3 |        3
  1 |        2 |        2
(38 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: a, (a + b), (a + b)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         ->  Partial Seq Scan on orca.m
               Output: a, b
 Optimizer: PolarDB PX Optimizer
(7 rows)

-- func expr
select * from orca.m where a=abs(b);
 a | b  
---+----
 1 | -1
 1 |  1
(2 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Seq Scan on orca.m
         Output: a, b
         Filter: (m.a = abs(m.b))
 Optimizer: PolarDB PX Optimizer
(6 rows)

-- grouping sets
select a,b,count(*) from orca.m group by grouping sets ((a), (a,b));
 a  | b  | count 
----+----+-------
 28 |  1 |     1
  1 |  1 |     1
 32 |  1 |     1
 11 |  0 |     1
 25 |  0 |     1
 34 |  1 |     1
 33 |  0 |     1
 14 |  1 |     1
 31 |  0 |     1
 15 |  0 |     1
 21 |  0 |     1
  1 | -1 |     1
 23 |  0 |     1
 16 |  1 |     1
  0 |  1 |     1
  2 |  1 |     1
  1 |  2 |     1
 10 |  1 |     1
  6 |  1 |     1
 24 |  1 |     1
  4 |  1 |     1
 12 |  1 |     1
  9 |  0 |     1
  7 |  0 |     1
 19 |  0 |     1
 27 |  0 |     1
 18 |  1 |     1
 22 |  1 |     1
  3 |  0 |     1
  5 |  0 |     1
 17 |  0 |     1
 13 |  0 |     1
  8 |  1 |     1
 30 |  1 |     1
 29 |  0 |     1
  1 |  0 |     1
 26 |  1 |     1
 20 |  1 |     1
 29 |    |     1
  4 |    |     1
 34 |    |     1
  0 |    |     1
 32 |    |     1
 10 |    |     1
  9 |    |     1
  7 |    |     1
 15 |    |     1
  6 |    |     1
 26 |    |     1
 12 |    |     1
 24 |    |     1
 19 |    |     1
 25 |    |     1
 31 |    |     1
 30 |    |     1
 21 |    |     1
 14 |    |     1
  3 |    |     1
 17 |    |     1
 28 |    |     1
 22 |    |     1
 20 |    |     1
 33 |    |     1
 13 |    |     1
  1 |    |     4
  5 |    |     1
 18 |    |     1
  2 |    |     1
 16 |    |     1
 27 |    |     1
 23 |    |     1
 11 |    |     1
  8 |    |     1
(73 rows)

select b,count(*) from orca.m group by grouping sets ((a), (a,b));
 b  | count 
----+-------
  1 |     1
  1 |     1
  1 |     1
  0 |     1
  0 |     1
  1 |     1
  0 |     1
  1 |     1
  0 |     1
  0 |     1
  0 |     1
 -1 |     1
  0 |     1
  1 |     1
  1 |     1
  1 |     1
  2 |     1
  1 |     1
  1 |     1
  1 |     1
  1 |     1
  1 |     1
  0 |     1
  0 |     1
  0 |     1
  0 |     1
  1 |     1
  1 |     1
  0 |     1
  0 |     1
  0 |     1
  0 |     1
  1 |     1
  1 |     1
  0 |     1
  0 |     1
  1 |     1
  1 |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     4
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
    |     1
(73 rows)

select a,count(*) from orca.m group by grouping sets ((a), (a,b));
 a  | count 
----+-------
 28 |     1
  1 |     1
 32 |     1
 11 |     1
 25 |     1
 34 |     1
 33 |     1
 14 |     1
 31 |     1
 15 |     1
 21 |     1
  1 |     1
 23 |     1
 16 |     1
  0 |     1
  2 |     1
  1 |     1
 10 |     1
  6 |     1
 24 |     1
  4 |     1
 12 |     1
  9 |     1
  7 |     1
 19 |     1
 27 |     1
 18 |     1
 22 |     1
  3 |     1
  5 |     1
 17 |     1
 13 |     1
  8 |     1
 30 |     1
 29 |     1
  1 |     1
 26 |     1
 20 |     1
 29 |     1
  4 |     1
 34 |     1
  0 |     1
 32 |     1
 10 |     1
  9 |     1
  7 |     1
 15 |     1
  6 |     1
 26 |     1
 12 |     1
 24 |     1
 19 |     1
 25 |     1
 31 |     1
 30 |     1
 21 |     1
 14 |     1
  3 |     1
 17 |     1
 28 |     1
 22 |     1
 20 |     1
 33 |     1
 13 |     1
  1 |     4
  5 |     1
 18 |     1
  2 |     1
 16 |     1
 27 |     1
 23 |     1
 11 |     1
  8 |     1
(73 rows)

select a,count(*) from orca.m group by grouping sets ((a), (b));
 a  | count 
----+-------
 29 |     1
  4 |     1
 34 |     1
  0 |     1
 32 |     1
 10 |     1
  9 |     1
  7 |     1
 15 |     1
  6 |     1
 26 |     1
 12 |     1
 24 |     1
 19 |     1
 25 |     1
 31 |     1
 30 |     1
 21 |     1
 14 |     1
  3 |     1
 17 |     1
 28 |     1
 22 |     1
 20 |     1
 33 |     1
 13 |     1
  1 |     4
  5 |     1
 18 |     1
  2 |     1
 16 |     1
 27 |     1
 23 |     1
 11 |     1
  8 |     1
    |    17
    |    19
    |     1
    |     1
(39 rows)

select a,b,count(*) from orca.m group by rollup(a, b);
 a  | b  | count 
----+----+-------
    |    |    38
 28 |  1 |     1
  1 |  1 |     1
 32 |  1 |     1
 11 |  0 |     1
 25 |  0 |     1
 34 |  1 |     1
 33 |  0 |     1
 14 |  1 |     1
 31 |  0 |     1
 15 |  0 |     1
 21 |  0 |     1
  1 | -1 |     1
 23 |  0 |     1
 16 |  1 |     1
  0 |  1 |     1
  2 |  1 |     1
  1 |  2 |     1
 10 |  1 |     1
  6 |  1 |     1
 24 |  1 |     1
  4 |  1 |     1
 12 |  1 |     1
  9 |  0 |     1
  7 |  0 |     1
 19 |  0 |     1
 27 |  0 |     1
 18 |  1 |     1
 22 |  1 |     1
  3 |  0 |     1
  5 |  0 |     1
 17 |  0 |     1
 13 |  0 |     1
  8 |  1 |     1
 30 |  1 |     1
 29 |  0 |     1
  1 |  0 |     1
 26 |  1 |     1
 20 |  1 |     1
 29 |    |     1
  4 |    |     1
 34 |    |     1
  0 |    |     1
 32 |    |     1
 10 |    |     1
  9 |    |     1
  7 |    |     1
 15 |    |     1
  6 |    |     1
 26 |    |     1
 12 |    |     1
 24 |    |     1
 19 |    |     1
 25 |    |     1
 31 |    |     1
 30 |    |     1
 21 |    |     1
 14 |    |     1
  3 |    |     1
 17 |    |     1
 28 |    |     1
 22 |    |     1
 20 |    |     1
 33 |    |     1
 13 |    |     1
  1 |    |     4
  5 |    |     1
 18 |    |     1
  2 |    |     1
 16 |    |     1
 27 |    |     1
 23 |    |     1
 11 |    |     1
  8 |    |     1
(74 rows)

select a,b,count(*) from orca.m group by rollup((a),(a,b)) order by 1,2,3;
 a  | b  | count 
----+----+-------
  0 |  1 |     1
  0 |    |     1
  1 | -1 |     1
  1 |  0 |     1
  1 |  1 |     1
  1 |  2 |     1
  1 |    |     4
  2 |  1 |     1
  2 |    |     1
  3 |  0 |     1
  3 |    |     1
  4 |  1 |     1
  4 |    |     1
  5 |  0 |     1
  5 |    |     1
  6 |  1 |     1
  6 |    |     1
  7 |  0 |     1
  7 |    |     1
  8 |  1 |     1
  8 |    |     1
  9 |  0 |     1
  9 |    |     1
 10 |  1 |     1
 10 |    |     1
 11 |  0 |     1
 11 |    |     1
 12 |  1 |     1
 12 |    |     1
 13 |  0 |     1
 13 |    |     1
 14 |  1 |     1
 14 |    |     1
 15 |  0 |     1
 15 |    |     1
 16 |  1 |     1
 16 |    |     1
 17 |  0 |     1
 17 |    |     1
 18 |  1 |     1
 18 |    |     1
 19 |  0 |     1
 19 |    |     1
 20 |  1 |     1
 20 |    |     1
 21 |  0 |     1
 21 |    |     1
 22 |  1 |     1
 22 |    |     1
 23 |  0 |     1
 23 |    |     1
 24 |  1 |     1
 24 |    |     1
 25 |  0 |     1
 25 |    |     1
 26 |  1 |     1
 26 |    |     1
 27 |  0 |     1
 27 |    |     1
 28 |  1 |     1
 28 |    |     1
 29 |  0 |     1
 29 |    |     1
 30 |  1 |     1
 30 |    |     1
 31 |  0 |     1
 31 |    |     1
 32 |  1 |     1
 32 |    |     1
 33 |  0 |     1
 33 |    |     1
 34 |  1 |     1
 34 |    |     1
    |    |    38
(74 rows)

select count(*) from orca.m group by ();
 count 
-------
    38
(1 row)

select a, count(*) from orca.r group by (), a;
 a  | count 
----+-------
 11 |     1
  8 |     1
    |     1
 19 |     1
  4 |     1
 14 |     1
  3 |     1
 17 |     1
 20 |     1
 13 |     1
 10 |     1
  9 |     1
  7 |     1
  1 |     1
  5 |     1
 18 |     1
  2 |     1
 16 |     1
 15 |     1
  6 |     1
 12 |     1
(21 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, (count())
   ->  GroupAggregate
         Output: a, count()
         Group Key: r.a
         ->  Sort
               Output: a
               Sort Key: r.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a
                     Hash Key: a
                     ->  Partial Seq Scan on orca.r
                           Output: a
 Optimizer: PolarDB PX Optimizer
(14 rows)

select a, count(*) from orca.r group by grouping sets ((),(a));
 a  | count 
----+-------
    |    21
 11 |     1
  8 |     1
    |     1
 19 |     1
  4 |     1
 14 |     1
  3 |     1
 17 |     1
 20 |     1
 13 |     1
 10 |     1
  9 |     1
  7 |     1
  1 |     1
  5 |     1
 18 |     1
  2 |     1
 16 |     1
 15 |     1
  6 |     1
 12 |     1
(22 rows)

select a, b, count(*) c from orca.r group by grouping sets ((),(a), (a,b)) order by b,a,c;
 a  | b | c  
----+---+----
  3 | 0 |  1
  6 | 0 |  1
  9 | 0 |  1
 12 | 0 |  1
 15 | 0 |  1
 18 | 0 |  1
  1 | 1 |  1
  4 | 1 |  1
  7 | 1 |  1
 10 | 1 |  1
 13 | 1 |  1
 16 | 1 |  1
 19 | 1 |  1
    | 1 |  1
  2 | 2 |  1
  5 | 2 |  1
  8 | 2 |  1
 11 | 2 |  1
 14 | 2 |  1
 17 | 2 |  1
 20 | 2 |  1
  1 |   |  1
  2 |   |  1
  3 |   |  1
  4 |   |  1
  5 |   |  1
  6 |   |  1
  7 |   |  1
  8 |   |  1
  9 |   |  1
 10 |   |  1
 11 |   |  1
 12 |   |  1
 13 |   |  1
 14 |   |  1
 15 |   |  1
 16 |   |  1
 17 |   |  1
 18 |   |  1
 19 |   |  1
 20 |   |  1
    |   |  1
    |   | 21
(43 rows)

select a, count(*) c from orca.r group by grouping sets ((),(a), (a,b)) order by b,a,c;
 a  | c  
----+----
  3 |  1
  6 |  1
  9 |  1
 12 |  1
 15 |  1
 18 |  1
  1 |  1
  4 |  1
  7 |  1
 10 |  1
 13 |  1
 16 |  1
 19 |  1
    |  1
  2 |  1
  5 |  1
  8 |  1
 11 |  1
 14 |  1
 17 |  1
 20 |  1
  1 |  1
  2 |  1
  3 |  1
  4 |  1
  5 |  1
  6 |  1
  7 |  1
  8 |  1
  9 |  1
 10 |  1
 11 |  1
 12 |  1
 13 |  1
 14 |  1
 15 |  1
 16 |  1
 17 |  1
 18 |  1
 19 |  1
 20 |  1
    |  1
    | 21
(43 rows)

select 1 from orca.r group by ();
 ?column? 
----------
        1
(1 row)

select a,1 from orca.r group by rollup(a);
 a  | ?column? 
----+----------
    |        1
 11 |        1
  8 |        1
    |        1
 19 |        1
  4 |        1
 14 |        1
  3 |        1
 17 |        1
 20 |        1
 13 |        1
 10 |        1
  9 |        1
  7 |        1
  1 |        1
  5 |        1
 18 |        1
  2 |        1
 16 |        1
 15 |        1
  6 |        1
 12 |        1
(22 rows)

select distinct grouping(a) + grouping(b) from orca.m group by rollup(a,b);
 ?column? 
----------
        0
        2
        1
(3 rows)

-- arrays
select array[array[a,b]], array[b] from orca.r;
   array    | array 
------------+-------
 {{1,1}}    | {1}
 {{2,2}}    | {2}
 {{3,0}}    | {0}
 {{4,1}}    | {1}
 {{5,2}}    | {2}
 {{6,0}}    | {0}
 {{7,1}}    | {1}
 {{8,2}}    | {2}
 {{9,0}}    | {0}
 {{10,1}}   | {1}
 {{11,2}}   | {2}
 {{12,0}}   | {0}
 {{13,1}}   | {1}
 {{14,2}}   | {2}
 {{15,0}}   | {0}
 {{16,1}}   | {1}
 {{17,2}}   | {2}
 {{18,0}}   | {0}
 {{19,1}}   | {1}
 {{20,2}}   | {2}
 {{NULL,1}} | {1}
(21 rows)

                   QUERY PLAN                    
-------------------------------------------------
 Result
   Output: ARRAY[ARRAY[a, b]], ARRAY[b]
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a, b
         ->  Partial Seq Scan on orca.r
               Output: a, b
 Optimizer: PolarDB PX Optimizer
(7 rows)

-- setops
select a, b from orca.m union select b,a from orca.m;
 a  | b  
----+----
  1 |  8
  1 | 10
  1 |  1
  0 | 21
 31 |  0
 15 |  0
  1 | 28
  1 | -1
  0 |  1
  0 |  9
  1 |  2
  0 | 11
  1 | 30
 10 |  1
  4 |  1
  7 |  0
 19 |  0
  1 | 12
 18 |  1
  1 | 24
  1 | 16
  0 |  7
  0 |  3
  3 |  0
  0 |  5
  5 |  0
 13 |  0
 29 |  0
 26 |  1
  0 | 23
 20 |  1
  0 | 31
  0 | 13
  0 | 25
 28 |  1
  0 | 27
 32 |  1
  0 | 33
 11 |  0
 25 |  0
  1 | 22
 34 |  1
 33 |  0
  1 | 26
 14 |  1
  1 | 34
  1 | 20
 21 |  0
  0 | 19
  1 | 18
 23 |  0
 16 |  1
  2 |  1
  0 | 15
  6 |  1
 24 |  1
  1 | 32
 12 |  1
  9 |  0
 27 |  0
 22 |  1
  1 | 14
 17 |  0
  8 |  1
 30 |  1
 -1 |  1
  1 |  4
  1 |  0
  0 | 17
  1 |  6
  0 | 29
(71 rows)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: m.a, m.b
   ->  GroupAggregate
         Output: m.a, m.b
         Group Key: m.a, m.b
         ->  Sort
               Output: m.a, m.b
               Sort Key: m.a, m.b
               ->  Append
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: m.a, m.b
                           Hash Key: m.a, m.b
                           ->  Partial Seq Scan on orca.m
                                 Output: m.a, m.b
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: m_1.b, m_1.a
                           Hash Key: m_1.b, m_1.a
                           ->  Partial Seq Scan on orca.m m_1
                                 Output: m_1.b, m_1.a
 Optimizer: PolarDB PX Optimizer
(20 rows)

SELECT a from orca.m UNION ALL select b from orca.m UNION ALL select a+b from orca.m group by 1;
 a  
----
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
  1
  1
  1
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
  0
  1
 -1
  2
  1
 29
  0
  9
  7
 35
 15
 19
 25
 31
 21
  3
 17
 33
 13
  1
  5
  2
 27
 23
 11
(96 rows)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: m.a
   ->  Append
         ->  Partial Seq Scan on orca.m
               Output: m.a
         ->  Partial Seq Scan on orca.m m_1
               Output: m_1.b
         ->  GroupAggregate
               Output: ((m_2.a + m_2.b))
               Group Key: ((m_2.a + m_2.b))
               ->  Sort
                     Output: ((m_2.a + m_2.b))
                     Sort Key: ((m_2.a + m_2.b))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: ((m_2.a + m_2.b))
                           Hash Key: ((m_2.a + m_2.b))
                           ->  Partial Seq Scan on orca.m m_2
                                 Output: (m_2.a + m_2.b)
 Optimizer: PolarDB PX Optimizer
(19 rows)

drop table if exists orca.foo;
create table orca.foo(a int, b int, c int, d int);
drop table if exists orca.bar;
NOTICE:  table "bar" does not exist, skipping
create table orca.bar(a int, b int, c int);
insert into orca.foo select i, i%2, i%4, i-1 from generate_series(1,40)i;
insert into orca.bar select i, i%3, i%2 from generate_series(1,30)i;
-- distinct operation
SELECT distinct a, b from orca.foo;
 a  | b 
----+---
 31 | 1
  1 | 1
 18 | 0
 17 | 1
 32 | 0
  7 | 1
  3 | 1
 19 | 1
 14 | 0
 25 | 1
  6 | 0
 20 | 0
 35 | 1
 10 | 0
 38 | 0
 40 | 0
 27 | 1
 21 | 1
  9 | 1
 12 | 0
 11 | 1
  5 | 1
 26 | 0
 24 | 0
 36 | 0
 29 | 1
 15 | 1
 28 | 0
  2 | 0
 30 | 0
 22 | 0
 33 | 1
  8 | 0
 39 | 1
 23 | 1
 16 | 0
 13 | 1
 34 | 0
 37 | 1
  4 | 0
(40 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  GroupAggregate
         Output: a, b
         Group Key: foo.a, foo.b
         ->  Sort
               Output: a, b
               Sort Key: foo.a, foo.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a, b
                     Hash Key: a, b
                     ->  Partial Seq Scan on orca.foo
                           Output: a, b
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT distinct foo.a, bar.b from orca.foo, orca.bar where foo.b = bar.a;
 a  | b 
----+---
 27 | 1
 21 | 1
 25 | 1
 31 | 1
  1 | 1
  9 | 1
 33 | 1
 11 | 1
  5 | 1
 39 | 1
 23 | 1
 13 | 1
 17 | 1
 29 | 1
 37 | 1
 35 | 1
  7 | 1
  3 | 1
 19 | 1
 15 | 1
(20 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, bar.b
   ->  GroupAggregate
         Output: foo.a, bar.b
         Group Key: foo.a, bar.b
         ->  Sort
               Output: foo.a, bar.b
               Sort Key: foo.a, bar.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, bar.b
                     Hash Key: foo.a, bar.b
                     ->  Hash Join
                           Output: foo.a, bar.b
                           Hash Cond: (foo.b = bar.a)
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: foo.a, foo.b
                                 Hash Key: foo.b
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.a, foo.b
                           ->  Hash
                                 Output: bar.a, bar.b
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: bar.a, bar.b
                                       Hash Key: bar.a
                                       ->  Partial Seq Scan on orca.bar
                                             Output: bar.a, bar.b
 Optimizer: PolarDB PX Optimizer
(27 rows)

SELECT distinct a, b from orca.foo;
 a  | b 
----+---
 14 | 0
 40 | 0
 27 | 1
 21 | 1
 28 | 0
 25 | 1
  2 | 0
 31 | 1
 30 | 0
 22 | 0
  1 | 1
  9 | 1
 33 | 1
  8 | 0
 12 | 0
 11 | 1
  5 | 1
 39 | 1
 23 | 1
 26 | 0
 16 | 0
  6 | 0
 18 | 0
 13 | 1
 24 | 0
 17 | 1
 36 | 0
 34 | 0
 32 | 0
 29 | 1
 20 | 0
 37 | 1
 35 | 1
 10 | 0
  7 | 1
  3 | 1
 19 | 1
 38 | 0
  4 | 0
 15 | 1
(40 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  GroupAggregate
         Output: a, b
         Group Key: foo.a, foo.b
         ->  Sort
               Output: a, b
               Sort Key: foo.a, foo.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a, b
                     Hash Key: a, b
                     ->  Partial Seq Scan on orca.foo
                           Output: a, b
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT distinct a, count(*) from orca.foo group by a;
 a  | count 
----+-------
 27 |     1
 28 |     1
 21 |     1
 25 |     1
 31 |     1
  1 |     1
 32 |     1
 38 |     1
  9 |     1
 33 |     1
 34 |     1
 14 |     1
 11 |     1
  5 |     1
 39 |     1
 23 |     1
 16 |     1
  2 |     1
 10 |     1
 36 |     1
  6 |     1
 24 |     1
  4 |     1
 13 |     1
 12 |     1
 17 |     1
 18 |     1
 22 |     1
 29 |     1
 37 |     1
  8 |     1
 35 |     1
 30 |     1
  7 |     1
 40 |     1
  3 |     1
 26 |     1
 20 |     1
 19 |     1
 15 |     1
(40 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, (count())
   ->  GroupAggregate
         Output: a, count()
         Group Key: foo.a
         ->  Sort
               Output: a
               Sort Key: foo.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a
                     Hash Key: a
                     ->  Partial Seq Scan on orca.foo
                           Output: a
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT distinct foo.a, bar.b, sum(bar.c+foo.c) from orca.foo, orca.bar where foo.b = bar.a group by foo.a, bar.b;
 a  | b | sum 
----+---+-----
  7 | 1 |   4
 37 | 1 |   2
 13 | 1 |   2
 23 | 1 |   4
 17 | 1 |   2
  1 | 1 |   2
 25 | 1 |   2
 21 | 1 |   2
 27 | 1 |   4
  3 | 1 |   4
 33 | 1 |   2
  9 | 1 |   2
 19 | 1 |   4
  5 | 1 |   2
 35 | 1 |   4
 11 | 1 |   4
 31 | 1 |   4
 29 | 1 |   2
 15 | 1 |   4
 39 | 1 |   4
(20 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, bar.b, (sum((bar.c + foo.c)))
   ->  HashAggregate
         Output: foo.a, bar.b, sum((bar.c + foo.c))
         Group Key: foo.a, bar.b
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.a, foo.c, bar.b, bar.c
               Hash Key: foo.a, bar.b
               ->  Hash Join
                     Output: foo.a, foo.c, bar.b, bar.c
                     Hash Cond: (foo.b = bar.a)
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: foo.a, foo.b, foo.c
                           Hash Key: foo.b
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a, foo.b, foo.c
                     ->  Hash
                           Output: bar.a, bar.b, bar.c
                           ->  PX Hash 6:6  (slice4; segments: 6)
                                 Output: bar.a, bar.b, bar.c
                                 Hash Key: bar.a
                                 ->  Partial Seq Scan on orca.bar
                                       Output: bar.a, bar.b, bar.c
 Optimizer: PolarDB PX Optimizer
(24 rows)

SELECT distinct a, count(*) from orca.foo group by a;
 a  | count 
----+-------
 27 |     1
 28 |     1
 21 |     1
 25 |     1
 31 |     1
  1 |     1
 32 |     1
 38 |     1
  9 |     1
 33 |     1
 34 |     1
 14 |     1
 11 |     1
  5 |     1
 39 |     1
 23 |     1
 16 |     1
  2 |     1
 10 |     1
 36 |     1
  6 |     1
 24 |     1
  4 |     1
 13 |     1
 12 |     1
 17 |     1
 18 |     1
 22 |     1
 29 |     1
 37 |     1
  8 |     1
 35 |     1
 30 |     1
  7 |     1
 40 |     1
  3 |     1
 26 |     1
 20 |     1
 19 |     1
 15 |     1
(40 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, (count())
   ->  GroupAggregate
         Output: a, count()
         Group Key: foo.a
         ->  Sort
               Output: a
               Sort Key: foo.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a
                     Hash Key: a
                     ->  Partial Seq Scan on orca.foo
                           Output: a
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT distinct foo.a, bar.b from orca.foo, orca.bar where foo.b = bar.a;
 a  | b 
----+---
 27 | 1
 21 | 1
 25 | 1
 31 | 1
  1 | 1
  9 | 1
 33 | 1
 11 | 1
  5 | 1
 39 | 1
 23 | 1
 13 | 1
 17 | 1
 29 | 1
 37 | 1
 35 | 1
  7 | 1
  3 | 1
 19 | 1
 15 | 1
(20 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, bar.b
   ->  GroupAggregate
         Output: foo.a, bar.b
         Group Key: foo.a, bar.b
         ->  Sort
               Output: foo.a, bar.b
               Sort Key: foo.a, bar.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, bar.b
                     Hash Key: foo.a, bar.b
                     ->  Hash Join
                           Output: foo.a, bar.b
                           Hash Cond: (foo.b = bar.a)
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: foo.a, foo.b
                                 Hash Key: foo.b
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.a, foo.b
                           ->  Hash
                                 Output: bar.a, bar.b
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: bar.a, bar.b
                                       Hash Key: bar.a
                                       ->  Partial Seq Scan on orca.bar
                                             Output: bar.a, bar.b
 Optimizer: PolarDB PX Optimizer
(27 rows)

SELECT distinct foo.a, bar.b, sum(bar.c+foo.c) from orca.foo, orca.bar where foo.b = bar.a group by foo.a, bar.b;
 a  | b | sum 
----+---+-----
  7 | 1 |   4
 37 | 1 |   2
 13 | 1 |   2
 23 | 1 |   4
 17 | 1 |   2
  1 | 1 |   2
 25 | 1 |   2
 21 | 1 |   2
 27 | 1 |   4
  3 | 1 |   4
 33 | 1 |   2
  9 | 1 |   2
 19 | 1 |   4
  5 | 1 |   2
 35 | 1 |   4
 11 | 1 |   4
 31 | 1 |   4
 29 | 1 |   2
 15 | 1 |   4
 39 | 1 |   4
(20 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, bar.b, (sum((bar.c + foo.c)))
   ->  HashAggregate
         Output: foo.a, bar.b, sum((bar.c + foo.c))
         Group Key: foo.a, bar.b
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.a, foo.c, bar.b, bar.c
               Hash Key: foo.a, bar.b
               ->  Hash Join
                     Output: foo.a, foo.c, bar.b, bar.c
                     Hash Cond: (foo.b = bar.a)
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: foo.a, foo.b, foo.c
                           Hash Key: foo.b
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a, foo.b, foo.c
                     ->  Hash
                           Output: bar.a, bar.b, bar.c
                           ->  PX Hash 6:6  (slice4; segments: 6)
                                 Output: bar.a, bar.b, bar.c
                                 Hash Key: bar.a
                                 ->  Partial Seq Scan on orca.bar
                                       Output: bar.a, bar.b, bar.c
 Optimizer: PolarDB PX Optimizer
(24 rows)

SELECT distinct a, b from orca.foo;
 a  | b 
----+---
 14 | 0
 40 | 0
 27 | 1
 21 | 1
 28 | 0
 25 | 1
  2 | 0
 31 | 1
 30 | 0
 22 | 0
  1 | 1
  9 | 1
 33 | 1
  8 | 0
 12 | 0
 11 | 1
  5 | 1
 39 | 1
 23 | 1
 26 | 0
 16 | 0
  6 | 0
 18 | 0
 13 | 1
 24 | 0
 17 | 1
 36 | 0
 34 | 0
 32 | 0
 29 | 1
 20 | 0
 37 | 1
 35 | 1
 10 | 0
  7 | 1
  3 | 1
 19 | 1
 38 | 0
  4 | 0
 15 | 1
(40 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  GroupAggregate
         Output: a, b
         Group Key: foo.a, foo.b
         ->  Sort
               Output: a, b
               Sort Key: foo.a, foo.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a, b
                     Hash Key: a, b
                     ->  Partial Seq Scan on orca.foo
                           Output: a, b
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT distinct a, count(*) from orca.foo group by a;
 a  | count 
----+-------
 27 |     1
 28 |     1
 21 |     1
 25 |     1
 31 |     1
  1 |     1
 32 |     1
 38 |     1
  9 |     1
 33 |     1
 34 |     1
 14 |     1
 11 |     1
  5 |     1
 39 |     1
 23 |     1
 16 |     1
  2 |     1
 10 |     1
 36 |     1
  6 |     1
 24 |     1
  4 |     1
 13 |     1
 12 |     1
 17 |     1
 18 |     1
 22 |     1
 29 |     1
 37 |     1
  8 |     1
 35 |     1
 30 |     1
  7 |     1
 40 |     1
  3 |     1
 26 |     1
 20 |     1
 19 |     1
 15 |     1
(40 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, (count())
   ->  GroupAggregate
         Output: a, count()
         Group Key: foo.a
         ->  Sort
               Output: a
               Sort Key: foo.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a
                     Hash Key: a
                     ->  Partial Seq Scan on orca.foo
                           Output: a
 Optimizer: PolarDB PX Optimizer
(14 rows)

SELECT distinct foo.a, bar.b from orca.foo, orca.bar where foo.b = bar.a;
 a  | b 
----+---
 27 | 1
 21 | 1
 25 | 1
 31 | 1
  1 | 1
  9 | 1
 33 | 1
 11 | 1
  5 | 1
 39 | 1
 23 | 1
 13 | 1
 17 | 1
 29 | 1
 37 | 1
 35 | 1
  7 | 1
  3 | 1
 19 | 1
 15 | 1
(20 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, bar.b
   ->  GroupAggregate
         Output: foo.a, bar.b
         Group Key: foo.a, bar.b
         ->  Sort
               Output: foo.a, bar.b
               Sort Key: foo.a, bar.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, bar.b
                     Hash Key: foo.a, bar.b
                     ->  Hash Join
                           Output: foo.a, bar.b
                           Hash Cond: (foo.b = bar.a)
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: foo.a, foo.b
                                 Hash Key: foo.b
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.a, foo.b
                           ->  Hash
                                 Output: bar.a, bar.b
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: bar.a, bar.b
                                       Hash Key: bar.a
                                       ->  Partial Seq Scan on orca.bar
                                             Output: bar.a, bar.b
 Optimizer: PolarDB PX Optimizer
(27 rows)

SELECT distinct foo.a, bar.b, sum(bar.c+foo.c) from orca.foo, orca.bar where foo.b = bar.a group by foo.a, bar.b;
 a  | b | sum 
----+---+-----
  7 | 1 |   4
 37 | 1 |   2
 13 | 1 |   2
 23 | 1 |   4
 17 | 1 |   2
  1 | 1 |   2
 25 | 1 |   2
 21 | 1 |   2
 27 | 1 |   4
  3 | 1 |   4
 33 | 1 |   2
  9 | 1 |   2
 19 | 1 |   4
  5 | 1 |   2
 35 | 1 |   4
 11 | 1 |   4
 31 | 1 |   4
 29 | 1 |   2
 15 | 1 |   4
 39 | 1 |   4
(20 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, bar.b, (sum((bar.c + foo.c)))
   ->  HashAggregate
         Output: foo.a, bar.b, sum((bar.c + foo.c))
         Group Key: foo.a, bar.b
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.a, foo.c, bar.b, bar.c
               Hash Key: foo.a, bar.b
               ->  Hash Join
                     Output: foo.a, foo.c, bar.b, bar.c
                     Hash Cond: (foo.b = bar.a)
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: foo.a, foo.b, foo.c
                           Hash Key: foo.b
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a, foo.b, foo.c
                     ->  Hash
                           Output: bar.a, bar.b, bar.c
                           ->  PX Hash 6:6  (slice4; segments: 6)
                                 Output: bar.a, bar.b, bar.c
                                 Hash Key: bar.a
                                 ->  Partial Seq Scan on orca.bar
                                       Output: bar.a, bar.b, bar.c
 Optimizer: PolarDB PX Optimizer
(24 rows)

-- window operations
select row_number() over() from orca.foo order by 1;
 row_number 
------------
          1
          2
          3
          4
          5
          6
          7
          8
          9
         10
         11
         12
         13
         14
         15
         16
         17
         18
         19
         20
         21
         22
         23
         24
         25
         26
         27
         28
         29
         30
         31
         32
         33
         34
         35
         36
         37
         38
         39
         40
(40 rows)

                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Output: (row_number() OVER (?))
   Sort Key: (row_number() OVER (?))
   ->  WindowAgg
         Output: row_number() OVER (?)
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               ->  Partial Seq Scan on orca.foo
 Optimizer: PolarDB PX Optimizer
(8 rows)

select rank() over(partition by b order by count(*)/sum(a)) from orca.foo group by a, b order by 1;
 rank 
------
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
   20
(40 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (rank() OVER (?))
   Merge Key: (rank() OVER (?))
   ->  Result
         Output: (rank() OVER (?))
         ->  Sort
               Output: (rank() OVER (?)), b, ((count() / sum(a)))
               Sort Key: (rank() OVER (?))
               ->  WindowAgg
                     Output: rank() OVER (?), b, ((count() / sum(a)))
                     ->  Sort
                           Output: b, ((count() / sum(a)))
                           Sort Key: foo.b, ((count() / sum(foo.a)))
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: b, ((count() / sum(a)))
                                 Hash Key: b
                                 ->  GroupAggregate
                                       Output: b, (count() / sum(a))
                                       Group Key: foo.a, foo.b
                                       ->  Sort
                                             Output: a, b
                                             Sort Key: foo.a, foo.b
                                             ->  PX Hash 6:6  (slice3; segments: 6)
                                                   Output: a, b
                                                   Hash Key: a, b
                                                   ->  Partial Seq Scan on orca.foo
                                                         Output: a, b
 Optimizer: PolarDB PX Optimizer
(28 rows)

select row_number() over(order by foo.a) from orca.foo inner join orca.bar using(b) group by foo.a, bar.b, bar.a;
 row_number 
------------
          1
          2
          3
          4
          5
          6
          7
          8
          9
         10
         11
         12
         13
         14
         15
         16
         17
         18
         19
         20
         21
         22
         23
         24
         25
         26
         27
         28
         29
         30
         31
         32
         33
         34
         35
         36
         37
         38
         39
         40
         41
         42
         43
         44
         45
         46
         47
         48
         49
         50
         51
         52
         53
         54
         55
         56
         57
         58
         59
         60
         61
         62
         63
         64
         65
         66
         67
         68
         69
         70
         71
         72
         73
         74
         75
         76
         77
         78
         79
         80
         81
         82
         83
         84
         85
         86
         87
         88
         89
         90
         91
         92
         93
         94
         95
         96
         97
         98
         99
        100
        101
        102
        103
        104
        105
        106
        107
        108
        109
        110
        111
        112
        113
        114
        115
        116
        117
        118
        119
        120
        121
        122
        123
        124
        125
        126
        127
        128
        129
        130
        131
        132
        133
        134
        135
        136
        137
        138
        139
        140
        141
        142
        143
        144
        145
        146
        147
        148
        149
        150
        151
        152
        153
        154
        155
        156
        157
        158
        159
        160
        161
        162
        163
        164
        165
        166
        167
        168
        169
        170
        171
        172
        173
        174
        175
        176
        177
        178
        179
        180
        181
        182
        183
        184
        185
        186
        187
        188
        189
        190
        191
        192
        193
        194
        195
        196
        197
        198
        199
        200
        201
        202
        203
        204
        205
        206
        207
        208
        209
        210
        211
        212
        213
        214
        215
        216
        217
        218
        219
        220
        221
        222
        223
        224
        225
        226
        227
        228
        229
        230
        231
        232
        233
        234
        235
        236
        237
        238
        239
        240
        241
        242
        243
        244
        245
        246
        247
        248
        249
        250
        251
        252
        253
        254
        255
        256
        257
        258
        259
        260
        261
        262
        263
        264
        265
        266
        267
        268
        269
        270
        271
        272
        273
        274
        275
        276
        277
        278
        279
        280
        281
        282
        283
        284
        285
        286
        287
        288
        289
        290
        291
        292
        293
        294
        295
        296
        297
        298
        299
        300
        301
        302
        303
        304
        305
        306
        307
        308
        309
        310
        311
        312
        313
        314
        315
        316
        317
        318
        319
        320
        321
        322
        323
        324
        325
        326
        327
        328
        329
        330
        331
        332
        333
        334
        335
        336
        337
        338
        339
        340
        341
        342
        343
        344
        345
        346
        347
        348
        349
        350
        351
        352
        353
        354
        355
        356
        357
        358
        359
        360
        361
        362
        363
        364
        365
        366
        367
        368
        369
        370
        371
        372
        373
        374
        375
        376
        377
        378
        379
        380
        381
        382
        383
        384
        385
        386
        387
        388
        389
        390
        391
        392
        393
        394
        395
        396
        397
        398
        399
        400
(400 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 WindowAgg
   Output: row_number() OVER (?)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: foo.a
         Merge Key: foo.a
         ->  GroupAggregate
               Output: foo.a
               Group Key: foo.a, bar.b, bar.a
               ->  Sort
                     Output: foo.a, bar.a, bar.b
                     Sort Key: foo.a, bar.b, bar.a
                     ->  Hash Join
                           Output: foo.a, bar.a, bar.b
                           Hash Cond: (bar.b = foo.b)
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: bar.a, bar.b
                                 Hash Key: bar.b
                                 ->  Partial Seq Scan on orca.bar
                                       Output: bar.a, bar.b
                           ->  Hash
                                 Output: foo.a, foo.b
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: foo.a, foo.b
                                       Hash Key: foo.b
                                       ->  Partial Seq Scan on orca.foo
                                             Output: foo.a, foo.b
 Optimizer: PolarDB PX Optimizer
(27 rows)

select 1+row_number() over(order by foo.a+bar.a) from orca.foo inner join orca.bar using(b);
 ?column? 
----------
        2
        3
        4
        5
        6
        7
        8
        9
       10
       11
       12
       13
       14
       15
       16
       17
       18
       19
       20
       21
       22
       23
       24
       25
       26
       27
       28
       29
       30
       31
       32
       33
       34
       35
       36
       37
       38
       39
       40
       41
       42
       43
       44
       45
       46
       47
       48
       49
       50
       51
       52
       53
       54
       55
       56
       57
       58
       59
       60
       61
       62
       63
       64
       65
       66
       67
       68
       69
       70
       71
       72
       73
       74
       75
       76
       77
       78
       79
       80
       81
       82
       83
       84
       85
       86
       87
       88
       89
       90
       91
       92
       93
       94
       95
       96
       97
       98
       99
      100
      101
      102
      103
      104
      105
      106
      107
      108
      109
      110
      111
      112
      113
      114
      115
      116
      117
      118
      119
      120
      121
      122
      123
      124
      125
      126
      127
      128
      129
      130
      131
      132
      133
      134
      135
      136
      137
      138
      139
      140
      141
      142
      143
      144
      145
      146
      147
      148
      149
      150
      151
      152
      153
      154
      155
      156
      157
      158
      159
      160
      161
      162
      163
      164
      165
      166
      167
      168
      169
      170
      171
      172
      173
      174
      175
      176
      177
      178
      179
      180
      181
      182
      183
      184
      185
      186
      187
      188
      189
      190
      191
      192
      193
      194
      195
      196
      197
      198
      199
      200
      201
      202
      203
      204
      205
      206
      207
      208
      209
      210
      211
      212
      213
      214
      215
      216
      217
      218
      219
      220
      221
      222
      223
      224
      225
      226
      227
      228
      229
      230
      231
      232
      233
      234
      235
      236
      237
      238
      239
      240
      241
      242
      243
      244
      245
      246
      247
      248
      249
      250
      251
      252
      253
      254
      255
      256
      257
      258
      259
      260
      261
      262
      263
      264
      265
      266
      267
      268
      269
      270
      271
      272
      273
      274
      275
      276
      277
      278
      279
      280
      281
      282
      283
      284
      285
      286
      287
      288
      289
      290
      291
      292
      293
      294
      295
      296
      297
      298
      299
      300
      301
      302
      303
      304
      305
      306
      307
      308
      309
      310
      311
      312
      313
      314
      315
      316
      317
      318
      319
      320
      321
      322
      323
      324
      325
      326
      327
      328
      329
      330
      331
      332
      333
      334
      335
      336
      337
      338
      339
      340
      341
      342
      343
      344
      345
      346
      347
      348
      349
      350
      351
      352
      353
      354
      355
      356
      357
      358
      359
      360
      361
      362
      363
      364
      365
      366
      367
      368
      369
      370
      371
      372
      373
      374
      375
      376
      377
      378
      379
      380
      381
      382
      383
      384
      385
      386
      387
      388
      389
      390
      391
      392
      393
      394
      395
      396
      397
      398
      399
      400
      401
(400 rows)

                            QUERY PLAN                            
------------------------------------------------------------------
 WindowAgg
   Output: (1 + row_number() OVER (?))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: ((foo.a + bar.a))
         Merge Key: ((foo.a + bar.a))
         ->  Sort
               Output: ((foo.a + bar.a))
               Sort Key: ((foo.a + bar.a))
               ->  Hash Join
                     Output: (foo.a + bar.a)
                     Hash Cond: (foo.b = bar.b)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: foo.a, foo.b
                           Hash Key: foo.b
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a, foo.b
                     ->  Hash
                           Output: bar.a, bar.b
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: bar.a, bar.b
                                 Hash Key: bar.b
                                 ->  Partial Seq Scan on orca.bar
                                       Output: bar.a, bar.b
 Optimizer: PolarDB PX Optimizer
(24 rows)

select row_number() over(order by foo.a+ bar.a)/count(*) from orca.foo inner join orca.bar using(b) group by foo.a, bar.a, bar.b;
 ?column? 
----------
        1
        2
        3
        4
        5
        6
        7
        8
        9
       10
       11
       12
       13
       14
       15
       16
       17
       18
       19
       20
       21
       22
       23
       24
       25
       26
       27
       28
       29
       30
       31
       32
       33
       34
       35
       36
       37
       38
       39
       40
       41
       42
       43
       44
       45
       46
       47
       48
       49
       50
       51
       52
       53
       54
       55
       56
       57
       58
       59
       60
       61
       62
       63
       64
       65
       66
       67
       68
       69
       70
       71
       72
       73
       74
       75
       76
       77
       78
       79
       80
       81
       82
       83
       84
       85
       86
       87
       88
       89
       90
       91
       92
       93
       94
       95
       96
       97
       98
       99
      100
      101
      102
      103
      104
      105
      106
      107
      108
      109
      110
      111
      112
      113
      114
      115
      116
      117
      118
      119
      120
      121
      122
      123
      124
      125
      126
      127
      128
      129
      130
      131
      132
      133
      134
      135
      136
      137
      138
      139
      140
      141
      142
      143
      144
      145
      146
      147
      148
      149
      150
      151
      152
      153
      154
      155
      156
      157
      158
      159
      160
      161
      162
      163
      164
      165
      166
      167
      168
      169
      170
      171
      172
      173
      174
      175
      176
      177
      178
      179
      180
      181
      182
      183
      184
      185
      186
      187
      188
      189
      190
      191
      192
      193
      194
      195
      196
      197
      198
      199
      200
      201
      202
      203
      204
      205
      206
      207
      208
      209
      210
      211
      212
      213
      214
      215
      216
      217
      218
      219
      220
      221
      222
      223
      224
      225
      226
      227
      228
      229
      230
      231
      232
      233
      234
      235
      236
      237
      238
      239
      240
      241
      242
      243
      244
      245
      246
      247
      248
      249
      250
      251
      252
      253
      254
      255
      256
      257
      258
      259
      260
      261
      262
      263
      264
      265
      266
      267
      268
      269
      270
      271
      272
      273
      274
      275
      276
      277
      278
      279
      280
      281
      282
      283
      284
      285
      286
      287
      288
      289
      290
      291
      292
      293
      294
      295
      296
      297
      298
      299
      300
      301
      302
      303
      304
      305
      306
      307
      308
      309
      310
      311
      312
      313
      314
      315
      316
      317
      318
      319
      320
      321
      322
      323
      324
      325
      326
      327
      328
      329
      330
      331
      332
      333
      334
      335
      336
      337
      338
      339
      340
      341
      342
      343
      344
      345
      346
      347
      348
      349
      350
      351
      352
      353
      354
      355
      356
      357
      358
      359
      360
      361
      362
      363
      364
      365
      366
      367
      368
      369
      370
      371
      372
      373
      374
      375
      376
      377
      378
      379
      380
      381
      382
      383
      384
      385
      386
      387
      388
      389
      390
      391
      392
      393
      394
      395
      396
      397
      398
      399
      400
(400 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 WindowAgg
   Output: (row_number() OVER (?) / (count()))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (count()), ((foo.a + bar.a))
         Merge Key: ((foo.a + bar.a))
         ->  Result
               Output: (count()), ((foo.a + bar.a))
               ->  Sort
                     Output: ((foo.a + bar.a)), (count())
                     Sort Key: ((foo.a + bar.a))
                     ->  HashAggregate
                           Output: (foo.a + bar.a), count()
                           Group Key: foo.a, bar.a, bar.b
                           ->  Hash Join
                                 Output: foo.a, bar.a, bar.b
                                 Hash Cond: (bar.b = foo.b)
                                 ->  PX Hash 6:6  (slice2; segments: 6)
                                       Output: bar.a, bar.b
                                       Hash Key: bar.b
                                       ->  Partial Seq Scan on orca.bar
                                             Output: bar.a, bar.b
                                 ->  Hash
                                       Output: foo.a, foo.b
                                       ->  PX Hash 6:6  (slice3; segments: 6)
                                             Output: foo.a, foo.b
                                             Hash Key: foo.b
                                             ->  Partial Seq Scan on orca.foo
                                                   Output: foo.a, foo.b
 Optimizer: PolarDB PX Optimizer
(29 rows)

select count(*) over(partition by b order by a range between 1 preceding and (select count(*) from orca.bar) following) from orca.foo;
 count 
-------
    16
    16
    16
    16
    16
    15
    14
    13
    12
    11
    10
     9
     8
     7
     6
     5
     4
     3
     2
     1
    16
    16
    16
    16
    16
    15
    14
    13
    12
    11
    10
     9
     8
     7
     6
     5
     4
     3
     2
     1
(40 rows)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: window frame RANGE with OFFSET PRECEDING or FOLLOWING
select a+1, rank() over(partition by b+1 order by a+1) from orca.foo order by 1, 2;
 ?column? | rank 
----------+------
        2 |    1
        3 |    1
        4 |    2
        5 |    2
        6 |    3
        7 |    3
        8 |    4
        9 |    4
       10 |    5
       11 |    5
       12 |    6
       13 |    6
       14 |    7
       15 |    7
       16 |    8
       17 |    8
       18 |    9
       19 |    9
       20 |   10
       21 |   10
       22 |   11
       23 |   11
       24 |   12
       25 |   12
       26 |   13
       27 |   13
       28 |   14
       29 |   14
       30 |   15
       31 |   15
       32 |   16
       33 |   16
       34 |   17
       35 |   17
       36 |   18
       37 |   18
       38 |   19
       39 |   19
       40 |   20
       41 |   20
(40 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((a + 1)), (rank() OVER (?))
   Merge Key: ((a + 1)), (rank() OVER (?))
   ->  Result
         Output: ((a + 1)), (rank() OVER (?))
         ->  Sort
               Output: ((a + 1)), (rank() OVER (?)), ((b + 1))
               Sort Key: ((foo.a + 1)), (rank() OVER (?))
               ->  WindowAgg
                     Output: ((a + 1)), rank() OVER (?), ((b + 1))
                     ->  Sort
                           Output: ((a + 1)), ((b + 1))
                           Sort Key: ((foo.b + 1)), ((foo.a + 1))
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: ((a + 1)), ((b + 1))
                                 Hash Key: ((b + 1))
                                 ->  Partial Seq Scan on orca.foo
                                       Output: (a + 1), (b + 1)
 Optimizer: PolarDB PX Optimizer
(19 rows)

select a , sum(a) over (order by a range 1 preceding) from orca.r order by 1,2;
 a  | sum 
----+-----
  1 |   1
  2 |   3
  3 |   5
  4 |   7
  5 |   9
  6 |  11
  7 |  13
  8 |  15
  9 |  17
 10 |  19
 11 |  21
 12 |  23
 13 |  25
 14 |  27
 15 |  29
 16 |  31
 17 |  33
 18 |  35
 19 |  37
 20 |  39
    |    
(21 rows)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: window frame RANGE with OFFSET PRECEDING or FOLLOWING
select a, b, floor(avg(b) over(order by a desc, b desc rows between unbounded preceding and unbounded following)) as avg, dense_rank() over (order by a) from orca.r order by 1,2,3,4;
 a  | b | avg | dense_rank 
----+---+-----+------------
  1 | 1 |   1 |          1
  2 | 2 |   1 |          2
  3 | 0 |   1 |          3
  4 | 1 |   1 |          4
  5 | 2 |   1 |          5
  6 | 0 |   1 |          6
  7 | 1 |   1 |          7
  8 | 2 |   1 |          8
  9 | 0 |   1 |          9
 10 | 1 |   1 |         10
 11 | 2 |   1 |         11
 12 | 0 |   1 |         12
 13 | 1 |   1 |         13
 14 | 2 |   1 |         14
 15 | 0 |   1 |         15
 16 | 1 |   1 |         16
 17 | 2 |   1 |         17
 18 | 0 |   1 |         18
 19 | 1 |   1 |         19
 20 | 2 |   1 |         20
    | 1 |   1 |         21
(21 rows)

                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Sort
   Output: a, b, (floor((avg(b) OVER (?)))), (dense_rank() OVER (?))
   Sort Key: r.a, r.b, (floor((avg(r.b) OVER (?)))), (dense_rank() OVER (?))
   ->  WindowAgg
         Output: a, b, floor((avg(b) OVER (?))), dense_rank() OVER (?)
         ->  Sort
               Output: (avg(b) OVER (?)), a, b
               Sort Key: r.a
               ->  WindowAgg
                     Output: avg(b) OVER (?), a, b
                     ->  PX Coordinator 6:1  (slice1; segments: 6)
                           Output: a, b
                           Merge Key: a, b
                           ->  Sort
                                 Output: a, b
                                 Sort Key: r.a DESC, r.b DESC
                                 ->  Partial Seq Scan on orca.r
                                       Output: a, b
 Optimizer: PolarDB PX Optimizer
(19 rows)

select lead(a) over(order by a) from orca.r order by 1;
 lead 
------
    2
    3
    4
    5
    6
    7
    8
    9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
     
     
(21 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 Result
   Output: (lead(a) OVER (?))
   ->  Sort
         Output: (lead(a) OVER (?)), a
         Sort Key: (lead(r.a) OVER (?))
         ->  WindowAgg
               Output: lead(a) OVER (?), a
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: a
                     Merge Key: a
                     ->  Sort
                           Output: a
                           Sort Key: r.a
                           ->  Partial Seq Scan on orca.r
                                 Output: a
 Optimizer: PolarDB PX Optimizer
(16 rows)

select lag(c,d) over(order by c,d) from orca.s order by 1;
 lag 
-----
   0
   0
   0
   0
   1
   1
   1
   1
   1
   2
   2
   2
   2
   2
   3
   3
   3
   3
   4
   4
   4
   4
   5
   5
   5
   5
   6
   6
   6
   6
(30 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 Result
   Output: (lag(c, d) OVER (?))
   ->  Sort
         Output: (lag(c, d) OVER (?)), c
         Sort Key: (lag(s.c, s.d) OVER (?))
         ->  WindowAgg
               Output: lag(c, d) OVER (?), c
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: c, d
                     Merge Key: c, d
                     ->  Sort
                           Output: c, d
                           Sort Key: s.c, s.d
                           ->  Partial Seq Scan on orca.s
                                 Output: c, d
 Optimizer: PolarDB PX Optimizer
(16 rows)

select lead(c,c+d,1000) over(order by c,d) from orca.s order by 1;
 lead 
------
    0
    0
    0
    1
    1
    1
    1
    2
    2
    2
    2
    2
    3
    3
    3
    4
    4
    4
    5
    5
    5
    6
    6
    6
 1000
 1000
 1000
 1000
 1000
 1000
(30 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 Result
   Output: (lead(c, (c + d), 1000) OVER (?))
   ->  Sort
         Output: (lead(c, (c + d), 1000) OVER (?)), c
         Sort Key: (lead(s.c, (s.c + s.d), 1000) OVER (?))
         ->  WindowAgg
               Output: lead(c, (c + d), 1000) OVER (?), c
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: c, d
                     Merge Key: c, d
                     ->  Sort
                           Output: c, d
                           Sort Key: s.c, s.d
                           ->  Partial Seq Scan on orca.s
                                 Output: c, d
 Optimizer: PolarDB PX Optimizer
(16 rows)

-- test normalization of window functions
create table orca_w1(a int, b int);
create table orca_w2(a int, b int);
create table orca_w3(a int, b text);
insert into orca_w1 select i, i from generate_series(1, 3) i;
insert into orca_w2 select i, i from generate_series(2, 4) i;
insert into orca_w3 select i, i from generate_series(3, 5) i;
-- outer ref in subquery in target list and window func in target list
select (select b from orca_w3 where a = orca_w1.a) as one, row_number() over(partition by orca_w1.a) as two from orca_w2, orca_w1;
 one | two 
-----+-----
     |   1
     |   2
     |   3
     |   1
     |   2
     |   3
 3   |   1
 3   |   2
 3   |   3
(9 rows)

                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1)), (row_number() OVER (?))
   ->  WindowAgg
         Output: (SubPlan 1), row_number() OVER (?)
         ->  Sort
               Output: orca_w1.a
               Sort Key: orca_w1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: orca_w1.a
                     Hash Key: orca_w1.a
                     ->  Nested Loop
                           Output: orca_w1.a
                           Join Filter: true
                           ->  Partial Seq Scan on orca.orca_w1
                                 Output: orca_w1.a
                           ->  Materialize
                                 ->  PX Broadcast 6:6  (slice3; segments: 6)
                                       ->  Partial Seq Scan on orca.orca_w2
         SubPlan 1
           ->  Full Seq Scan on orca.orca_w3
                 Output: orca_w3.b
                 Filter: (orca_w3.a = orca_w1.a)
 Optimizer: PolarDB PX Optimizer
(23 rows)

-- aggref in subquery with window func in target list
select orca_w1.a, (select sum(orca_w2.a) from orca_w2 where orca_w1.b = orca_w2.b), count(*), rank() over (order by orca_w1.b) from orca_w1 group by orca_w1.a, orca_w1.b order by orca_w1.a;
 a | sum | count | rank 
---+-----+-------+------
 1 |     |     1 |    1
 2 |   2 |     1 |    2
 3 |   3 |     1 |    3
(3 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Result
   Output: orca_w1.a, (sum(orca_w2.a)), (count()), (rank() OVER (?))
   ->  Sort
         Output: orca_w1.a, (sum(orca_w2.a)), (count()), (rank() OVER (?)), orca_w1.b
         Sort Key: orca_w1.a
         ->  WindowAgg
               Output: orca_w1.a, (sum(orca_w2.a)), (count()), rank() OVER (?), orca_w1.b
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: orca_w1.a, orca_w1.b, (count()), (sum(orca_w2.a))
                     Merge Key: orca_w1.b
                     ->  Result
                           Output: orca_w1.a, orca_w1.b, (count()), (sum(orca_w2.a))
                           ->  Sort
                                 Output: orca_w1.a, orca_w1.b, (count()), (sum(orca_w2.a))
                                 Sort Key: orca_w1.b
                                 ->  Hash Left Join
                                       Output: orca_w1.a, orca_w1.b, (count()), (sum(orca_w2.a))
                                       Hash Cond: (orca_w1.b = orca_w2.b)
                                       ->  PX Hash 6:6  (slice2; segments: 6)
                                             Output: orca_w1.a, orca_w1.b, (count())
                                             Hash Key: orca_w1.b
                                             ->  GroupAggregate
                                                   Output: orca_w1.a, orca_w1.b, count()
                                                   Group Key: orca_w1.a, orca_w1.b
                                                   ->  Sort
                                                         Output: orca_w1.a, orca_w1.b
                                                         Sort Key: orca_w1.a, orca_w1.b
                                                         ->  PX Hash 6:6  (slice3; segments: 6)
                                                               Output: orca_w1.a, orca_w1.b
                                                               Hash Key: orca_w1.a, orca_w1.b
                                                               ->  Partial Seq Scan on orca.orca_w1
                                                                     Output: orca_w1.a, orca_w1.b
                                       ->  Hash
                                             Output: (sum(orca_w2.a)), orca_w2.b
                                             ->  GroupAggregate
                                                   Output: sum(orca_w2.a), orca_w2.b
                                                   Group Key: orca_w2.b
                                                   ->  Sort
                                                         Output: orca_w2.a, orca_w2.b
                                                         Sort Key: orca_w2.b
                                                         ->  PX Hash 6:6  (slice4; segments: 6)
                                                               Output: orca_w2.a, orca_w2.b
                                                               Hash Key: orca_w2.b
                                                               ->  Partial Seq Scan on orca.orca_w2
                                                                     Output: orca_w2.a, orca_w2.b
 Optimizer: PolarDB PX Optimizer
(46 rows)

-- window function inside subquery inside target list with outer ref
select orca_w1.a, (select rank() over (order by orca_w1.b) from orca_w2 where orca_w1.b = orca_w2.b), count(*) from orca_w1 group by orca_w1.a, orca_w1.b order by orca_w1.a;
 a | rank | count 
---+------+-------
 1 |      |     1
 2 |    1 |     1
 3 |    1 |     1
(3 rows)

                              QUERY PLAN                              
----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: orca_w1.a, ((SubPlan 1)), (count())
   Merge Key: orca_w1.a
   ->  Result
         Output: orca_w1.a, (SubPlan 1), (count())
         ->  Sort
               Output: (count()), orca_w1.a, orca_w1.b
               Sort Key: orca_w1.a
               ->  GroupAggregate
                     Output: count(), orca_w1.a, orca_w1.b
                     Group Key: orca_w1.a, orca_w1.b
                     ->  Sort
                           Output: orca_w1.a, orca_w1.b
                           Sort Key: orca_w1.a, orca_w1.b
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: orca_w1.a, orca_w1.b
                                 Hash Key: orca_w1.a, orca_w1.b
                                 ->  Partial Seq Scan on orca.orca_w1
                                       Output: orca_w1.a, orca_w1.b
         SubPlan 1
           ->  WindowAgg
                 Output: rank() OVER (?)
                 ->  Full Seq Scan on orca.orca_w2
                       Filter: (orca_w1.b = orca_w2.b)
 Optimizer: PolarDB PX Optimizer
(25 rows)

-- window function with empty partition clause inside subquery inside target list with outer ref
select (select rank() over() from orca_w3 where a = orca_w1.a) as one, row_number() over(partition by orca_w1.a) as two from orca_w1, orca_w2;
 one | two 
-----+-----
     |   1
     |   2
     |   3
     |   1
     |   2
     |   3
   1 |   1
   1 |   2
   1 |   3
(9 rows)

                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1)), (row_number() OVER (?))
   ->  WindowAgg
         Output: (SubPlan 1), row_number() OVER (?)
         ->  Sort
               Output: orca_w1.a
               Sort Key: orca_w1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: orca_w1.a
                     Hash Key: orca_w1.a
                     ->  Nested Loop
                           Output: orca_w1.a
                           Join Filter: true
                           ->  Partial Seq Scan on orca.orca_w1
                                 Output: orca_w1.a
                           ->  Materialize
                                 ->  PX Broadcast 6:6  (slice3; segments: 6)
                                       ->  Partial Seq Scan on orca.orca_w2
         SubPlan 1
           ->  WindowAgg
                 Output: rank() OVER (?)
                 ->  Full Seq Scan on orca.orca_w3
                       Filter: (orca_w3.a = orca_w1.a)
 Optimizer: PolarDB PX Optimizer
(24 rows)

-- window function in IN clause
select (select a from orca_w3 where a = orca_w1.a) as one from orca_w1 where orca_w1.a IN (select rank() over(partition by orca_w1.a) + 1 from orca_w1, orca_w2);
 one 
-----
    
(1 row)

                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1))
   ->  Hash Join
         Output: (SubPlan 1)
         Hash Cond: (((rank() OVER (?) + 1)) = (orca_w1_1.a)::bigint)
         ->  GroupAggregate
               Output: ((rank() OVER (?) + 1))
               Group Key: ((rank() OVER (?) + 1))
               ->  Sort
                     Output: ((rank() OVER (?) + 1))
                     Sort Key: ((rank() OVER (?) + 1))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: ((rank() OVER (?) + 1))
                           Hash Key: ((rank() OVER (?) + 1))
                           ->  WindowAgg
                                 Output: (rank() OVER (?) + 1)
                                 ->  Sort
                                       Output: orca_w1.a
                                       Sort Key: orca_w1.a
                                       ->  PX Hash 6:6  (slice3; segments: 6)
                                             Output: orca_w1.a
                                             Hash Key: orca_w1.a
                                             ->  Nested Loop
                                                   Output: orca_w1.a
                                                   Join Filter: true
                                                   ->  Partial Seq Scan on orca.orca_w1
                                                         Output: orca_w1.a
                                                   ->  Materialize
                                                         ->  PX Broadcast 6:6  (slice4; segments: 6)
                                                               ->  Partial Seq Scan on orca.orca_w2
         ->  Hash
               Output: orca_w1_1.a
               ->  PX Hash 6:6  (slice5; segments: 6)
                     Output: orca_w1_1.a
                     Hash Key: (orca_w1_1.a)::bigint
                     ->  Partial Seq Scan on orca.orca_w1 orca_w1_1
                           Output: orca_w1_1.a
         SubPlan 1
           ->  Full Seq Scan on orca.orca_w3
                 Output: orca_w3.a
                 Filter: (orca_w3.a = orca_w1_1.a)
 Optimizer: PolarDB PX Optimizer
(42 rows)

-- window function in subquery inside target list with outer ref in partition clause
select (select rank() over(partition by orca_w2.a) from orca_w3 where a = orca_w1.a) as one, row_number() over(partition by orca_w1.a) as two from orca_w1, orca_w2 order by orca_w1.a;
 one | two 
-----+-----
     |   1
     |   2
     |   3
     |   1
     |   2
     |   3
   1 |   1
   1 |   2
   1 |   3
(9 rows)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Result
   Output: ((SubPlan 1)), (row_number() OVER (?))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: ((SubPlan 1)), (row_number() OVER (?)), orca_w1.a
         Merge Key: orca_w1.a
         ->  WindowAgg
               Output: (SubPlan 1), row_number() OVER (?), orca_w1.a
               ->  Sort
                     Output: orca_w1.a
                     Sort Key: orca_w1.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: orca_w1.a
                           Hash Key: orca_w1.a
                           ->  Nested Loop
                                 Output: orca_w1.a
                                 Join Filter: true
                                 ->  Partial Seq Scan on orca.orca_w1
                                       Output: orca_w1.a
                                 ->  Materialize
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             ->  Partial Seq Scan on orca.orca_w2
               SubPlan 1
                 ->  WindowAgg
                       Output: rank() OVER (?)
                       ->  Full Seq Scan on orca.orca_w3
                             Filter: (orca_w3.a = orca_w1.a)
 Optimizer: PolarDB PX Optimizer
(27 rows)

-- correlated subquery in target list
select (select a+1 from (select a from orca_w2 where orca_w1.a=orca_w2.a) sq(a)) as one, row_number() over(partition by orca_w1.a) as two from orca_w1;
 one | two 
-----+-----
     |   1
   3 |   1
   4 |   1
(3 rows)

                        QUERY PLAN                        
----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1)), (row_number() OVER (?))
   ->  WindowAgg
         Output: (SubPlan 1), row_number() OVER (?)
         ->  Sort
               Output: orca_w1.a
               Sort Key: orca_w1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: orca_w1.a
                     Hash Key: orca_w1.a
                     ->  Partial Seq Scan on orca.orca_w1
                           Output: orca_w1.a
         SubPlan 1
           ->  Result
                 Output: (orca_w2.a + 1)
                 ->  Full Seq Scan on orca.orca_w2
                       Output: orca_w2.a
                       Filter: (orca_w1.a = orca_w2.a)
 Optimizer: PolarDB PX Optimizer
(19 rows)

-- correlated subquery in target list, mismatching varattnos
select (select a+1 from (select a from orca_w2 where sq2.a=orca_w2.a) sq1(a)) as one, row_number() over(partition by sq2.a) as two from (select 1,1,1,a from orca_w1) sq2(x,y,z,a);
 one | two 
-----+-----
     |   1
   3 |   1
   4 |   1
(3 rows)

                        QUERY PLAN                        
----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1)), (row_number() OVER (?))
   ->  WindowAgg
         Output: (SubPlan 1), row_number() OVER (?)
         ->  Sort
               Output: orca_w1.a
               Sort Key: orca_w1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: orca_w1.a
                     Hash Key: orca_w1.a
                     ->  Partial Seq Scan on orca.orca_w1
                           Output: orca_w1.a
         SubPlan 1
           ->  Result
                 Output: (orca_w2.a + 1)
                 ->  Full Seq Scan on orca.orca_w2
                       Output: orca_w2.a
                       Filter: (orca_w1.a = orca_w2.a)
 Optimizer: PolarDB PX Optimizer
(19 rows)

-- cte in scalar subquery
with x as (select a, b from orca_w1)
select (select count(*) from x) as one, rank() over(partition by a) as rank_within_parent from x order by a desc;
 one | rank_within_parent 
-----+--------------------
   3 |                  1
   3 |                  1
   3 |                  1
(3 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Result
   Output: (COALESCE((count()), '0'::bigint)), (rank() OVER (?))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (COALESCE((count()), '0'::bigint)), (rank() OVER (?)), share0_ref3.a
         Merge Key: share0_ref3.a
         ->  Sequence
               Output: (COALESCE((count()), '0'::bigint)), (rank() OVER (?)), share0_ref3.a
               ->  Shared Scan (Producer; slice1; share0)
                     Output: share0_ref1.a, share0_ref1.b
                     ->  Sort
                           Output: orca_w1.a, orca_w1.b
                           Sort Key: orca_w1.a DESC
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: orca_w1.a, orca_w1.b
                                 Hash Key: orca_w1.a
                                 ->  Partial Seq Scan on orca.orca_w1
                                       Output: orca_w1.a, orca_w1.b
               ->  Nested Loop Left Join
                     Output: COALESCE((count()), '0'::bigint), (rank() OVER (?)), share0_ref3.a
                     Join Filter: true
                     ->  Sort
                           Output: (rank() OVER (?)), share0_ref3.a
                           Sort Key: share0_ref3.a DESC
                           ->  WindowAgg
                                 Output: rank() OVER (?), share0_ref3.a
                                 ->  Sort
                                       Output: share0_ref3.a, share0_ref3.b
                                       Sort Key: share0_ref3.a
                                       ->  Shared Scan (Producer; slice1; share0)
                                             Output: share0_ref3.a, share0_ref3.b
                     ->  Materialize
                           Output: (count())
                           ->  PX Broadcast 1:6  (slice3)
                                 Output: (count())
                                 ->  Aggregate
                                       Output: count()
                                       ->  PX Coordinator 6:1  (slice4; segments: 6)
                                             ->  Result
                                                   ->  Shared Scan (Consumer; slice4; share0)
                                                         Output: share0_ref2.a, share0_ref2.b
 Optimizer: PolarDB PX Optimizer
(41 rows)

-- window function in subquery inside target list with outer ref in order clause
select (select rank() over(order by orca_w2.a) from orca_w3 where a = orca_w1.a) as one, row_number() over(partition by orca_w1.a) as two from orca_w1, orca_w2 order by orca_w1.a;
 one | two 
-----+-----
     |   1
     |   2
     |   3
     |   1
     |   2
     |   3
   1 |   1
   1 |   2
   1 |   3
(9 rows)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Result
   Output: ((SubPlan 1)), (row_number() OVER (?))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: ((SubPlan 1)), (row_number() OVER (?)), orca_w1.a
         Merge Key: orca_w1.a
         ->  WindowAgg
               Output: (SubPlan 1), row_number() OVER (?), orca_w1.a
               ->  Sort
                     Output: orca_w1.a
                     Sort Key: orca_w1.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: orca_w1.a
                           Hash Key: orca_w1.a
                           ->  Nested Loop
                                 Output: orca_w1.a
                                 Join Filter: true
                                 ->  Partial Seq Scan on orca.orca_w1
                                       Output: orca_w1.a
                                 ->  Materialize
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             ->  Partial Seq Scan on orca.orca_w2
               SubPlan 1
                 ->  WindowAgg
                       Output: rank() OVER (?)
                       ->  Full Seq Scan on orca.orca_w3
                             Filter: (orca_w3.a = orca_w1.a)
 Optimizer: PolarDB PX Optimizer
(27 rows)

-- window function with outer ref in arguments
select (select sum(orca_w1.a + a) over(order by b) + 1 from orca_w2 where orca_w1.a = orca_w2.a) from orca_w1 order by orca_w1.a;
 ?column? 
----------
         
        5
        7
(3 rows)

                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Result
   Output: ((SubPlan 1))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: ((SubPlan 1)), orca_w1.a
         Merge Key: orca_w1.a
         ->  Result
               Output: (SubPlan 1), orca_w1.a
               ->  Sort
                     Output: orca_w1.a
                     Sort Key: orca_w1.a
                     ->  Partial Seq Scan on orca.orca_w1
                           Output: orca_w1.a
               SubPlan 1
                 ->  WindowAgg
                       Output: (sum((orca_w1.a + orca_w2.a)) OVER (?) + 1)
                       ->  Sort
                             Output: orca_w2.a, orca_w2.b
                             Sort Key: orca_w2.b
                             ->  Full Seq Scan on orca.orca_w2
                                   Output: orca_w2.a, orca_w2.b
                                   Filter: (orca_w1.a = orca_w2.a)
 Optimizer: PolarDB PX Optimizer
(22 rows)

-- window function with outer ref in window clause and arguments 
select (select sum(orca_w1.a + a) over(order by b + orca_w1.a) + 1 from orca_w2 where orca_w1.a = orca_w2.a) from orca_w1 order by orca_w1.a;
 ?column? 
----------
         
        5
        7
(3 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Result
   Output: ((SubPlan 1))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: ((SubPlan 1)), orca_w1.a
         Merge Key: orca_w1.a
         ->  Result
               Output: (SubPlan 1), orca_w1.a
               ->  Sort
                     Output: orca_w1.a
                     Sort Key: orca_w1.a
                     ->  Partial Seq Scan on orca.orca_w1
                           Output: orca_w1.a
               SubPlan 1
                 ->  WindowAgg
                       Output: (sum((orca_w1.a + orca_w2.a)) OVER (?) + 1)
                       ->  Sort
                             Output: ((orca_w2.b + orca_w1.a)), orca_w2.a
                             Sort Key: ((orca_w2.b + orca_w1.a))
                             ->  Full Seq Scan on orca.orca_w2
                                   Output: (orca_w2.b + orca_w1.a), orca_w2.a
                                   Filter: (orca_w1.a = orca_w2.a)
 Optimizer: PolarDB PX Optimizer
(22 rows)

-- cte
with x as (select a, b from orca.r)
select rank() over(partition by a, case when b = 0 then a+b end order by b asc) as rank_within_parent from x order by a desc ,case when a+b = 0 then a end ,b;
 rank_within_parent 
--------------------
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
                  1
(21 rows)

                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Result
   Output: (rank() OVER (?))
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (rank() OVER (?)), a, b, (CASE WHEN ((a + b) = 0) THEN a ELSE NULL::integer END)
         Merge Key: a, (CASE WHEN ((a + b) = 0) THEN a ELSE NULL::integer END), b
         ->  Sort
               Output: (rank() OVER (?)), a, b, (CASE WHEN ((a + b) = 0) THEN a ELSE NULL::integer END)
               Sort Key: r.a DESC, (CASE WHEN ((r.a + r.b) = 0) THEN r.a ELSE NULL::integer END), r.b
               ->  Sort
                     Output: (rank() OVER (?)), a, b, (CASE WHEN ((a + b) = 0) THEN a ELSE NULL::integer END)
                     Sort Key: r.a DESC, (CASE WHEN ((r.a + r.b) = 0) THEN r.a ELSE NULL::integer END), r.b
                     ->  WindowAgg
                           Output: rank() OVER (?), a, b, CASE WHEN ((a + b) = 0) THEN a ELSE NULL::integer END
                           ->  Sort
                                 Output: a, b, (CASE WHEN (b = 0) THEN (a + b) ELSE NULL::integer END)
                                 Sort Key: r.a, (CASE WHEN (r.b = 0) THEN (r.a + r.b) ELSE NULL::integer END), r.b
                                 ->  PX Hash 6:6  (slice2; segments: 6)
                                       Output: a, b, (CASE WHEN (b = 0) THEN (a + b) ELSE NULL::integer END)
                                       Hash Key: a, (CASE WHEN (b = 0) THEN (a + b) ELSE NULL::integer END)
                                       ->  Partial Seq Scan on orca.r
                                             Output: a, b, CASE WHEN (b = 0) THEN (a + b) ELSE NULL::integer END
 Optimizer: PolarDB PX Optimizer
(22 rows)

-- alias
select foo.d from orca.foo full join orca.bar on (foo.d = bar.a) group by d;
 d  
----
 29
  4
 34
  0
 32
 10
  9
  7
 35
 38
 15
  6
 26
 12
 39
 24
 19
 36
 25
 31
 30
 21
 14
  3
 17
 37
 28
 22
 20
 33
 13
  1
  5
 18
  2
 16
 27
 23
 11
  8
(40 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.d
   ->  GroupAggregate
         Output: foo.d
         Group Key: foo.d
         ->  Sort
               Output: foo.d
               Sort Key: foo.d
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.d
                     Hash Key: foo.d
                     ->  Merge Full Join
                           Output: foo.d
                           Merge Cond: (foo.d = bar.a)
                           ->  Sort
                                 Output: foo.d
                                 Sort Key: foo.d
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: foo.d
                                       Hash Key: foo.d
                                       ->  Partial Seq Scan on orca.foo
                                             Output: foo.d
                           ->  Sort
                                 Output: bar.a
                                 Sort Key: bar.a
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: bar.a
                                       Hash Key: bar.a
                                       ->  Partial Seq Scan on orca.bar
                                             Output: bar.a
 Optimizer: PolarDB PX Optimizer
(31 rows)

select 1 as v from orca.foo full join orca.bar on (foo.d = bar.a) group by d;
 v 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(40 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Result
   Output: 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  GroupAggregate
               Group Key: foo.d
               ->  Sort
                     Output: foo.d
                     Sort Key: foo.d
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: foo.d
                           Hash Key: foo.d
                           ->  Merge Full Join
                                 Output: foo.d
                                 Merge Cond: (foo.d = bar.a)
                                 ->  Sort
                                       Output: foo.d
                                       Sort Key: foo.d
                                       ->  PX Hash 6:6  (slice3; segments: 6)
                                             Output: foo.d
                                             Hash Key: foo.d
                                             ->  Partial Seq Scan on orca.foo
                                                   Output: foo.d
                                 ->  Sort
                                       Output: bar.a
                                       Sort Key: bar.a
                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                             Output: bar.a
                                             Hash Key: bar.a
                                             ->  Partial Seq Scan on orca.bar
                                                   Output: bar.a
 Optimizer: PolarDB PX Optimizer
(31 rows)

select * from orca.r where a in (select count(*)+1 as v from orca.foo full join orca.bar on (foo.d = bar.a) group by d+r.b);
 a | b 
---+---
 2 | 2
(1 row)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, r.b
   ->  Partial Seq Scan on orca.r
         Output: r.a, r.b
         Filter: (SubPlan 1)
         SubPlan 1
           ->  HashAggregate
                 Output: (count() + 1)
                 Group Key: (foo.d + r.b)
                 ->  Result
                       Output: (foo.d + r.b)
                       ->  Materialize
                             Output: foo.d
                             ->  PX Broadcast 6:6  (slice2; segments: 6)
                                   Output: foo.d
                                   ->  Merge Full Join
                                         Output: foo.d
                                         Merge Cond: (foo.d = bar.a)
                                         ->  Sort
                                               Output: foo.d
                                               Sort Key: foo.d
                                               ->  PX Hash 6:6  (slice3; segments: 6)
                                                     Output: foo.d
                                                     Hash Key: foo.d
                                                     ->  Partial Seq Scan on orca.foo
                                                           Output: foo.d
                                         ->  Sort
                                               Output: bar.a
                                               Sort Key: bar.a
                                               ->  PX Hash 6:6  (slice4; segments: 6)
                                                     Output: bar.a
                                                     Hash Key: bar.a
                                                     ->  Partial Seq Scan on orca.bar
                                                           Output: bar.a
 Optimizer: PolarDB PX Optimizer
(35 rows)

select * from orca.r where r.a in (select d+r.b+1 as v from orca.foo full join orca.bar on (foo.d = bar.a) group by d+r.b) order by r.a, r.b;
 a  | b 
----+---
  3 | 0
  4 | 1
  5 | 2
  6 | 0
  7 | 1
  8 | 2
  9 | 0
 10 | 1
 11 | 2
 12 | 0
 13 | 1
 14 | 2
 15 | 0
 16 | 1
 17 | 2
 18 | 0
 19 | 1
 20 | 2
(18 rows)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  Query-to-DXL Translation: No attribute entry found due to incorrect normalization of query
drop table if exists orca.rcte;
NOTICE:  table "rcte" does not exist, skipping
create table orca.rcte(a int, b int, c int);
insert into orca.rcte select i, i%2, i%3 from generate_series(1,40)i;
with x as (select * from orca.rcte where a < 10) select * from x x1, x x2;
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 1 | 2 | 0 | 2
 1 | 1 | 1 | 3 | 1 | 0
 1 | 1 | 1 | 4 | 0 | 1
 1 | 1 | 1 | 5 | 1 | 2
 1 | 1 | 1 | 6 | 0 | 0
 1 | 1 | 1 | 7 | 1 | 1
 1 | 1 | 1 | 8 | 0 | 2
 1 | 1 | 1 | 9 | 1 | 0
 2 | 0 | 2 | 1 | 1 | 1
 2 | 0 | 2 | 2 | 0 | 2
 2 | 0 | 2 | 3 | 1 | 0
 2 | 0 | 2 | 4 | 0 | 1
 2 | 0 | 2 | 5 | 1 | 2
 2 | 0 | 2 | 6 | 0 | 0
 2 | 0 | 2 | 7 | 1 | 1
 2 | 0 | 2 | 8 | 0 | 2
 2 | 0 | 2 | 9 | 1 | 0
 3 | 1 | 0 | 1 | 1 | 1
 3 | 1 | 0 | 2 | 0 | 2
 3 | 1 | 0 | 3 | 1 | 0
 3 | 1 | 0 | 4 | 0 | 1
 3 | 1 | 0 | 5 | 1 | 2
 3 | 1 | 0 | 6 | 0 | 0
 3 | 1 | 0 | 7 | 1 | 1
 3 | 1 | 0 | 8 | 0 | 2
 3 | 1 | 0 | 9 | 1 | 0
 4 | 0 | 1 | 1 | 1 | 1
 4 | 0 | 1 | 2 | 0 | 2
 4 | 0 | 1 | 3 | 1 | 0
 4 | 0 | 1 | 4 | 0 | 1
 4 | 0 | 1 | 5 | 1 | 2
 4 | 0 | 1 | 6 | 0 | 0
 4 | 0 | 1 | 7 | 1 | 1
 4 | 0 | 1 | 8 | 0 | 2
 4 | 0 | 1 | 9 | 1 | 0
 5 | 1 | 2 | 1 | 1 | 1
 5 | 1 | 2 | 2 | 0 | 2
 5 | 1 | 2 | 3 | 1 | 0
 5 | 1 | 2 | 4 | 0 | 1
 5 | 1 | 2 | 5 | 1 | 2
 5 | 1 | 2 | 6 | 0 | 0
 5 | 1 | 2 | 7 | 1 | 1
 5 | 1 | 2 | 8 | 0 | 2
 5 | 1 | 2 | 9 | 1 | 0
 6 | 0 | 0 | 1 | 1 | 1
 6 | 0 | 0 | 2 | 0 | 2
 6 | 0 | 0 | 3 | 1 | 0
 6 | 0 | 0 | 4 | 0 | 1
 6 | 0 | 0 | 5 | 1 | 2
 6 | 0 | 0 | 6 | 0 | 0
 6 | 0 | 0 | 7 | 1 | 1
 6 | 0 | 0 | 8 | 0 | 2
 6 | 0 | 0 | 9 | 1 | 0
 7 | 1 | 1 | 1 | 1 | 1
 7 | 1 | 1 | 2 | 0 | 2
 7 | 1 | 1 | 3 | 1 | 0
 7 | 1 | 1 | 4 | 0 | 1
 7 | 1 | 1 | 5 | 1 | 2
 7 | 1 | 1 | 6 | 0 | 0
 7 | 1 | 1 | 7 | 1 | 1
 7 | 1 | 1 | 8 | 0 | 2
 7 | 1 | 1 | 9 | 1 | 0
 8 | 0 | 2 | 1 | 1 | 1
 8 | 0 | 2 | 2 | 0 | 2
 8 | 0 | 2 | 3 | 1 | 0
 8 | 0 | 2 | 4 | 0 | 1
 8 | 0 | 2 | 5 | 1 | 2
 8 | 0 | 2 | 6 | 0 | 0
 8 | 0 | 2 | 7 | 1 | 1
 8 | 0 | 2 | 8 | 0 | 2
 8 | 0 | 2 | 9 | 1 | 0
 9 | 1 | 0 | 1 | 1 | 1
 9 | 1 | 0 | 2 | 0 | 2
 9 | 1 | 0 | 3 | 1 | 0
 9 | 1 | 0 | 4 | 0 | 1
 9 | 1 | 0 | 5 | 1 | 2
 9 | 1 | 0 | 6 | 0 | 0
 9 | 1 | 0 | 7 | 1 | 1
 9 | 1 | 0 | 8 | 0 | 2
 9 | 1 | 0 | 9 | 1 | 0
(81 rows)

                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
   ->  Sequence
         Output: share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  Partial Seq Scan on orca.rcte
                     Output: rcte.a, rcte.b, rcte.c
                     Filter: (rcte.a < 10)
         ->  Nested Loop
               Output: share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
               Join Filter: true
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
                     ->  Shared Scan (Consumer; slice2; share0)
                           Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
               ->  Shared Scan (Producer; slice1; share0)
                     Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
 Optimizer: PolarDB PX Optimizer
(19 rows)

with x as (select * from orca.rcte where a < 10) select * from x x1, x x2 where x2.a = x1.b;
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 | 1 | 1 | 1 | 1
 3 | 1 | 0 | 1 | 1 | 1
 5 | 1 | 2 | 1 | 1 | 1
 7 | 1 | 1 | 1 | 1 | 1
 9 | 1 | 0 | 1 | 1 | 1
(5 rows)

                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
   ->  Sequence
         Output: share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  Partial Seq Scan on orca.rcte
                     Output: rcte.a, rcte.b, rcte.c
                     Filter: ((rcte.a < 10) AND ((rcte.b < 10) OR (rcte.a < 10)))
         ->  Hash Join
               Output: share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
               Hash Cond: (share0_ref3.b = share0_ref2.a)
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
                     Hash Key: share0_ref3.b
                     ->  Result
                           Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
                           Filter: (share0_ref3.b < 10)
                           ->  Shared Scan (Consumer; slice2; share0)
                                 Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
               ->  Hash
                     Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
                           Hash Key: share0_ref2.a
                           ->  Result
                                 Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
                                 Filter: (share0_ref2.a < 10)
                                 ->  Shared Scan (Consumer; slice3; share0)
                                       Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
 Optimizer: PolarDB PX Optimizer
(31 rows)

with x as (select * from orca.rcte where a < 10) select a from x union all select b from x;
 a 
---
 1
 2
 3
 4
 5
 6
 7
 8
 9
 1
 0
 1
 0
 1
 0
 1
 0
 1
(18 rows)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref2.a
   ->  Sequence
         Output: share0_ref2.a
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  Partial Seq Scan on orca.rcte
                     Output: rcte.a, rcte.b, rcte.c
                     Filter: (rcte.a < 10)
         ->  Append
               ->  Result
                     Output: share0_ref2.a
                     ->  Shared Scan (Producer; slice1; share0)
                           Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
               ->  Result
                     Output: share0_ref3.b
                     ->  Shared Scan (Producer; slice1; share0)
                           Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
 Optimizer: PolarDB PX Optimizer
(19 rows)

with x as (select * from orca.rcte where a < 10) select * from x x1 where x1.b = any (select x2.a from x x2 group by x2.a);
 a | b | c 
---+---+---
 1 | 1 | 1
 3 | 1 | 0
 5 | 1 | 2
 7 | 1 | 1
 9 | 1 | 0
(5 rows)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
   ->  Sequence
         Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: rcte.a, rcte.b, rcte.c
                     Hash Key: rcte.b
                     ->  Partial Seq Scan on orca.rcte
                           Output: rcte.a, rcte.b, rcte.c
                           Filter: (rcte.a < 10)
         ->  Hash Semi Join
               Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
               Hash Cond: (share0_ref3.b = share0_ref2.a)
               ->  Shared Scan (Producer; slice1; share0)
                     Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
               ->  Hash
                     Output: share0_ref2.a
                     ->  PX Hash 6:6  (slice3; segments: 6)
                           Output: share0_ref2.a
                           Hash Key: share0_ref2.a
                           ->  Result
                                 Output: share0_ref2.a
                                 ->  Shared Scan (Consumer; slice3; share0)
                                       Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
 Optimizer: PolarDB PX Optimizer
(27 rows)

with x as (select * from orca.rcte where a < 10) select * from x x1 where x1.b = all (select x2.a from x x2 group by x2.a);
 a | b | c 
---+---+---
(0 rows)

                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sequence
   Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
   ->  Shared Scan (Producer; slice0; share0)
         Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: rcte.a, rcte.b, rcte.c
               ->  Partial Seq Scan on orca.rcte
                     Output: rcte.a, rcte.b, rcte.c
                     Filter: (rcte.a < 10)
   ->  Result
         Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
         Filter: (SubPlan 1)
         ->  Shared Scan (Producer; slice0; share0)
               Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
         SubPlan 1
           ->  Result
                 Output: true
                 Filter: ((CASE WHEN (sum((CASE WHEN (share0_ref3.b <> share0_ref1.a) THEN 1 ELSE 0 END)) IS NULL) THEN true WHEN (sum((CASE WHEN (share0_ref1.a IS NULL) THEN 1 ELSE 0 END)) > '0'::bigint) THEN NULL::boolean WHEN (share0_ref3.b IS NULL) THEN NULL::boolean WHEN (sum((CASE WHEN (share0_ref3.b <> share0_ref1.a) THEN 1 ELSE 0 END)) = '0'::bigint) THEN true ELSE false END) = true)
                 ->  Aggregate
                       Output: CASE WHEN (sum((CASE WHEN (share0_ref3.b <> share0_ref1.a) THEN 1 ELSE 0 END)) IS NULL) THEN true WHEN (sum((CASE WHEN (share0_ref1.a IS NULL) THEN 1 ELSE 0 END)) > '0'::bigint) THEN NULL::boolean WHEN (share0_ref3.b IS NULL) THEN NULL::boolean WHEN (sum((CASE WHEN (share0_ref3.b <> share0_ref1.a) THEN 1 ELSE 0 END)) = '0'::bigint) THEN true ELSE false END
                       ->  Result
                             Output: CASE WHEN (share0_ref3.b <> share0_ref1.a) THEN 1 ELSE 0 END, CASE WHEN (share0_ref1.a IS NULL) THEN 1 ELSE 0 END
                             ->  Materialize
                                   Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
                                   ->  Shared Scan (Producer; slice0; share0)
                                         Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
 Optimizer: PolarDB PX Optimizer
(27 rows)

with x as (select * from orca.rcte where a < 10) select * from x x1, x x2, x x3 where x2.a = x1.b and x3.b = x2.b                                                                                   ;
 a | b | c | a | b | c | a | b | c 
---+---+---+---+---+---+---+---+---
 1 | 1 | 1 | 1 | 1 | 1 | 9 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1 | 7 | 1 | 1
 1 | 1 | 1 | 1 | 1 | 1 | 5 | 1 | 2
 1 | 1 | 1 | 1 | 1 | 1 | 3 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 3 | 1 | 0 | 1 | 1 | 1 | 9 | 1 | 0
 3 | 1 | 0 | 1 | 1 | 1 | 7 | 1 | 1
 3 | 1 | 0 | 1 | 1 | 1 | 5 | 1 | 2
 3 | 1 | 0 | 1 | 1 | 1 | 3 | 1 | 0
 3 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1
 5 | 1 | 2 | 1 | 1 | 1 | 9 | 1 | 0
 5 | 1 | 2 | 1 | 1 | 1 | 7 | 1 | 1
 5 | 1 | 2 | 1 | 1 | 1 | 5 | 1 | 2
 5 | 1 | 2 | 1 | 1 | 1 | 3 | 1 | 0
 5 | 1 | 2 | 1 | 1 | 1 | 1 | 1 | 1
 7 | 1 | 1 | 1 | 1 | 1 | 9 | 1 | 0
 7 | 1 | 1 | 1 | 1 | 1 | 7 | 1 | 1
 7 | 1 | 1 | 1 | 1 | 1 | 5 | 1 | 2
 7 | 1 | 1 | 1 | 1 | 1 | 3 | 1 | 0
 7 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
 9 | 1 | 0 | 1 | 1 | 1 | 9 | 1 | 0
 9 | 1 | 0 | 1 | 1 | 1 | 7 | 1 | 1
 9 | 1 | 0 | 1 | 1 | 1 | 5 | 1 | 2
 9 | 1 | 0 | 1 | 1 | 1 | 3 | 1 | 0
 9 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1
(25 rows)

                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref4.a, share0_ref4.b, share0_ref4.c, share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
   ->  Sequence
         Output: share0_ref4.a, share0_ref4.b, share0_ref4.c, share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: rcte.a, rcte.b, rcte.c
                     Hash Key: rcte.b
                     ->  Partial Seq Scan on orca.rcte
                           Output: rcte.a, rcte.b, rcte.c
                           Filter: (rcte.a < 10)
         ->  Hash Join
               Output: share0_ref4.a, share0_ref4.b, share0_ref4.c, share0_ref3.a, share0_ref3.b, share0_ref3.c, share0_ref2.a, share0_ref2.b, share0_ref2.c
               Hash Cond: (share0_ref3.b = share0_ref2.b)
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: share0_ref4.a, share0_ref4.b, share0_ref4.c, share0_ref3.a, share0_ref3.b, share0_ref3.c
                     Hash Key: share0_ref3.b
                     ->  Hash Join
                           Output: share0_ref4.a, share0_ref4.b, share0_ref4.c, share0_ref3.a, share0_ref3.b, share0_ref3.c
                           Hash Cond: (share0_ref4.b = share0_ref3.a)
                           ->  Result
                                 Output: share0_ref4.a, share0_ref4.b, share0_ref4.c
                                 Filter: (share0_ref4.b < 10)
                                 ->  Shared Scan (Consumer; slice3; share0)
                                       Output: share0_ref4.a, share0_ref4.b, share0_ref4.c
                           ->  Hash
                                 Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
                                       Hash Key: share0_ref3.a
                                       ->  Result
                                             Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
                                             Filter: (share0_ref3.a < 10)
                                             ->  Shared Scan (Consumer; slice4; share0)
                                                   Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
               ->  Hash
                     Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
                     ->  Shared Scan (Producer; slice1; share0)
                           Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
 Optimizer: PolarDB PX Optimizer
(41 rows)

with x as (select * from orca.rcte where a < 10) select * from x x2 where x2.b < (select avg(b) from x x1);
 a | b | c 
---+---+---
 2 | 0 | 2
 4 | 0 | 1
 6 | 0 | 0
 8 | 0 | 2
(4 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
   ->  Sequence
         Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  Partial Seq Scan on orca.rcte
                     Output: rcte.a, rcte.b, rcte.c
                     Filter: (rcte.a < 10)
         ->  Nested Loop
               Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
               Join Filter: ((share0_ref2.b)::numeric < (avg(share0_ref3.b)))
               ->  PX Broadcast 1:6  (slice2)
                     Output: (avg(share0_ref3.b))
                     ->  Finalize Aggregate
                           Output: avg(share0_ref3.b)
                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                 Output: (PARTIAL avg(share0_ref3.b))
                                 ->  Partial Aggregate
                                       Output: PARTIAL avg(share0_ref3.b)
                                       ->  Shared Scan (Consumer; slice3; share0)
                                             Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
               ->  Shared Scan (Producer; slice1; share0)
                     Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
 Optimizer: PolarDB PX Optimizer
(25 rows)

with x as (select r.a from orca.r, orca.s  where r.a < 10 and s.d < 10 and r.a = s.d) select * from x x1, x x2;
 a | a 
---+---
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
(225 rows)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref3.a, share0_ref2.a
   ->  Sequence
         Output: share0_ref3.a, share0_ref2.a
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a
               ->  Hash Join
                     Output: r.a
                     Hash Cond: (s.d = r.a)
                     ->  Partial Seq Scan on orca.s
                           Output: s.d
                           Filter: (s.d < 10)
                     ->  Hash
                           Output: r.a
                           ->  PX Broadcast 6:6  (slice2; segments: 6)
                                 Output: r.a
                                 ->  Partial Index Scan using r_a on orca.r
                                       Output: r.a
                                       Index Cond: (r.a < 10)
         ->  Nested Loop
               Output: share0_ref3.a, share0_ref2.a
               Join Filter: true
               ->  PX Broadcast 6:6  (slice3; segments: 6)
                     Output: share0_ref3.a
                     ->  Shared Scan (Consumer; slice3; share0)
                           Output: share0_ref3.a
               ->  Materialize
                     Output: share0_ref2.a
                     ->  Shared Scan (Producer; slice1; share0)
                           Output: share0_ref2.a
 Optimizer: PolarDB PX Optimizer
(31 rows)

with x as (select r.a from orca.r, orca.s  where r.a < 10 and s.c < 10 and r.a = s.c) select * from x x1, x x2;
 a | a 
---+---
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 3 | 3
 3 | 4
 3 | 5
 3 | 6
 3 | 1
 3 | 2
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 4 | 3
 4 | 4
 4 | 5
 4 | 6
 4 | 1
 4 | 2
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 5 | 3
 5 | 4
 5 | 5
 5 | 6
 5 | 1
 5 | 2
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 6 | 3
 6 | 4
 6 | 5
 6 | 6
 6 | 1
 6 | 2
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 1 | 3
 1 | 4
 1 | 5
 1 | 6
 1 | 1
 1 | 2
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
 2 | 3
 2 | 4
 2 | 5
 2 | 6
 2 | 1
 2 | 2
(676 rows)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref3.a, share0_ref2.a
   ->  Sequence
         Output: share0_ref3.a, share0_ref2.a
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a
               ->  Hash Join
                     Output: r.a
                     Hash Cond: (s.c = r.a)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: s.c
                           Hash Key: s.c
                           ->  Partial Seq Scan on orca.s
                                 Output: s.c
                                 Filter: (s.c < 10)
                     ->  Hash
                           Output: r.a
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: r.a
                                 Hash Key: r.a
                                 ->  Partial Index Scan using r_a on orca.r
                                       Output: r.a
                                       Index Cond: (r.a < 10)
         ->  Nested Loop
               Output: share0_ref3.a, share0_ref2.a
               Join Filter: true
               ->  PX Broadcast 6:6  (slice4; segments: 6)
                     Output: share0_ref3.a
                     ->  Shared Scan (Consumer; slice4; share0)
                           Output: share0_ref3.a
               ->  Materialize
                     Output: share0_ref2.a
                     ->  Shared Scan (Producer; slice1; share0)
                           Output: share0_ref2.a
 Optimizer: PolarDB PX Optimizer
(35 rows)

with x as (select * from orca.rcte where a < 10) (select a from x x2) union all (select max(a) from x x1);
 a 
---
 1
 2
 3
 4
 5
 6
 7
 8
 9
 9
(10 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref2.a
   ->  Sequence
         Output: share0_ref2.a
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b, share0_ref1.c
               ->  Partial Seq Scan on orca.rcte
                     Output: rcte.a, rcte.b, rcte.c
                     Filter: (rcte.a < 10)
         ->  Append
               ->  Result
                     Output: share0_ref2.a
                     ->  Shared Scan (Producer; slice1; share0)
                           Output: share0_ref2.a, share0_ref2.b, share0_ref2.c
               ->  PX Hash 1:6  (slice2)
                     Output: (max(share0_ref3.a))
                     ->  Finalize Aggregate
                           Output: max(share0_ref3.a)
                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                 Output: (PARTIAL max(share0_ref3.a))
                                 ->  Partial Aggregate
                                       Output: PARTIAL max(share0_ref3.a)
                                       ->  Shared Scan (Consumer; slice3; share0)
                                             Output: share0_ref3.a, share0_ref3.b, share0_ref3.c
 Optimizer: PolarDB PX Optimizer
(25 rows)

with x as (select * from orca.r) select * from x order by a;
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 0
  4 | 1
  5 | 2
  6 | 0
  7 | 1
  8 | 2
  9 | 0
 10 | 1
 11 | 2
 12 | 0
 13 | 1
 14 | 2
 15 | 0
 16 | 1
 17 | 2
 18 | 0
 19 | 1
 20 | 2
    | 1
(21 rows)

                  QUERY PLAN                  
----------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   Merge Key: a
   ->  Sort
         Output: a, b
         Sort Key: r.a
         ->  Sort
               Output: a, b
               Sort Key: r.a
               ->  Partial Seq Scan on orca.r
                     Output: a, b
 Optimizer: PolarDB PX Optimizer
(12 rows)

-- with x as (select * from orca.rcte where a < 10) select * from x x1, x x2 where x2.a = x1.b limit 1;
-- correlated execution
select (select 1 union select 2);
ERROR:  more than one row returned by a subquery used as an expression
select (select generate_series(1,5));
ERROR:  more than one row returned by a subquery used as an expression
select (select a from orca.foo inner1 where inner1.a=outer1.a  union select b from orca.foo inner2 where inner2.b=outer1.b) from orca.foo outer1;
ERROR:  more than one row returned by a subquery used as an expression
select (select generate_series(1,1)) as series;
 series 
--------
      1
(1 row)

select generate_series(1,5);
 generate_series 
-----------------
               1
               2
               3
               4
               5
(5 rows)

select a, c from orca.r, orca.s where a = any (select c) order by a, c limit 10;
 a | c 
---+---
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
(10 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 Limit
   Output: r.a, s.c
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: r.a, s.c
         Merge Key: r.a, s.c
         ->  Limit
               Output: r.a, s.c
               ->  Sort
                     Output: r.a, s.c
                     Sort Key: r.a, s.c
                     ->  Hash Join
                           Output: r.a, s.c
                           Hash Cond: (((SubPlan 1)) = r.a)
                           ->  Partial Seq Scan on orca.s
                                 Output: (SubPlan 1), s.c
                                 SubPlan 1
                                   ->  Result
                                         Output: s.c
                                         ->  Result
                                               Output: true
                           ->  Hash
                                 Output: r.a
                                 ->  Full Seq Scan on orca.r
                                       Output: r.a
 Optimizer: PolarDB PX Optimizer
(25 rows)

select a, c from orca.r, orca.s where a = (select c) order by a, c limit 10;
 a | c 
---+---
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
(10 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 Limit
   Output: r.a, s.c
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: r.a, s.c
         Merge Key: r.a, s.c
         ->  Limit
               Output: r.a, s.c
               ->  Sort
                     Output: r.a, s.c
                     Sort Key: r.a, s.c
                     ->  Hash Join
                           Output: r.a, s.c
                           Hash Cond: (((SubPlan 1)) = r.a)
                           ->  Partial Seq Scan on orca.s
                                 Output: (SubPlan 1), s.c
                                 SubPlan 1
                                   ->  Result
                                         Output: s.c
                                         ->  Result
                                               Output: true
                           ->  Hash
                                 Output: r.a
                                 ->  Full Seq Scan on orca.r
                                       Output: r.a
 Optimizer: PolarDB PX Optimizer
(25 rows)

select a, c from orca.r, orca.s where a  not in  (select c) order by a, c limit 10;
 a | c 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 2
 1 | 2
 1 | 2
 1 | 2
 1 | 2
 1 | 3
(10 rows)

                          QUERY PLAN                           
---------------------------------------------------------------
 Limit
   Output: r.a, s.c
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: r.a, s.c
         Merge Key: r.a, s.c
         ->  Limit
               Output: r.a, s.c
               ->  Sort
                     Output: r.a, s.c
                     Sort Key: r.a, s.c
                     ->  Nested Loop
                           Output: r.a, s.c
                           Join Filter: (r.a <> ((SubPlan 1)))
                           ->  Full Seq Scan on orca.r
                                 Output: r.a
                           ->  Partial Seq Scan on orca.s
                                 Output: (SubPlan 1), s.c
                                 SubPlan 1
                                   ->  Result
                                         Output: s.c
                                         ->  Result
                                               Output: true
 Optimizer: PolarDB PX Optimizer
(23 rows)

select a, c from orca.r, orca.s where a  = any  (select c from orca.r) order by a, c limit 10;
 a | c 
---+---
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 1 | 1
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
(10 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: r_1.a, s.c
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: r_1.a, s.c
         Merge Key: r_1.a, s.c
         ->  Limit
               Output: r_1.a, s.c
               ->  Sort
                     Output: r_1.a, s.c
                     Sort Key: r_1.a, s.c
                     ->  Hash Join
                           Output: r_1.a, s.c
                           Hash Cond: (s.c = r_1.a)
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: s.c
                                 Hash Key: s.c
                                 ->  Partial Seq Scan on orca.s
                                       Output: s.c
                           ->  Hash
                                 Output: r_1.a
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: r_1.a
                                       Hash Key: r_1.a
                                       ->  Nested Loop Semi Join
                                             Output: r_1.a
                                             Join Filter: true
                                             ->  Partial Seq Scan on orca.r r_1
                                                   Output: r_1.a
                                             ->  Materialize
                                                   ->  PX Broadcast 1:6  (slice4)
                                                         ->  Limit
                                                               ->  PX Coordinator 6:1  (slice5; segments: 6)
                                                                     ->  Limit
                                                                           ->  Partial Seq Scan on orca.r
 Optimizer: PolarDB PX Optimizer
(35 rows)

select a, c from orca.r, orca.s where a  <> all (select c) order by a, c limit 10;
 a | c 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 2
 1 | 2
 1 | 2
 1 | 2
 1 | 2
 1 | 3
(10 rows)

                          QUERY PLAN                           
---------------------------------------------------------------
 Limit
   Output: r.a, s.c
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: r.a, s.c
         Merge Key: r.a, s.c
         ->  Limit
               Output: r.a, s.c
               ->  Sort
                     Output: r.a, s.c
                     Sort Key: r.a, s.c
                     ->  Nested Loop
                           Output: r.a, s.c
                           Join Filter: (r.a <> ((SubPlan 1)))
                           ->  Full Seq Scan on orca.r
                                 Output: r.a
                           ->  Partial Seq Scan on orca.s
                                 Output: (SubPlan 1), s.c
                                 SubPlan 1
                                   ->  Result
                                         Output: s.c
                                         ->  Result
                                               Output: true
 Optimizer: PolarDB PX Optimizer
(23 rows)

select a, (select (select (select c from orca.s where a=c group by c))) as subq from orca.r order by a;
 a  | subq 
----+------
  1 |    1
  2 |    2
  3 |    3
  4 |    4
  5 |    5
  6 |    6
  7 |     
  8 |     
  9 |     
 10 |     
 11 |     
 12 |     
 13 |     
 14 |     
 15 |     
 16 |     
 17 |     
 18 |     
 19 |     
 20 |     
    |     
(21 rows)

                  QUERY PLAN                  
----------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: r.a, ((SubPlan 1))
   Merge Key: r.a
   ->  Result
         Output: r.a, (SubPlan 1)
         ->  Sort
               Output: r.a
               Sort Key: r.a
               ->  Partial Seq Scan on orca.r
                     Output: r.a
         SubPlan 1
           ->  HashAggregate
                 Output: s.c
                 Group Key: s.c
                 ->  Full Seq Scan on orca.s
                       Output: s.c
                       Filter: (r.a = s.c)
 Optimizer: PolarDB PX Optimizer
(18 rows)

with v as (select a,b from orca.r, orca.s where a=c)  select c from orca.s group by c having count(*) not in (select b from v where a=c) order by c;
 c 
---
 0
 1
 2
 3
 4
 5
 6
(7 rows)

                                                                                                                                                                             QUERY PLAN                                                                                                                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: s.c
   Merge Key: s.c
   ->  Sort
         Output: s.c
         Sort Key: s.c
         ->  Result
               Output: s.c
               Filter: (SubPlan 1)
               ->  GroupAggregate
                     Output: s.c, count()
                     Group Key: s.c
                     ->  Sort
                           Output: s.c
                           Sort Key: s.c
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: s.c
                                 Hash Key: s.c
                                 ->  Partial Seq Scan on orca.s
                                       Output: s.c
               SubPlan 1
                 ->  Result
                       Output: true
                       Filter: ((CASE WHEN (sum((CASE WHEN ((count()) = r.b) THEN 1 ELSE 0 END)) IS NULL) THEN true WHEN (sum((CASE WHEN (r.b IS NULL) THEN 1 ELSE 0 END)) > '0'::bigint) THEN NULL::boolean WHEN ((count()) IS NULL) THEN NULL::boolean WHEN (sum((CASE WHEN ((count()) = r.b) THEN 1 ELSE 0 END)) = '0'::bigint) THEN true ELSE false END) = true)
                       ->  Aggregate
                             Output: CASE WHEN (sum((CASE WHEN ((count()) = r.b) THEN 1 ELSE 0 END)) IS NULL) THEN true WHEN (sum((CASE WHEN (r.b IS NULL) THEN 1 ELSE 0 END)) > '0'::bigint) THEN NULL::boolean WHEN ((count()) IS NULL) THEN NULL::boolean WHEN (sum((CASE WHEN ((count()) = r.b) THEN 1 ELSE 0 END)) = '0'::bigint) THEN true ELSE false END
                             ->  Result
                                   Output: CASE WHEN ((count()) = r.b) THEN 1 ELSE 0 END, CASE WHEN (r.b IS NULL) THEN 1 ELSE 0 END
                                   Filter: (r.a = s.c)
                                   ->  Materialize
                                         Output: r.a, r.b
                                         ->  PX Broadcast 6:6  (slice3; segments: 6)
                                               Output: r.a, r.b
                                               ->  Nested Loop
                                                     Output: r.a, r.b
                                                     Join Filter: true
                                                     ->  Full Seq Scan on orca.s s_1
                                                           Output: s_1.c
                                                     ->  Partial Index Scan using r_a on orca.r
                                                           Output: r.a, r.b
                                                           Index Cond: (r.a = s_1.c)
 Optimizer: PolarDB PX Optimizer
(42 rows)

CREATE TABLE orca.onek (
unique1 int4,
unique2 int4,
two int4,
four int4,
ten int4,
twenty int4,
hundred int4,
thousand int4,
twothousand int4,
fivethous int4,
tenthous int4,
odd int4,
even int4,
stringu1 name,
stringu2 name,
string4 name
);
insert into orca.onek values (931,1,1,3,1,11,1,31,131,431,931,2,3,'VJAAAA','BAAAAA','HHHHxx');
insert into orca.onek values (714,2,0,2,4,14,4,14,114,214,714,8,9,'MBAAAA','CAAAAA','OOOOxx');
insert into orca.onek values (711,3,1,3,1,11,1,11,111,211,711,2,3,'JBAAAA','DAAAAA','VVVVxx');
insert into orca.onek values (883,4,1,3,3,3,3,83,83,383,883,6,7,'ZHAAAA','EAAAAA','AAAAxx');
insert into orca.onek values (439,5,1,3,9,19,9,39,39,439,439,18,19,'XQAAAA','FAAAAA','HHHHxx');
insert into orca.onek values (670,6,0,2,0,10,0,70,70,170,670,0,1,'UZAAAA','GAAAAA','OOOOxx');
insert into orca.onek values (543,7,1,3,3,3,3,43,143,43,543,6,7,'XUAAAA','HAAAAA','VVVVxx');
select ten, sum(distinct four) from orca.onek a
group by ten
having exists (select 1 from orca.onek b where sum(distinct a.four) = b.four);
 ten | sum 
-----+-----
   0 |   2
   1 |   3
   3 |   3
   4 |   2
   9 |   3
(5 rows)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: onek.ten, (sum(DISTINCT onek.four))
   ->  Hash Join
         Output: onek.ten, (sum(DISTINCT onek.four))
         Hash Cond: ((sum(DISTINCT onek.four)) = (onek_1.four)::bigint)
         ->  GroupAggregate
               Output: sum(DISTINCT onek.four), sum(DISTINCT onek.four), onek.ten
               Group Key: onek.ten
               ->  Sort
                     Output: onek.four, onek.ten
                     Sort Key: onek.ten
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: onek.four, onek.ten
                           Hash Key: onek.ten
                           ->  Partial Seq Scan on orca.onek
                                 Output: onek.four, onek.ten
         ->  Hash
               Output: onek_1.four
               ->  PX Broadcast 6:6  (slice3; segments: 6)
                     Output: onek_1.four
                     ->  GroupAggregate
                           Output: onek_1.four
                           Group Key: onek_1.four
                           ->  Sort
                                 Output: onek_1.four
                                 Sort Key: onek_1.four
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: onek_1.four
                                       Hash Key: onek_1.four
                                       ->  GroupAggregate
                                             Output: onek_1.four
                                             Group Key: onek_1.four
                                             ->  Result
                                                   Output: 1, onek_1.four
                                                   ->  Sort
                                                         Output: onek_1.four
                                                         Sort Key: onek_1.four
                                                         ->  Partial Seq Scan on orca.onek onek_1
                                                               Output: onek_1.four
 Optimizer: PolarDB PX Optimizer
(40 rows)

-- indexes on partitioned tables
create table orca.pp(a int) partition by range(a);
CREATE TABLE pp1 PARTITION of orca.pp for values from (1) to (10);
create index pp_a on orca.pp(a);
-- list partition tests
-- test homogeneous partitions
drop table if exists orca.t;
NOTICE:  table "t" does not exist, skipping
create table orca.t ( a int, b char(2), to_be_drop int, c int, d char(2), e int)
partition by list(d);
CREATE TABLE part1 PARTITION OF orca.t FOR VALUES IN ('a');
CREATE TABLE part2 PARTITION OF orca.t FOR VALUES IN ('b');
insert into orca.t
	select i, i::char(2), i, i, case when i%2 = 0 then 'a' else 'b' end, i
	from generate_series(1,100) i;
select * from orca.t order by 1, 2, 3, 4, 5, 6 limit 4;
 a | b  | to_be_drop | c | d  | e 
---+----+------------+---+----+---
 1 | 1  |          1 | 1 | b  | 1
 2 | 2  |          2 | 2 | a  | 2
 3 | 3  |          3 | 3 | b  | 3
 4 | 4  |          4 | 4 | a  | 4
(4 rows)

                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Limit
   Output: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
         Merge Key: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
         ->  Limit
               Output: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
               ->  Sort
                     Output: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
                     Sort Key: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
                     ->  Append
                           ->  Partial Seq Scan on orca.part1
                                 Output: part1.a, part1.b, part1.to_be_drop, part1.c, part1.d, part1.e
                           ->  Partial Seq Scan on orca.part2
                                 Output: part2.a, part2.b, part2.to_be_drop, part2.c, part2.d, part2.e
 Optimizer: PolarDB PX Optimizer
(16 rows)

alter table orca.t drop column to_be_drop;
select * from orca.t order by 1, 2, 3, 4, 5 limit 4;
 a | b  | c | d  | e 
---+----+---+----+---
 1 | 1  | 1 | b  | 1
 2 | 2  | 2 | a  | 2
 3 | 3  | 3 | b  | 3
 4 | 4  | 4 | a  | 4
(4 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit
   Output: part1.a, part1.b, part1.c, part1.d, part1.e
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: part1.a, part1.b, part1.c, part1.d, part1.e
         Merge Key: part1.a, part1.b, part1.c, part1.d, part1.e
         ->  Limit
               Output: part1.a, part1.b, part1.c, part1.d, part1.e
               ->  Sort
                     Output: part1.a, part1.b, part1.c, part1.d, part1.e
                     Sort Key: part1.a, part1.b, part1.c, part1.d, part1.e
                     ->  Append
                           ->  Partial Seq Scan on orca.part1
                                 Output: part1.a, part1.b, part1.c, part1.d, part1.e
                           ->  Partial Seq Scan on orca.part2
                                 Output: part2.a, part2.b, part2.c, part2.d, part2.e
 Optimizer: PolarDB PX Optimizer
(16 rows)

insert into orca.t (d, a) values('a', 0);
insert into orca.t (a, d) values(0, 'b');
select * from orca.t order by 1, 2, 3, 4, 5 limit 4;
 a | b  | c | d  | e 
---+----+---+----+---
 0 |    |   | a  |  
 0 |    |   | b  |  
 1 | 1  | 1 | b  | 1
 2 | 2  | 2 | a  | 2
(4 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit
   Output: part1.a, part1.b, part1.c, part1.d, part1.e
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: part1.a, part1.b, part1.c, part1.d, part1.e
         Merge Key: part1.a, part1.b, part1.c, part1.d, part1.e
         ->  Limit
               Output: part1.a, part1.b, part1.c, part1.d, part1.e
               ->  Sort
                     Output: part1.a, part1.b, part1.c, part1.d, part1.e
                     Sort Key: part1.a, part1.b, part1.c, part1.d, part1.e
                     ->  Append
                           ->  Partial Seq Scan on orca.part1
                                 Output: part1.a, part1.b, part1.c, part1.d, part1.e
                           ->  Partial Seq Scan on orca.part2
                                 Output: part2.a, part2.b, part2.c, part2.d, part2.e
 Optimizer: PolarDB PX Optimizer
(16 rows)

create table orca.multilevel_p (a int, b int)
partition by range(a);
CREATE TABLE aa_p1 PARTITION of orca.multilevel_p for values from (0) to (50);
CREATE TABLE aa_p2 PARTITION of orca.multilevel_p for values from (50) to (100);
insert into orca.multilevel_p values (1,1), (100,200);
ERROR:  no partition of relation "multilevel_p" found for row
DETAIL:  Partition key of the failing row contains (a) = (100).
select * from orca.multilevel_p;
 a | b 
---+---
(0 rows)

                 QUERY PLAN                 
--------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: aa_p1.a, aa_p1.b
   ->  Append
         ->  Partial Seq Scan on orca.aa_p1
               Output: aa_p1.a, aa_p1.b
         ->  Partial Seq Scan on orca.aa_p2
               Output: aa_p2.a, aa_p2.b
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- test heterogeneous partitions
drop table if exists orca.t;
create table orca.t ( timest character varying(6), user_id numeric(16,0) not null, to_be_drop char(5), tag1 char(5), tag2 char(5))
partition by list (timest);
CREATE TABLE part201203 PARTITION OF orca.t FOR VALUES IN ('201203');
CREATE TABLE part201204 PARTITION OF orca.t FOR VALUES IN ('201204');
CREATE TABLE part201205 PARTITION OF orca.t FOR VALUES IN ('201205');
insert into orca.t values('201203',0,'drop', 'tag1','tag2');
alter table orca.t drop column to_be_drop;
alter table orca.t add partition part201206 values('201206');
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.t add partition part201206 values('201206')...
                                                    ^
alter table orca.t add partition part201207 values('201207');
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.t add partition part201207 values('201207')...
                                                    ^
alter table orca.t add partition part201208 values('201208');
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.t add partition part201208 values('201208')...
                                                    ^
insert into orca.t values('201203',1,'tag1','tag2');
insert into orca.t values('201204',2,'tag1','tag2');
insert into orca.t values('201205',1,'tag1','tag2');
insert into orca.t values('201206',2,'tag1','tag2');
ERROR:  no partition of relation "t" found for row
DETAIL:  Partition key of the failing row contains (timest) = (201206).
insert into orca.t values('201207',1,'tag1','tag2');
ERROR:  no partition of relation "t" found for row
DETAIL:  Partition key of the failing row contains (timest) = (201207).
insert into orca.t values('201208',2,'tag1','tag2');
ERROR:  no partition of relation "t" found for row
DETAIL:  Partition key of the failing row contains (timest) = (201208).
-- test projections
select * from orca.t order by 1,2;
 timest | user_id | tag1  | tag2  
--------+---------+-------+-------
 201203 |       0 | tag1  | tag2 
 201203 |       1 | tag1  | tag2 
 201204 |       2 | tag1  | tag2 
 201205 |       1 | tag1  | tag2 
(4 rows)

                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part201203.timest, part201203.user_id, part201203.tag1, part201203.tag2
   Merge Key: part201203.timest, part201203.user_id
   ->  Sort
         Output: part201203.timest, part201203.user_id, part201203.tag1, part201203.tag2
         Sort Key: part201203.timest, part201203.user_id
         ->  Append
               ->  Partial Seq Scan on orca.part201203
                     Output: part201203.timest, part201203.user_id, part201203.tag1, part201203.tag2
               ->  Partial Seq Scan on orca.part201204
                     Output: part201204.timest, part201204.user_id, part201204.tag1, part201204.tag2
               ->  Partial Seq Scan on orca.part201205
                     Output: part201205.timest, part201205.user_id, part201205.tag1, part201205.tag2
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- test EXPLAIN support of partition selection nodes, while we're at it.
explain (costs off) select * from orca.t order by 1,2;
                    QUERY PLAN                     
---------------------------------------------------
 Sort
   Sort Key: part201203.timest, part201203.user_id
   ->  Append
         ->  Seq Scan on part201203
         ->  Seq Scan on part201204
         ->  Seq Scan on part201205
(6 rows)

select tag2, tag1 from orca.t order by 1, 2;;
 tag2  | tag1  
-------+-------
 tag2  | tag1 
 tag2  | tag1 
 tag2  | tag1 
 tag2  | tag1 
(4 rows)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part201203.tag2, part201203.tag1
   Merge Key: part201203.tag2, part201203.tag1
   ->  Sort
         Output: part201203.tag2, part201203.tag1
         Sort Key: part201203.tag2, part201203.tag1
         ->  Append
               ->  Partial Seq Scan on orca.part201203
                     Output: part201203.tag2, part201203.tag1
               ->  Partial Seq Scan on orca.part201204
                     Output: part201204.tag2, part201204.tag1
               ->  Partial Seq Scan on orca.part201205
                     Output: part201205.tag2, part201205.tag1
 Optimizer: PolarDB PX Optimizer
(14 rows)

select tag1, user_id from orca.t order by 1, 2;
 tag1  | user_id 
-------+---------
 tag1  |       0
 tag1  |       1
 tag1  |       1
 tag1  |       2
(4 rows)

                           QUERY PLAN                            
-----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part201203.tag1, part201203.user_id
   Merge Key: part201203.tag1, part201203.user_id
   ->  Sort
         Output: part201203.tag1, part201203.user_id
         Sort Key: part201203.tag1, part201203.user_id
         ->  Append
               ->  Partial Seq Scan on orca.part201203
                     Output: part201203.tag1, part201203.user_id
               ->  Partial Seq Scan on orca.part201204
                     Output: part201204.tag1, part201204.user_id
               ->  Partial Seq Scan on orca.part201205
                     Output: part201205.tag1, part201205.user_id
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into orca.t(user_id, timest, tag2) values(3, '201208','tag2');
ERROR:  no partition of relation "t" found for row
DETAIL:  Partition key of the failing row contains (timest) = (201208).
select * from orca.t order by 1, 2;
 timest | user_id | tag1  | tag2  
--------+---------+-------+-------
 201203 |       0 | tag1  | tag2 
 201203 |       1 | tag1  | tag2 
 201204 |       2 | tag1  | tag2 
 201205 |       1 | tag1  | tag2 
(4 rows)

                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part201203.timest, part201203.user_id, part201203.tag1, part201203.tag2
   Merge Key: part201203.timest, part201203.user_id
   ->  Sort
         Output: part201203.timest, part201203.user_id, part201203.tag1, part201203.tag2
         Sort Key: part201203.timest, part201203.user_id
         ->  Append
               ->  Partial Seq Scan on orca.part201203
                     Output: part201203.timest, part201203.user_id, part201203.tag1, part201203.tag2
               ->  Partial Seq Scan on orca.part201204
                     Output: part201204.timest, part201204.user_id, part201204.tag1, part201204.tag2
               ->  Partial Seq Scan on orca.part201205
                     Output: part201205.timest, part201205.user_id, part201205.tag1, part201205.tag2
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- test heterogeneous indexes with constant expression evaluation
drop table if exists orca.t_date;
NOTICE:  table "t_date" does not exist, skipping
create table orca.t_date ( timest date, user_id numeric(16,0) not null, tag1 char(5), tag2 char(5))
partition by list (timest);
CREATE TABLE part_data_201203 PARTITION OF orca.t_date FOR VALUES IN ('01-03-2012');
CREATE TABLE part_data_201204 PARTITION OF orca.t_date FOR VALUES IN ('01-04-2012');
CREATE TABLE part_data_201205 PARTITION OF orca.t_date FOR VALUES IN ('01-05-2012');
create index user_id_idx on orca.t_date(user_id);
alter table orca.t_date add partition part201206 values('01-06-2012'::date);
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.t_date add partition part201206 values('01-...
                                                         ^
alter table orca.t_date add partition part201207 values('01-07-2012'::date);
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.t_date add partition part201207 values('01-...
                                                         ^
alter table orca.t_date add partition part201208 values('01-08-2012'::date);
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.t_date add partition part201208 values('01-...
                                                         ^
insert into orca.t_date values('01-03-2012'::date,0,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,1,'tag1','tag2');
insert into orca.t_date values('01-04-2012'::date,2,'tag1','tag2');
insert into orca.t_date values('01-05-2012'::date,1,'tag1','tag2');
insert into orca.t_date values('01-06-2012'::date,2,'tag1','tag2');
ERROR:  no partition of relation "t_date" found for row
DETAIL:  Partition key of the failing row contains (timest) = (01-06-2012).
insert into orca.t_date values('01-07-2012'::date,1,'tag1','tag2');
ERROR:  no partition of relation "t_date" found for row
DETAIL:  Partition key of the failing row contains (timest) = (01-07-2012).
insert into orca.t_date values('01-08-2012'::date,2,'tag1','tag2');
ERROR:  no partition of relation "t_date" found for row
DETAIL:  Partition key of the failing row contains (timest) = (01-08-2012).
insert into orca.t_date values('01-03-2012'::date,2,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,3,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,4,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,5,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,6,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,7,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,8,'tag1','tag2');
insert into orca.t_date values('01-03-2012'::date,9,'tag1','tag2');
set polar_px_optimizer_enable_partial_index=on;
ERROR:  unrecognized configuration parameter "polar_px_optimizer_enable_partial_index"
set polar_px_optimizer_enable_space_pruning=off;
set polar_px_optimizer_enable_constant_expression_evaluation=on;
-- start_ignore
analyze orca.t_date;
-- end_ignore
explain (costs off) select * from orca.t_date where user_id=9;
                QUERY PLAN                
------------------------------------------
 Append
   ->  Seq Scan on part_data_201203
         Filter: (user_id = '9'::numeric)
   ->  Seq Scan on part_data_201204
         Filter: (user_id = '9'::numeric)
   ->  Seq Scan on part_data_201205
         Filter: (user_id = '9'::numeric)
(7 rows)

select * from orca.t_date where user_id=9;
   timest   | user_id | tag1  | tag2  
------------+---------+-------+-------
 01-03-2012 |       9 | tag1  | tag2 
(1 row)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part_data_201203.timest, part_data_201203.user_id, part_data_201203.tag1, part_data_201203.tag2
   ->  Append
         ->  Partial Index Scan using part_data_201203_user_id_idx on orca.part_data_201203
               Output: part_data_201203.timest, part_data_201203.user_id, part_data_201203.tag1, part_data_201203.tag2
               Index Cond: (part_data_201203.user_id = '9'::numeric)
         ->  Partial Index Scan using part_data_201204_user_id_idx on orca.part_data_201204
               Output: part_data_201204.timest, part_data_201204.user_id, part_data_201204.tag1, part_data_201204.tag2
               Index Cond: (part_data_201204.user_id = '9'::numeric)
         ->  Partial Index Scan using part_data_201205_user_id_idx on orca.part_data_201205
               Output: part_data_201205.timest, part_data_201205.user_id, part_data_201205.tag1, part_data_201205.tag2
               Index Cond: (part_data_201205.user_id = '9'::numeric)
 Optimizer: PolarDB PX Optimizer
(13 rows)

reset polar_px_optimizer_enable_space_pruning;
set polar_px_optimizer_enumerate_plans=off;
set polar_px_optimizer_enable_constant_expression_evaluation=off;
drop table if exists orca.t_text;
NOTICE:  table "t_text" does not exist, skipping
drop index if exists orca.user_id_idx;
create table orca.t_text ( timest date, user_id numeric(16,0) not null, tag1 char(5), tag2 char(5))
partition by list(tag1);
CREATE TABLE partgood PARTITION OF orca.t_text FOR VALUES IN ('good'::text);
ERROR:  syntax error at or near "::"
LINE 1: ...tgood PARTITION OF orca.t_text FOR VALUES IN ('good'::text);
                                                               ^
CREATE TABLE partbad PARTITION OF orca.t_text FOR VALUES IN ('bad'::text);
ERROR:  syntax error at or near "::"
LINE 1: ...artbad PARTITION OF orca.t_text FOR VALUES IN ('bad'::text);
                                                               ^
CREATE TABLE partugly PARTITION OF orca.t_text FOR VALUES IN ('ugly'::text);
ERROR:  syntax error at or near "::"
LINE 1: ...tugly PARTITION OF orca.t_text FOR VALUES IN ('ugly'::text);
                                                               ^
create index user_id_idx on orca.t_text_1_prt_partgood(user_id);
ERROR:  relation "orca.t_text_1_prt_partgood" does not exist
insert into orca.t_text values('01-03-2012'::date,0,'good','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (good ).
insert into orca.t_text values('01-03-2012'::date,1,'bad','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (bad  ).
insert into orca.t_text values('01-04-2012'::date,2,'ugly','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (ugly ).
insert into orca.t_text values('01-05-2012'::date,1,'good','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (good ).
insert into orca.t_text values('01-06-2012'::date,2,'bad','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (bad  ).
insert into orca.t_text values('01-07-2012'::date,1,'ugly','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (ugly ).
insert into orca.t_text values('01-08-2012'::date,2,'good','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (good ).
insert into orca.t_text values('01-03-2012'::date,2,'bad','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (bad  ).
insert into orca.t_text values('01-03-2012'::date,3,'ugly','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (ugly ).
insert into orca.t_text values('01-03-2012'::date,4,'good','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (good ).
insert into orca.t_text values('01-03-2012'::date,5,'bad','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (bad  ).
insert into orca.t_text values('01-03-2012'::date,6,'ugly','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (ugly ).
insert into orca.t_text values('01-03-2012'::date,7,'good','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (good ).
insert into orca.t_text values('01-03-2012'::date,8,'bad','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (bad  ).
insert into orca.t_text values('01-03-2012'::date,9,'ugly','tag2');
ERROR:  no partition of relation "t_text" found for row
DETAIL:  Partition key of the failing row contains (tag1) = (ugly ).
set polar_px_optimizer_enable_space_pruning=off;
set polar_px_optimizer_enable_constant_expression_evaluation=on;
-- start_ignore
analyze orca.t_text;
-- end_ignore
explain (costs off) select * from orca.t_text where user_id=9;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

select * from orca.t_text where user_id=9;
 timest | user_id | tag1 | tag2 
--------+---------+------+------
(0 rows)

reset polar_px_optimizer_enable_space_pruning;
set polar_px_optimizer_enumerate_plans=off;
reset polar_px_optimizer_enable_constant_expression_evaluation;
reset polar_px_optimizer_enable_partial_index;
ERROR:  unrecognized configuration parameter "polar_px_optimizer_enable_partial_index"
-- test that constant expression evaluation works with integers
drop table if exists orca.t_ceeval_ints;
NOTICE:  table "t_ceeval_ints" does not exist, skipping
create table orca.t_ceeval_ints(user_id numeric(16,0), category_id int, tag1 char(5), tag2 char(5))
partition by list (category_id);
CREATE TABLE part100 PARTITION OF orca.t_ceeval_ints FOR VALUES IN ('100');
CREATE TABLE part101 PARTITION OF orca.t_ceeval_ints FOR VALUES IN ('101');
CREATE TABLE part102 PARTITION OF orca.t_ceeval_ints FOR VALUES IN ('102');
create index user_id_ceeval_ints on orca.t_ceeval_ints_1_prt_part101(user_id);
ERROR:  relation "orca.t_ceeval_ints_1_prt_part101" does not exist
insert into orca.t_ceeval_ints values(1, 100, 'tag1', 'tag2');
insert into orca.t_ceeval_ints values(2, 100, 'tag1', 'tag2');
insert into orca.t_ceeval_ints values(3, 100, 'tag1', 'tag2');
insert into orca.t_ceeval_ints values(4, 101, 'tag1', 'tag2');
insert into orca.t_ceeval_ints values(5, 102, 'tag1', 'tag2');
set polar_px_optimizer_enable_partial_index=on;
ERROR:  unrecognized configuration parameter "polar_px_optimizer_enable_partial_index"
set polar_px_optimizer_enable_space_pruning=off;
set polar_px_optimizer_enable_constant_expression_evaluation=on;
set polar_px_optimizer_use_external_constant_expression_evaluation_for_ints = on;
NOTICE:  identifier "polar_px_optimizer_use_external_constant_expression_evaluation_for_ints" will be truncated to "polar_px_optimizer_use_external_constant_expression_evaluation_"
ERROR:  unrecognized configuration parameter "polar_px_optimizer_use_external_constant_expression_evaluation_"
-- start_ignore
analyze orca.t_ceeval_ints;
-- end_ignore
explain (costs off) select * from orca.t_ceeval_ints where user_id=4;
                QUERY PLAN                
------------------------------------------
 Append
   ->  Seq Scan on part100
         Filter: (user_id = '4'::numeric)
   ->  Seq Scan on part101
         Filter: (user_id = '4'::numeric)
   ->  Seq Scan on part102
         Filter: (user_id = '4'::numeric)
(7 rows)

select * from orca.t_ceeval_ints where user_id=4;
 user_id | category_id | tag1  | tag2  
---------+-------------+-------+-------
       4 |         101 | tag1  | tag2 
(1 row)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part100.user_id, part100.category_id, part100.tag1, part100.tag2
   ->  Append
         ->  Partial Seq Scan on orca.part100
               Output: part100.user_id, part100.category_id, part100.tag1, part100.tag2
               Filter: (part100.user_id = '4'::numeric)
         ->  Partial Seq Scan on orca.part101
               Output: part101.user_id, part101.category_id, part101.tag1, part101.tag2
               Filter: (part101.user_id = '4'::numeric)
         ->  Partial Seq Scan on orca.part102
               Output: part102.user_id, part102.category_id, part102.tag1, part102.tag2
               Filter: (part102.user_id = '4'::numeric)
 Optimizer: PolarDB PX Optimizer
(13 rows)

reset polar_px_optimizer_enable_space_pruning;
reset polar_px_optimizer_enumerate_plans;
reset polar_px_optimizer_use_external_constant_expression_evaluation_for_ints;
NOTICE:  identifier "polar_px_optimizer_use_external_constant_expression_evaluation_for_ints" will be truncated to "polar_px_optimizer_use_external_constant_expression_evaluation_"
ERROR:  unrecognized configuration parameter "polar_px_optimizer_use_external_constant_expression_evaluation_"
reset polar_px_optimizer_enable_constant_expression_evaluation;
reset polar_px_optimizer_enable_partial_index;
ERROR:  unrecognized configuration parameter "polar_px_optimizer_enable_partial_index"
-- test project elements in TVF
CREATE FUNCTION orca.csq_f(a int) RETURNS int AS $$ select $1 $$ LANGUAGE SQL;
CREATE TABLE orca.csq_r(a int);
INSERT INTO orca.csq_r VALUES (1);
SELECT * FROM orca.csq_r WHERE a IN (SELECT * FROM orca.csq_f(orca.csq_r.a));
 a 
---
 1
(1 row)

-- test algebrization of having clause
drop table if exists orca.tab1;
NOTICE:  table "tab1" does not exist, skipping
create table orca.tab1(a int, b int, c int, d int, e int);
insert into orca.tab1 values (1,2,3,4,5);
insert into orca.tab1 values (1,2,3,4,5);
insert into orca.tab1 values (1,2,3,4,5);
select b,d from orca.tab1 group by b,d having min(distinct d)>3;
 b | d 
---+---
 2 | 4
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: b, d
   ->  Result
         Output: b, d
         Filter: ((min(tab1.d)) > 3)
         ->  Finalize GroupAggregate
               Output: min(d), b, d
               Group Key: tab1.b, tab1.d
               ->  Sort
                     Output: b, d, (PARTIAL min(d))
                     Sort Key: tab1.b, tab1.d
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: b, d, (PARTIAL min(d))
                           Hash Key: b, d
                           ->  Partial GroupAggregate
                                 Output: b, d, PARTIAL min(d)
                                 Group Key: tab1.b, tab1.d
                                 ->  Sort
                                       Output: b, d
                                       Sort Key: tab1.b, tab1.d
                                       ->  Partial Seq Scan on orca.tab1
                                             Output: b, d
 Optimizer: PolarDB PX Optimizer
(23 rows)

select b,d from orca.tab1 group by b,d having d>3;
 b | d 
---+---
 2 | 4
(1 row)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: b, d
   ->  GroupAggregate
         Output: b, d
         Group Key: tab1.b, tab1.d
         ->  Sort
               Output: b, d
               Sort Key: tab1.b, tab1.d
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: b, d
                     Hash Key: b, d
                     ->  GroupAggregate
                           Output: b, d
                           Group Key: tab1.b, tab1.d
                           ->  Sort
                                 Output: b, d
                                 Sort Key: tab1.b, tab1.d
                                 ->  Partial Seq Scan on orca.tab1
                                       Output: b, d
                                       Filter: (tab1.d > 3)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select b,d from orca.tab1 group by b,d having min(distinct d)>b;
 b | d 
---+---
 2 | 4
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: b, d
   ->  Result
         Output: b, d
         Filter: ((min(tab1.d)) > tab1.b)
         ->  Finalize GroupAggregate
               Output: min(d), b, d
               Group Key: tab1.b, tab1.d
               ->  Sort
                     Output: b, d, (PARTIAL min(d))
                     Sort Key: tab1.b, tab1.d
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: b, d, (PARTIAL min(d))
                           Hash Key: b, d
                           ->  Partial GroupAggregate
                                 Output: b, d, PARTIAL min(d)
                                 Group Key: tab1.b, tab1.d
                                 ->  Sort
                                       Output: b, d
                                       Sort Key: tab1.b, tab1.d
                                       ->  Partial Seq Scan on orca.tab1
                                             Output: b, d
 Optimizer: PolarDB PX Optimizer
(23 rows)

create table orca.fooh1 (a int, b int, c int);
create table orca.fooh2 (a int, b int, c int);
insert into orca.fooh1 select i%4, i%3, i from generate_series(1,20) i;
insert into orca.fooh2 select i%3, i%2, i from generate_series(1,20) i;
select sum(f1.b) from orca.fooh1 f1 group by f1.a;
 sum 
-----
   4
   6
   5
   6
(4 rows)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (sum(b))
   ->  Finalize GroupAggregate
         Output: sum(b)
         Group Key: fooh1.a
         ->  Sort
               Output: a, (PARTIAL sum(b))
               Sort Key: fooh1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: a, (PARTIAL sum(b))
                     Hash Key: a
                     ->  Partial HashAggregate
                           Output: a, PARTIAL sum(b)
                           Group Key: fooh1.a
                           ->  Partial Seq Scan on orca.fooh1
                                 Output: a, b
 Optimizer: PolarDB PX Optimizer
(17 rows)

select f1.a + 1 from fooh1 f1 group by f1.a+1 having sum(f1.a+1) + 1 > 20;
 ?column? 
----------
        4
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((a + 1))
   ->  Result
         Output: ((a + 1))
         Filter: (((sum((fooh1.a + 1))) + 1) > 20)
         ->  Finalize GroupAggregate
               Output: sum((a + 1)), ((a + 1))
               Group Key: ((fooh1.a + 1))
               ->  Sort
                     Output: ((a + 1)), (PARTIAL sum((a + 1)))
                     Sort Key: ((fooh1.a + 1))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: ((a + 1)), (PARTIAL sum((a + 1)))
                           Hash Key: ((a + 1))
                           ->  Partial HashAggregate
                                 Output: ((a + 1)), PARTIAL sum((a + 1))
                                 Group Key: (fooh1.a + 1)
                                 ->  Partial Seq Scan on orca.fooh1
                                       Output: (a + 1), a
 Optimizer: PolarDB PX Optimizer
(20 rows)

select 1 as one, f1.a from orca.fooh1 f1 group by f1.a having sum(f1.b) > 4;
 one | a 
-----+---
   1 | 0
   1 | 1
   1 | 2
(3 rows)

                                QUERY PLAN                                
--------------------------------------------------------------------------
 Result
   Output: 1, a
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: a
         ->  Result
               Output: a
               Filter: ((sum(fooh1.b)) > 4)
               ->  Finalize GroupAggregate
                     Output: sum(b), a
                     Group Key: fooh1.a
                     ->  Sort
                           Output: a, (PARTIAL sum(b))
                           Sort Key: fooh1.a
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: a, (PARTIAL sum(b))
                                 Hash Key: a
                                 ->  Partial HashAggregate
                                       Output: a, PARTIAL sum(b)
                                       Group Key: fooh1.a
                                       ->  Partial Seq Scan on orca.fooh1
                                             Output: a, b
 Optimizer: PolarDB PX Optimizer
(22 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having 10 > (select f2.a from orca.fooh2 f2 group by f2.a having sum(f1.a) > count(*) order by f2.a limit 1) order by f1.a;
 a | one 
---+-----
 2 |   1
 3 |   1
(2 rows)

                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  Result
         Output: fooh1.a, 1
         ->  Sort
               Output: fooh1.a
               Sort Key: fooh1.a
               ->  Result
                     Output: fooh1.a
                     Filter: (10 > (SubPlan 1))
                     ->  GroupAggregate
                           Output: sum(fooh1.a), fooh1.a
                           Group Key: fooh1.a
                           ->  Sort
                                 Output: fooh1.a
                                 Sort Key: fooh1.a
                                 ->  PX Hash 6:6  (slice2; segments: 6)
                                       Output: fooh1.a
                                       Hash Key: fooh1.a
                                       ->  Partial Seq Scan on orca.fooh1
                                             Output: fooh1.a
                     SubPlan 1
                       ->  Limit
                             Output: fooh2.a
                             ->  Sort
                                   Output: fooh2.a
                                   Sort Key: fooh2.a
                                   ->  Result
                                         Output: fooh2.a
                                         Filter: ((sum(fooh1.a)) > (count()))
                                         ->  Materialize
                                               Output: fooh2.a, (count())
                                               ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                     Output: fooh2.a, (count())
                                                     ->  Finalize GroupAggregate
                                                           Output: fooh2.a, count()
                                                           Group Key: fooh2.a
                                                           ->  Sort
                                                                 Output: fooh2.a, (PARTIAL count())
                                                                 Sort Key: fooh2.a
                                                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                                                       Output: fooh2.a, (PARTIAL count())
                                                                       Hash Key: fooh2.a
                                                                       ->  Partial GroupAggregate
                                                                             Output: fooh2.a, PARTIAL count()
                                                                             Group Key: fooh2.a
                                                                             ->  Sort
                                                                                   Output: fooh2.a
                                                                                   Sort Key: fooh2.a
                                                                                   ->  Partial Seq Scan on orca.fooh2
                                                                                         Output: fooh2.a
 Optimizer: PolarDB PX Optimizer
(53 rows)

select 1 from orca.fooh1 f1 group by f1.a having 10 > (select f2.a from orca.fooh2 f2 group by f2.a having sum(f1.a) > count(*) order by f2.a limit 1) order by f1.a;
 ?column? 
----------
        1
        1
(2 rows)

                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Result
   Output: (1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (1), fooh1.a
         Merge Key: fooh1.a
         ->  Result
               Output: 1, fooh1.a
               ->  Sort
                     Output: fooh1.a
                     Sort Key: fooh1.a
                     ->  Result
                           Output: fooh1.a
                           Filter: (10 > (SubPlan 1))
                           ->  GroupAggregate
                                 Output: sum(fooh1.a), fooh1.a
                                 Group Key: fooh1.a
                                 ->  Sort
                                       Output: fooh1.a
                                       Sort Key: fooh1.a
                                       ->  PX Hash 6:6  (slice2; segments: 6)
                                             Output: fooh1.a
                                             Hash Key: fooh1.a
                                             ->  Partial Seq Scan on orca.fooh1
                                                   Output: fooh1.a
                           SubPlan 1
                             ->  Limit
                                   Output: fooh2.a
                                   ->  Sort
                                         Output: fooh2.a
                                         Sort Key: fooh2.a
                                         ->  Result
                                               Output: fooh2.a
                                               Filter: ((sum(fooh1.a)) > (count()))
                                               ->  Materialize
                                                     Output: fooh2.a, (count())
                                                     ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                           Output: fooh2.a, (count())
                                                           ->  Finalize GroupAggregate
                                                                 Output: fooh2.a, count()
                                                                 Group Key: fooh2.a
                                                                 ->  Sort
                                                                       Output: fooh2.a, (PARTIAL count())
                                                                       Sort Key: fooh2.a
                                                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                                                             Output: fooh2.a, (PARTIAL count())
                                                                             Hash Key: fooh2.a
                                                                             ->  Partial GroupAggregate
                                                                                   Output: fooh2.a, PARTIAL count()
                                                                                   Group Key: fooh2.a
                                                                                   ->  Sort
                                                                                         Output: fooh2.a
                                                                                         Sort Key: fooh2.a
                                                                                         ->  Partial Seq Scan on orca.fooh2
                                                                                               Output: fooh2.a
 Optimizer: PolarDB PX Optimizer
(55 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having 10 > (select 1 from orca.fooh2 f2 group by f2.a having sum(f1.b) > count(*) order by f2.a limit 1) order by f1.a;
 a | one 
---+-----
(0 rows)

                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  Result
         Output: fooh1.a, 1
         ->  Sort
               Output: fooh1.a
               Sort Key: fooh1.a
               ->  Result
                     Output: fooh1.a
                     Filter: (10 > (SubPlan 1))
                     ->  Finalize GroupAggregate
                           Output: sum(fooh1.b), fooh1.a
                           Group Key: fooh1.a
                           ->  Sort
                                 Output: fooh1.a, (PARTIAL sum(fooh1.b))
                                 Sort Key: fooh1.a
                                 ->  PX Hash 6:6  (slice2; segments: 6)
                                       Output: fooh1.a, (PARTIAL sum(fooh1.b))
                                       Hash Key: fooh1.a
                                       ->  Partial HashAggregate
                                             Output: fooh1.a, PARTIAL sum(fooh1.b)
                                             Group Key: fooh1.a
                                             ->  Partial Seq Scan on orca.fooh1
                                                   Output: fooh1.a, fooh1.b
                     SubPlan 1
                       ->  Result
                             Output: 1
                             ->  Limit
                                   Output: fooh2.a
                                   ->  Sort
                                         Output: fooh2.a
                                         Sort Key: fooh2.a
                                         ->  Result
                                               Output: fooh2.a
                                               Filter: ((sum(fooh1.b)) > (count()))
                                               ->  Materialize
                                                     Output: fooh2.a, (count())
                                                     ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                           Output: fooh2.a, (count())
                                                           ->  Finalize GroupAggregate
                                                                 Output: fooh2.a, count()
                                                                 Group Key: fooh2.a
                                                                 ->  Sort
                                                                       Output: fooh2.a, (PARTIAL count())
                                                                       Sort Key: fooh2.a
                                                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                                                             Output: fooh2.a, (PARTIAL count())
                                                                             Hash Key: fooh2.a
                                                                             ->  Partial GroupAggregate
                                                                                   Output: fooh2.a, PARTIAL count()
                                                                                   Group Key: fooh2.a
                                                                                   ->  Sort
                                                                                         Output: fooh2.a
                                                                                         Sort Key: fooh2.a
                                                                                         ->  Partial Seq Scan on orca.fooh2
                                                                                               Output: fooh2.a
 Optimizer: PolarDB PX Optimizer
(58 rows)

select 1 from orca.fooh1 f1 group by f1.a having 10 > (select 1 from orca.fooh2 f2 group by f2.a having sum(f1.b) > count(*) order by f2.a limit 1) order by f1.a;
 ?column? 
----------
(0 rows)

                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: (1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (1), fooh1.a
         Merge Key: fooh1.a
         ->  Result
               Output: 1, fooh1.a
               ->  Sort
                     Output: fooh1.a
                     Sort Key: fooh1.a
                     ->  Result
                           Output: fooh1.a
                           Filter: (10 > (SubPlan 1))
                           ->  Finalize GroupAggregate
                                 Output: sum(fooh1.b), fooh1.a
                                 Group Key: fooh1.a
                                 ->  Sort
                                       Output: fooh1.a, (PARTIAL sum(fooh1.b))
                                       Sort Key: fooh1.a
                                       ->  PX Hash 6:6  (slice2; segments: 6)
                                             Output: fooh1.a, (PARTIAL sum(fooh1.b))
                                             Hash Key: fooh1.a
                                             ->  Partial HashAggregate
                                                   Output: fooh1.a, PARTIAL sum(fooh1.b)
                                                   Group Key: fooh1.a
                                                   ->  Partial Seq Scan on orca.fooh1
                                                         Output: fooh1.a, fooh1.b
                           SubPlan 1
                             ->  Result
                                   Output: 1
                                   ->  Limit
                                         Output: fooh2.a
                                         ->  Sort
                                               Output: fooh2.a
                                               Sort Key: fooh2.a
                                               ->  Result
                                                     Output: fooh2.a
                                                     Filter: ((sum(fooh1.b)) > (count()))
                                                     ->  Materialize
                                                           Output: fooh2.a, (count())
                                                           ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                                 Output: fooh2.a, (count())
                                                                 ->  Finalize GroupAggregate
                                                                       Output: fooh2.a, count()
                                                                       Group Key: fooh2.a
                                                                       ->  Sort
                                                                             Output: fooh2.a, (PARTIAL count())
                                                                             Sort Key: fooh2.a
                                                                             ->  PX Hash 6:6  (slice4; segments: 6)
                                                                                   Output: fooh2.a, (PARTIAL count())
                                                                                   Hash Key: fooh2.a
                                                                                   ->  Partial GroupAggregate
                                                                                         Output: fooh2.a, PARTIAL count()
                                                                                         Group Key: fooh2.a
                                                                                         ->  Sort
                                                                                               Output: fooh2.a
                                                                                               Sort Key: fooh2.a
                                                                                               ->  Partial Seq Scan on orca.fooh2
                                                                                                     Output: fooh2.a
 Optimizer: PolarDB PX Optimizer
(60 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having 0 = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b) > 1 order by f2.a limit 1) order by f1.a;
 a | one 
---+-----
 0 |   1
 1 |   1
 2 |   1
 3 |   1
(4 rows)

                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  GroupAggregate
         Output: fooh1.a, 1
         Group Key: fooh1.a
         ->  Sort
               Output: fooh1.a
               Sort Key: fooh1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: fooh1.a
                     Hash Key: fooh1.a
                     ->  GroupAggregate
                           Output: fooh1.a
                           Group Key: fooh1.a
                           ->  Sort
                                 Output: fooh1.a
                                 Sort Key: fooh1.a
                                 ->  Nested Loop
                                       Output: fooh1.a
                                       Join Filter: true
                                       ->  Partial Seq Scan on orca.fooh1
                                             Output: fooh1.a
                                       ->  Materialize
                                             ->  PX Broadcast 1:6  (slice3)
                                                   ->  Result
                                                         Filter: (0 = fooh2.a)
                                                         ->  Limit
                                                               Output: fooh2.a
                                                               ->  PX Coordinator 6:1  (slice4; segments: 6)
                                                                     Output: fooh2.a
                                                                     Merge Key: fooh2.a
                                                                     ->  Sort
                                                                           Output: fooh2.a
                                                                           Sort Key: fooh2.a
                                                                           ->  Result
                                                                                 Output: fooh2.a
                                                                                 Filter: ((sum(fooh2.b)) > 1)
                                                                                 ->  Finalize GroupAggregate
                                                                                       Output: sum(fooh2.b), fooh2.a
                                                                                       Group Key: fooh2.a
                                                                                       ->  Sort
                                                                                             Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                             Sort Key: fooh2.a
                                                                                             ->  PX Hash 6:6  (slice5; segments: 6)
                                                                                                   Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                                   Hash Key: fooh2.a
                                                                                                   ->  Partial HashAggregate
                                                                                                         Output: fooh2.a, PARTIAL sum(fooh2.b)
                                                                                                         Group Key: fooh2.a
                                                                                                         ->  Partial Seq Scan on orca.fooh2
                                                                                                               Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(53 rows)

select 1 as one from orca.fooh1 f1 group by f1.a having 0 = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b) > 1 order by f2.a limit 1) order by f1.a;
 one 
-----
   1
   1
   1
   1
(4 rows)

                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: (1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (1), fooh1.a
         Merge Key: fooh1.a
         ->  GroupAggregate
               Output: 1, fooh1.a
               Group Key: fooh1.a
               ->  Sort
                     Output: fooh1.a
                     Sort Key: fooh1.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: fooh1.a
                           Hash Key: fooh1.a
                           ->  GroupAggregate
                                 Output: fooh1.a
                                 Group Key: fooh1.a
                                 ->  Sort
                                       Output: fooh1.a
                                       Sort Key: fooh1.a
                                       ->  Nested Loop
                                             Output: fooh1.a
                                             Join Filter: true
                                             ->  Partial Seq Scan on orca.fooh1
                                                   Output: fooh1.a
                                             ->  Materialize
                                                   ->  PX Broadcast 1:6  (slice3)
                                                         ->  Result
                                                               Filter: (0 = fooh2.a)
                                                               ->  Limit
                                                                     Output: fooh2.a
                                                                     ->  PX Coordinator 6:1  (slice4; segments: 6)
                                                                           Output: fooh2.a
                                                                           Merge Key: fooh2.a
                                                                           ->  Sort
                                                                                 Output: fooh2.a
                                                                                 Sort Key: fooh2.a
                                                                                 ->  Result
                                                                                       Output: fooh2.a
                                                                                       Filter: ((sum(fooh2.b)) > 1)
                                                                                       ->  Finalize GroupAggregate
                                                                                             Output: sum(fooh2.b), fooh2.a
                                                                                             Group Key: fooh2.a
                                                                                             ->  Sort
                                                                                                   Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                                   Sort Key: fooh2.a
                                                                                                   ->  PX Hash 6:6  (slice5; segments: 6)
                                                                                                         Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                                         Hash Key: fooh2.a
                                                                                                         ->  Partial HashAggregate
                                                                                                               Output: fooh2.a, PARTIAL sum(fooh2.b)
                                                                                                               Group Key: fooh2.a
                                                                                                               ->  Partial Seq Scan on orca.fooh2
                                                                                                                     Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(55 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having 0 = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b) > 1 order by f2.a limit 1) order by f1.a;
 a | one 
---+-----
 0 |   1
 1 |   1
 2 |   1
 3 |   1
(4 rows)

                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  GroupAggregate
         Output: fooh1.a, 1
         Group Key: fooh1.a
         ->  Sort
               Output: fooh1.a
               Sort Key: fooh1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: fooh1.a
                     Hash Key: fooh1.a
                     ->  GroupAggregate
                           Output: fooh1.a
                           Group Key: fooh1.a
                           ->  Sort
                                 Output: fooh1.a
                                 Sort Key: fooh1.a
                                 ->  Nested Loop
                                       Output: fooh1.a
                                       Join Filter: true
                                       ->  Partial Seq Scan on orca.fooh1
                                             Output: fooh1.a
                                       ->  Materialize
                                             ->  PX Broadcast 1:6  (slice3)
                                                   ->  Result
                                                         Filter: (0 = fooh2.a)
                                                         ->  Limit
                                                               Output: fooh2.a
                                                               ->  PX Coordinator 6:1  (slice4; segments: 6)
                                                                     Output: fooh2.a
                                                                     Merge Key: fooh2.a
                                                                     ->  Sort
                                                                           Output: fooh2.a
                                                                           Sort Key: fooh2.a
                                                                           ->  Result
                                                                                 Output: fooh2.a
                                                                                 Filter: ((sum(fooh2.b)) > 1)
                                                                                 ->  Finalize GroupAggregate
                                                                                       Output: sum(fooh2.b), fooh2.a
                                                                                       Group Key: fooh2.a
                                                                                       ->  Sort
                                                                                             Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                             Sort Key: fooh2.a
                                                                                             ->  PX Hash 6:6  (slice5; segments: 6)
                                                                                                   Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                                   Hash Key: fooh2.a
                                                                                                   ->  Partial HashAggregate
                                                                                                         Output: fooh2.a, PARTIAL sum(fooh2.b)
                                                                                                         Group Key: fooh2.a
                                                                                                         ->  Partial Seq Scan on orca.fooh2
                                                                                                               Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(53 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having 0 = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b + f1.a) > 1 order by f2.a limit 1) order by f1.a;
 a | one 
---+-----
 0 |   1
 1 |   1
 2 |   1
 3 |   1
(4 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  GroupAggregate
         Output: fooh1.a, 1
         Group Key: fooh1.a
         ->  Sort
               Output: fooh1.a
               Sort Key: fooh1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: fooh1.a
                     Hash Key: fooh1.a
                     ->  GroupAggregate
                           Output: fooh1.a
                           Group Key: fooh1.a
                           ->  Sort
                                 Output: fooh1.a
                                 Sort Key: fooh1.a
                                 ->  Partial Seq Scan on orca.fooh1
                                       Output: fooh1.a
                                       Filter: (SubPlan 1)
                                       SubPlan 1
                                         ->  Result
                                               Output: true
                                               Filter: (0 = fooh2.a)
                                               ->  Limit
                                                     Output: fooh2.a
                                                     ->  Sort
                                                           Output: fooh2.a
                                                           Sort Key: fooh2.a
                                                           ->  Result
                                                                 Output: fooh2.a
                                                                 Filter: ((sum((fooh2.b + fooh1.a))) > 1)
                                                                 ->  HashAggregate
                                                                       Output: sum((fooh2.b + fooh1.a)), fooh2.a
                                                                       Group Key: fooh2.a
                                                                       ->  Full Seq Scan on orca.fooh2
                                                                             Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(39 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having 0 = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b + sum(f1.b)) > 1 order by f2.a limit 1) order by f1.a;
 a | one 
---+-----
 0 |   1
 1 |   1
 2 |   1
 3 |   1
(4 rows)

                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  Result
         Output: fooh1.a, 1
         Filter: (SubPlan 1)
         ->  Finalize GroupAggregate
               Output: sum(fooh1.b), fooh1.a
               Group Key: fooh1.a
               ->  Sort
                     Output: fooh1.a, (PARTIAL sum(fooh1.b))
                     Sort Key: fooh1.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: fooh1.a, (PARTIAL sum(fooh1.b))
                           Hash Key: fooh1.a
                           ->  Partial HashAggregate
                                 Output: fooh1.a, PARTIAL sum(fooh1.b)
                                 Group Key: fooh1.a
                                 ->  Partial Seq Scan on orca.fooh1
                                       Output: fooh1.a, fooh1.b
         SubPlan 1
           ->  Result
                 Output: true
                 Filter: (0 = fooh2.a)
                 ->  Limit
                       Output: fooh2.a
                       ->  Sort
                             Output: fooh2.a
                             Sort Key: fooh2.a
                             ->  Result
                                   Output: fooh2.a
                                   Filter: ((sum((fooh2.b + (sum(fooh1.b))))) > '1'::numeric)
                                   ->  HashAggregate
                                         Output: sum((fooh2.b + (sum(fooh1.b)))), fooh2.a
                                         Group Key: fooh2.a
                                         ->  Full Seq Scan on orca.fooh2
                                               Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(38 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having f1.a < (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b + 1) > f1.a order by f2.a desc limit 1) order by f1.a;
 a | one 
---+-----
 0 |   1
 1 |   1
(2 rows)

                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fooh1.a, (1)
   Merge Key: fooh1.a
   ->  GroupAggregate
         Output: fooh1.a, 1
         Group Key: fooh1.a
         ->  Sort
               Output: fooh1.a
               Sort Key: fooh1.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: fooh1.a
                     Hash Key: fooh1.a
                     ->  GroupAggregate
                           Output: fooh1.a
                           Group Key: fooh1.a
                           ->  Sort
                                 Output: fooh1.a
                                 Sort Key: fooh1.a
                                 ->  Partial Seq Scan on orca.fooh1
                                       Output: fooh1.a
                                       Filter: (fooh1.a < (SubPlan 1))
                                       SubPlan 1
                                         ->  Limit
                                               Output: fooh2.a
                                               ->  Sort
                                                     Output: fooh2.a
                                                     Sort Key: fooh2.a DESC
                                                     ->  Result
                                                           Output: fooh2.a
                                                           Filter: ((sum((fooh2.b + 1))) > fooh1.a)
                                                           ->  Materialize
                                                                 Output: fooh2.a, (sum((fooh2.b + 1)))
                                                                 ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                                       Output: fooh2.a, (sum((fooh2.b + 1)))
                                                                       ->  Finalize GroupAggregate
                                                                             Output: fooh2.a, sum((fooh2.b + 1))
                                                                             Group Key: fooh2.a
                                                                             ->  Sort
                                                                                   Output: fooh2.a, (PARTIAL sum((fooh2.b + 1)))
                                                                                   Sort Key: fooh2.a
                                                                                   ->  PX Hash 6:6  (slice4; segments: 6)
                                                                                         Output: fooh2.a, (PARTIAL sum((fooh2.b + 1)))
                                                                                         Hash Key: fooh2.a
                                                                                         ->  Partial HashAggregate
                                                                                               Output: fooh2.a, PARTIAL sum((fooh2.b + 1))
                                                                                               Group Key: fooh2.a
                                                                                               ->  Partial Seq Scan on orca.fooh2
                                                                                                     Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(49 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having f1.a = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b) + 1 > f1.a order by f2.a desc limit 1);
 a | one 
---+-----
 2 |   1
(1 row)

                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: fooh1.a, 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: fooh1.a
         ->  GroupAggregate
               Output: fooh1.a
               Group Key: fooh1.a
               ->  Sort
                     Output: fooh1.a
                     Sort Key: fooh1.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: fooh1.a
                           Hash Key: fooh1.a
                           ->  GroupAggregate
                                 Output: fooh1.a
                                 Group Key: fooh1.a
                                 ->  Sort
                                       Output: fooh1.a
                                       Sort Key: fooh1.a
                                       ->  Partial Seq Scan on orca.fooh1
                                             Output: fooh1.a
                                             Filter: (fooh1.a = (SubPlan 1))
                                             SubPlan 1
                                               ->  Limit
                                                     Output: fooh2.a
                                                     ->  Sort
                                                           Output: fooh2.a
                                                           Sort Key: fooh2.a DESC
                                                           ->  Result
                                                                 Output: fooh2.a
                                                                 Filter: (((sum(fooh2.b)) + 1) > fooh1.a)
                                                                 ->  Materialize
                                                                       Output: fooh2.a, (sum(fooh2.b))
                                                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                                             Output: fooh2.a, (sum(fooh2.b))
                                                                             ->  Finalize GroupAggregate
                                                                                   Output: fooh2.a, sum(fooh2.b)
                                                                                   Group Key: fooh2.a
                                                                                   ->  Sort
                                                                                         Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                         Sort Key: fooh2.a
                                                                                         ->  PX Hash 6:6  (slice4; segments: 6)
                                                                                               Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                                               Hash Key: fooh2.a
                                                                                               ->  Partial HashAggregate
                                                                                                     Output: fooh2.a, PARTIAL sum(fooh2.b)
                                                                                                     Group Key: fooh2.a
                                                                                                     ->  Partial Seq Scan on orca.fooh2
                                                                                                           Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(50 rows)

select f1.a, 1 as one from orca.fooh1 f1 group by f1.a having f1.a = (select f2.a from orca.fooh2 f2 group by f2.a having sum(f2.b) > 1 order by f2.a limit 1);
 a | one 
---+-----
 0 |   1
(1 row)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Result
   Output: fooh1.a, 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: fooh1.a
         ->  Hash Join
               Output: fooh1.a
               Hash Cond: (fooh1.a = fooh2.a)
               ->  GroupAggregate
                     Output: fooh1.a
                     Group Key: fooh1.a
                     ->  Sort
                           Output: fooh1.a
                           Sort Key: fooh1.a
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: fooh1.a
                                 Hash Key: fooh1.a
                                 ->  GroupAggregate
                                       Output: fooh1.a
                                       Group Key: fooh1.a
                                       ->  Sort
                                             Output: fooh1.a
                                             Sort Key: fooh1.a
                                             ->  Partial Seq Scan on orca.fooh1
                                                   Output: fooh1.a
               ->  Hash
                     Output: fooh2.a
                     ->  PX Broadcast 1:6  (slice3)
                           Output: fooh2.a
                           ->  Limit
                                 Output: fooh2.a
                                 ->  PX Coordinator 6:1  (slice4; segments: 6)
                                       Output: fooh2.a
                                       Merge Key: fooh2.a
                                       ->  Sort
                                             Output: fooh2.a
                                             Sort Key: fooh2.a
                                             ->  Result
                                                   Output: fooh2.a
                                                   Filter: ((sum(fooh2.b)) > 1)
                                                   ->  Finalize GroupAggregate
                                                         Output: sum(fooh2.b), fooh2.a
                                                         Group Key: fooh2.a
                                                         ->  Sort
                                                               Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                               Sort Key: fooh2.a
                                                               ->  PX Hash 6:6  (slice5; segments: 6)
                                                                     Output: fooh2.a, (PARTIAL sum(fooh2.b))
                                                                     Hash Key: fooh2.a
                                                                     ->  Partial HashAggregate
                                                                           Output: fooh2.a, PARTIAL sum(fooh2.b)
                                                                           Group Key: fooh2.a
                                                                           ->  Partial Seq Scan on orca.fooh2
                                                                                 Output: fooh2.a, fooh2.b
 Optimizer: PolarDB PX Optimizer
(54 rows)

select sum(f1.a+1)+1 from orca.fooh1 f1 group by f1.a+1;
 ?column? 
----------
        6
       16
       21
       11
(4 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((sum((a + 1)) + 1))
   ->  Finalize GroupAggregate
         Output: (sum((a + 1)) + 1)
         Group Key: ((fooh1.a + 1))
         ->  Sort
               Output: ((a + 1)), (PARTIAL sum((a + 1)))
               Sort Key: ((fooh1.a + 1))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: ((a + 1)), (PARTIAL sum((a + 1)))
                     Hash Key: ((a + 1))
                     ->  Partial HashAggregate
                           Output: ((a + 1)), PARTIAL sum((a + 1))
                           Group Key: (fooh1.a + 1)
                           ->  Partial Seq Scan on orca.fooh1
                                 Output: (a + 1), a
 Optimizer: PolarDB PX Optimizer
(17 rows)

select sum(f1.a+1)+sum(f1.a+1) from orca.fooh1 f1 group by f1.a+1;
 ?column? 
----------
       10
       30
       40
       20
(4 rows)

                    QUERY PLAN                    
--------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((sum((a + 1)) + sum((a + 1))))
   ->  HashAggregate
         Output: (sum((a + 1)) + sum((a + 1)))
         Group Key: ((fooh1.a + 1))
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: a, ((a + 1))
               Hash Key: ((a + 1))
               ->  Partial Seq Scan on orca.fooh1
                     Output: a, (a + 1)
 Optimizer: PolarDB PX Optimizer
(11 rows)

select sum(f1.a+1)+avg(f1.a+1), sum(f1.a), sum(f1.a+1) from orca.fooh1 f1 group by f1.a+1;
        ?column?        | sum | sum 
------------------------+-----+-----
 6.00000000000000000000 |   0 |   5
    18.0000000000000000 |  10 |  15
    24.0000000000000000 |  15 |  20
    12.0000000000000000 |   5 |  10
(4 rows)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (((sum((a + 1)))::numeric + avg((a + 1)))), (sum(a)), (sum((a + 1)))
   ->  HashAggregate
         Output: ((sum((a + 1)))::numeric + avg((a + 1))), sum(a), sum((a + 1))
         Group Key: ((fooh1.a + 1))
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: a, ((a + 1))
               Hash Key: ((a + 1))
               ->  Partial Seq Scan on orca.fooh1
                     Output: a, (a + 1)
 Optimizer: PolarDB PX Optimizer
(11 rows)

--
-- test algebrization of group by clause with subqueries
--
drop table if exists foo, bar, jazz;
NOTICE:  table "jazz" does not exist, skipping
create table foo (a int, b int, c int);
create table bar (d int, e int, f int);
create table jazz (g int, h int, j int);
insert into foo values (1, 1, 1), (2, 2, 2), (3, 3, 3);
insert into bar values (1, 1, 1), (2, 2, 2), (3, 3, 3);
insert into jazz values (2, 2, 2);
-- subquery with outer reference with aggfunc in target list
select a, (select sum(e) from bar where foo.b = bar.f), b, count(*) from foo, jazz where foo.c = jazz.g group by b, a, h;
 a | sum | b | count 
---+-----+---+-------
 2 |   2 | 2 |     1
(1 row)

                              QUERY PLAN                              
----------------------------------------------------------------------
 Hash Left Join
   Output: foo.a, (sum(bar.e)), foo.b, (count())
   Hash Cond: (foo.b = bar.f)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: foo.a, foo.b, (count())
         ->  GroupAggregate
               Output: foo.a, foo.b, count()
               Group Key: foo.b, foo.a, jazz.h
               ->  Sort
                     Output: foo.a, foo.b, jazz.h
                     Sort Key: foo.b, foo.a, jazz.h
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: foo.a, foo.b, jazz.h
                           Hash Key: foo.b, foo.a, jazz.h
                           ->  Hash Join
                                 Output: foo.a, foo.b, jazz.h
                                 Hash Cond: (foo.c = jazz.g)
                                 ->  Partial Seq Scan on orca.foo
                                       Output: foo.a, foo.b, foo.c
                                 ->  Hash
                                       Output: jazz.g, jazz.h
                                       ->  Full Seq Scan on orca.jazz
                                             Output: jazz.g, jazz.h
   ->  Hash
         Output: bar.f, (sum(bar.e))
         ->  PX Coordinator 6:1  (slice3; segments: 6)
               Output: bar.f, (sum(bar.e))
               ->  GroupAggregate
                     Output: bar.f, sum(bar.e)
                     Group Key: bar.f
                     ->  Sort
                           Output: bar.e, bar.f
                           Sort Key: bar.f
                           ->  PX Hash 6:6  (slice4; segments: 6)
                                 Output: bar.e, bar.f
                                 Hash Key: bar.f
                                 ->  Partial Seq Scan on orca.bar
                                       Output: bar.e, bar.f
 Optimizer: PolarDB PX Optimizer
(39 rows)

-- complex agg expr in subquery
select foo.a, (select (foo.a + foo.b) * count(bar.e) from bar), b, count(*) from foo group by foo.a, foo.b, foo.a + foo.b;
 a | ?column? | b | count 
---+----------+---+-------
 1 |        6 | 1 |     1
 2 |       12 | 2 |     1
 3 |       18 | 3 |     1
(3 rows)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, ((SubPlan 1)), foo.b, (count())
   ->  GroupAggregate
         Output: foo.a, (SubPlan 1), foo.b, count()
         Group Key: foo.a, foo.b, ((foo.a + foo.b))
         ->  Sort
               Output: foo.a, foo.b, ((foo.a + foo.b))
               Sort Key: foo.a, foo.b, ((foo.a + foo.b))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, foo.b, ((foo.a + foo.b))
                     Hash Key: foo.a, foo.b, ((foo.a + foo.b))
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, foo.b, (foo.a + foo.b)
         SubPlan 1
           ->  Result
                 Output: ((foo.a + foo.b) * (count(bar.e)))
                 ->  Materialize
                       Output: (count(bar.e))
                       ->  PX Broadcast 1:6  (slice3)
                             Output: (count(bar.e))
                             ->  Finalize Aggregate
                                   Output: count(bar.e)
                                   ->  PX Coordinator 6:1  (slice4; segments: 6)
                                         Output: (PARTIAL count(bar.e))
                                         ->  Partial Aggregate
                                               Output: PARTIAL count(bar.e)
                                               ->  Partial Seq Scan on orca.bar
                                                     Output: bar.e
 Optimizer: PolarDB PX Optimizer
(29 rows)

-- aggfunc over an outer reference in a subquery
select (select sum(foo.a + bar.d) from bar) from foo group by a, b;
 sum 
-----
   9
  12
  15
(3 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1))
   ->  GroupAggregate
         Output: (SubPlan 1)
         Group Key: foo.a, foo.b
         ->  Sort
               Output: foo.a, foo.b
               Sort Key: foo.a, foo.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, foo.b
                     Hash Key: foo.a, foo.b
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, foo.b
         SubPlan 1
           ->  Aggregate
                 Output: sum((foo.a + bar.d))
                 ->  Full Seq Scan on orca.bar
                       Output: bar.d
 Optimizer: PolarDB PX Optimizer
(19 rows)

-- complex expression of aggfunc over an outer reference in a subquery
select (select sum(foo.a + bar.d) + 1 from bar) from foo group by a, b;
 ?column? 
----------
       10
       13
       16
(3 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1))
   ->  GroupAggregate
         Output: (SubPlan 1)
         Group Key: foo.a, foo.b
         ->  Sort
               Output: foo.a, foo.b
               Sort Key: foo.a, foo.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, foo.b
                     Hash Key: foo.a, foo.b
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, foo.b
         SubPlan 1
           ->  Result
                 Output: ((sum((foo.a + bar.d))) + 1)
                 ->  Aggregate
                       Output: sum((foo.a + bar.d))
                       ->  Full Seq Scan on orca.bar
                             Output: bar.d
 Optimizer: PolarDB PX Optimizer
(21 rows)

-- aggrefs with multiple agglevelsup
select (select (select sum(foo.a + bar.d) from jazz) from bar) from foo group by a, b;
 sum 
-----
   9
  12
  15
(3 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 Result
   Output: (SubPlan 2)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: foo.a
         ->  GroupAggregate
               Output: foo.a
               Group Key: foo.a, foo.b
               ->  Sort
                     Output: foo.a, foo.b
                     Sort Key: foo.a, foo.b
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: foo.a, foo.b
                           Hash Key: foo.a, foo.b
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a, foo.b
   SubPlan 2
     ->  Aggregate
           Output: (SubPlan 1)
           ->  Materialize
                 Output: bar.d
                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                       Output: bar.d
                       ->  Partial Seq Scan on orca.bar
                             Output: bar.d
           SubPlan 1
             ->  Result
                   Output: sum((foo.a + bar.d))
                   ->  Materialize
                         ->  PX Coordinator 6:1  (slice4; segments: 6)
                               ->  Partial Seq Scan on orca.jazz
 Optimizer: PolarDB PX Optimizer
(31 rows)

-- aggrefs with multiple agglevelsup in an expression
select (select (select sum(foo.a + bar.d) * 2 from jazz) from bar) from foo group by a, b;
 ?column? 
----------
       18
       24
       30
(3 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 Result
   Output: (SubPlan 2)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: foo.a
         ->  GroupAggregate
               Output: foo.a
               Group Key: foo.a, foo.b
               ->  Sort
                     Output: foo.a, foo.b
                     Sort Key: foo.a, foo.b
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: foo.a, foo.b
                           Hash Key: foo.a, foo.b
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a, foo.b
   SubPlan 2
     ->  Aggregate
           Output: (SubPlan 1)
           ->  Materialize
                 Output: bar.d
                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                       Output: bar.d
                       ->  Partial Seq Scan on orca.bar
                             Output: bar.d
           SubPlan 1
             ->  Result
                   Output: (sum((foo.a + bar.d)) * 2)
                   ->  Materialize
                         ->  PX Coordinator 6:1  (slice4; segments: 6)
                               ->  Partial Seq Scan on orca.jazz
 Optimizer: PolarDB PX Optimizer
(31 rows)

-- nested group by
select (select max(f) from bar where d = 1 group by a, e) from foo group by a;
 max 
-----
   1
   1
   1
(3 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (max(bar.f))
   ->  Nested Loop Left Join
         Output: (max(bar.f))
         Join Filter: true
         ->  GroupAggregate
               Output: foo.a
               Group Key: foo.a
               ->  Sort
                     Output: foo.a
                     Sort Key: foo.a
                     ->  PX Hash 6:6  (slice5; segments: 6)
                           Output: foo.a
                           Hash Key: foo.a
                           ->  Partial Seq Scan on orca.foo
                                 Output: foo.a
         ->  Assert
               Output: (max(bar.f))
               Assert Cond: ((row_number() OVER (?)) = 1)
               ->  Materialize
                     Output: (max(bar.f)), (row_number() OVER (?))
                     ->  PX Broadcast 1:6  (slice2)
                           Output: (max(bar.f)), (row_number() OVER (?))
                           ->  WindowAgg
                                 Output: (max(bar.f)), row_number() OVER (?)
                                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                                       Output: (max(bar.f))
                                       ->  GroupAggregate
                                             Output: max(bar.f)
                                             Group Key: bar.e
                                             ->  Sort
                                                   Output: bar.e, bar.f
                                                   Sort Key: bar.e
                                                   ->  PX Hash 6:6  (slice4; segments: 6)
                                                         Output: bar.e, bar.f
                                                         Hash Key: bar.e
                                                         ->  Partial Seq Scan on orca.bar
                                                               Output: bar.e, bar.f
                                                               Filter: (bar.d = 1)
 Optimizer: PolarDB PX Optimizer
(40 rows)

-- cte with an aggfunc of outer ref
select a, count(*), (with cte as (select min(d) dd from bar group by e) select max(a * dd) from cte) from foo group by a;
 a | count | max 
---+-------+-----
 1 |     1 |   3
 2 |     1 |   6
 3 |     1 |   9
(3 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, (count()), ((SubPlan 1))
   ->  GroupAggregate
         Output: foo.a, count(), (SubPlan 1)
         Group Key: foo.a
         ->  Sort
               Output: foo.a
               Sort Key: foo.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a
                     Hash Key: foo.a
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a
         SubPlan 1
           ->  Aggregate
                 Output: max((foo.a * (min(bar.d))))
                 ->  Materialize
                       Output: (min(bar.d))
                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                             Output: (min(bar.d))
                             ->  Result
                                   Output: (min(bar.d))
                                   ->  GroupAggregate
                                         Output: min(bar.d), bar.e
                                         Group Key: bar.e
                                         ->  Sort
                                               Output: bar.d, bar.e
                                               Sort Key: bar.e
                                               ->  PX Hash 6:6  (slice4; segments: 6)
                                                     Output: bar.d, bar.e
                                                     Hash Key: bar.e
                                                     ->  Partial Seq Scan on orca.bar
                                                           Output: bar.d, bar.e
 Optimizer: PolarDB PX Optimizer
(34 rows)

-- cte with an aggfunc of outer ref in an complex expression
select a, count(*), (with cte as (select e, min(d) as dd from bar group by e) select max(a) * sum(dd) from cte) from foo group by a;
 a | count | ?column? 
---+-------+----------
 1 |     1 |        6
 2 |     1 |       12
 3 |     1 |       18
(3 rows)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, (count()), ((SubPlan 1))
   ->  GroupAggregate
         Output: foo.a, count(), (SubPlan 1)
         Group Key: foo.a
         ->  Sort
               Output: foo.a
               Sort Key: foo.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a
                     Hash Key: foo.a
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a
         SubPlan 1
           ->  Result
                 Output: (max(foo.a) * (sum((min(bar.d)))))
                 ->  Materialize
                       Output: (sum((min(bar.d))))
                       ->  PX Broadcast 1:6  (slice3)
                             Output: (sum((min(bar.d))))
                             ->  Finalize Aggregate
                                   Output: sum((min(bar.d)))
                                   ->  PX Coordinator 6:1  (slice4; segments: 6)
                                         Output: (PARTIAL sum((min(bar.d))))
                                         ->  Partial Aggregate
                                               Output: PARTIAL sum((min(bar.d)))
                                               ->  GroupAggregate
                                                     Output: min(bar.d), bar.e
                                                     Group Key: bar.e
                                                     ->  Sort
                                                           Output: bar.e, bar.d
                                                           Sort Key: bar.e
                                                           ->  PX Hash 6:6  (slice5; segments: 6)
                                                                 Output: bar.e, bar.d
                                                                 Hash Key: bar.e
                                                                 ->  Partial Seq Scan on orca.bar
                                                                       Output: bar.e, bar.d
 Optimizer: PolarDB PX Optimizer
(38 rows)

-- subquery in group by
select max(a) from foo group by (select e from bar where bar.e = foo.a);
 max 
-----
   1
   2
   3
(3 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (max(foo.a))
   ->  GroupAggregate
         Output: max(foo.a)
         Group Key: ((SubPlan 1))
         ->  Sort
               Output: foo.a, ((SubPlan 1))
               Sort Key: ((SubPlan 1))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, ((SubPlan 1))
                     Hash Key: ((SubPlan 1))
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, (SubPlan 1)
                           SubPlan 1
                             ->  Full Seq Scan on orca.bar
                                   Output: bar.e
                                   Filter: (bar.e = foo.a)
 Optimizer: PolarDB PX Optimizer
(18 rows)

-- nested subquery in group by
select max(a) from foo group by (select g from jazz where foo.a = (select max(a) from foo where c = 1 group by b));
 max 
-----
   1
   3
(2 rows)

                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (max(foo.a))
   ->  GroupAggregate
         Output: max(foo.a)
         Group Key: ((SubPlan 1))
         ->  Sort
               Output: foo.a, ((SubPlan 1))
               Sort Key: ((SubPlan 1))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, ((SubPlan 1))
                     Hash Key: ((SubPlan 1))
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, (SubPlan 1)
                           SubPlan 1
                             ->  Result
                                   Output: jazz.g
                                   Filter: (foo.a = (max(foo_1.a)))
                                   ->  Materialize
                                         Output: jazz.g, (max(foo_1.a))
                                         ->  PX Broadcast 1:6  (slice3)
                                               Output: jazz.g, (max(foo_1.a))
                                               ->  Nested Loop
                                                     Output: jazz.g, (max(foo_1.a))
                                                     Join Filter: true
                                                     ->  Assert
                                                           Output: (max(foo_1.a))
                                                           Assert Cond: ((row_number() OVER (?)) = 1)
                                                           ->  WindowAgg
                                                                 Output: row_number() OVER (?), (max(foo_1.a))
                                                                 ->  PX Coordinator 6:1  (slice5; segments: 6)
                                                                       Output: (max(foo_1.a))
                                                                       ->  Result
                                                                             Output: (max(foo_1.a))
                                                                             ->  GroupAggregate
                                                                                   Output: max(foo_1.a), foo_1.b
                                                                                   Group Key: foo_1.b
                                                                                   ->  Sort
                                                                                         Output: foo_1.a, foo_1.b
                                                                                         Sort Key: foo_1.b
                                                                                         ->  PX Hash 6:6  (slice6; segments: 6)
                                                                                               Output: foo_1.a, foo_1.b
                                                                                               Hash Key: foo_1.b
                                                                                               ->  Partial Seq Scan on orca.foo foo_1
                                                                                                     Output: foo_1.a, foo_1.b
                                                                                                     Filter: (foo_1.c = 1)
                                                     ->  Materialize
                                                           Output: jazz.g
                                                           ->  PX Coordinator 6:1  (slice4; segments: 6)
                                                                 Output: jazz.g
                                                                 ->  Partial Seq Scan on orca.jazz
                                                                       Output: jazz.g
 Optimizer: PolarDB PX Optimizer
(52 rows)

-- group by inside groupby inside group by
select max(a) from foo group by (select min(g) from jazz where foo.a = (select max(g) from jazz group by h) group by h);
 max 
-----
   2
   3
(2 rows)

                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (max(foo.a))
   ->  GroupAggregate
         Output: max(foo.a)
         Group Key: ((SubPlan 1))
         ->  Sort
               Output: foo.a, ((SubPlan 1))
               Sort Key: ((SubPlan 1))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, ((SubPlan 1))
                     Hash Key: ((SubPlan 1))
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, (SubPlan 1)
                           SubPlan 1
                             ->  Result
                                   Output: (min(jazz.g))
                                   ->  GroupAggregate
                                         Output: min(jazz.g), jazz.h
                                         Group Key: jazz.h
                                         ->  Sort
                                               Output: jazz.g, jazz.h
                                               Sort Key: jazz.h
                                               ->  Result
                                                     Output: jazz.g, jazz.h
                                                     Filter: (foo.a = (max(jazz_1.g)))
                                                     ->  Materialize
                                                           Output: jazz.g, jazz.h, (max(jazz_1.g))
                                                           ->  PX Broadcast 1:6  (slice3)
                                                                 Output: jazz.g, jazz.h, (max(jazz_1.g))
                                                                 ->  Nested Loop
                                                                       Output: jazz.g, jazz.h, (max(jazz_1.g))
                                                                       Join Filter: true
                                                                       ->  Assert
                                                                             Output: (max(jazz_1.g))
                                                                             Assert Cond: ((row_number() OVER (?)) = 1)
                                                                             ->  WindowAgg
                                                                                   Output: row_number() OVER (?), (max(jazz_1.g))
                                                                                   ->  PX Coordinator 6:1  (slice5; segments: 6)
                                                                                         Output: (max(jazz_1.g))
                                                                                         ->  Result
                                                                                               Output: (max(jazz_1.g))
                                                                                               ->  GroupAggregate
                                                                                                     Output: max(jazz_1.g), jazz_1.h
                                                                                                     Group Key: jazz_1.h
                                                                                                     ->  Sort
                                                                                                           Output: jazz_1.g, jazz_1.h
                                                                                                           Sort Key: jazz_1.h
                                                                                                           ->  PX Hash 6:6  (slice6; segments: 6)
                                                                                                                 Output: jazz_1.g, jazz_1.h
                                                                                                                 Hash Key: jazz_1.h
                                                                                                                 ->  Partial Seq Scan on orca.jazz jazz_1
                                                                                                                       Output: jazz_1.g, jazz_1.h
                                                                       ->  Materialize
                                                                             Output: jazz.g, jazz.h
                                                                             ->  PX Coordinator 6:1  (slice4; segments: 6)
                                                                                   Output: jazz.g, jazz.h
                                                                                   ->  Partial Seq Scan on orca.jazz
                                                                                         Output: jazz.g, jazz.h
 Optimizer: PolarDB PX Optimizer
(59 rows)

-- cte subquery in group by
select max(a) from foo group by b, (with cte as (select min(g) from jazz group by h) select a from cte);
 max 
-----
   1
   2
   3
(3 rows)

                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (max(foo.a))
   ->  GroupAggregate
         Output: max(foo.a)
         Group Key: foo.b, ((SubPlan 1))
         ->  Sort
               Output: foo.a, foo.b, ((SubPlan 1))
               Sort Key: foo.b, ((SubPlan 1))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: foo.a, foo.b, ((SubPlan 1))
                     Hash Key: foo.b, ((SubPlan 1))
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, foo.b, (SubPlan 1)
                           SubPlan 1
                             ->  Result
                                   Output: foo.a
                                   ->  Materialize
                                         ->  PX Broadcast 6:6  (slice3; segments: 6)
                                               ->  Result
                                                     ->  GroupAggregate
                                                           Output: min(jazz.g), jazz.h
                                                           Group Key: jazz.h
                                                           ->  Sort
                                                                 Output: jazz.g, jazz.h
                                                                 Sort Key: jazz.h
                                                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                                                       Output: jazz.g, jazz.h
                                                                       Hash Key: jazz.h
                                                                       ->  Partial Seq Scan on orca.jazz
                                                                             Output: jazz.g, jazz.h
 Optimizer: PolarDB PX Optimizer
(31 rows)

-- group by subquery in order by
select * from foo order by ((select min(bar.e + 1) * 2 from bar group by foo.a) - foo.a);
 a | b | c 
---+---+---
 3 | 3 | 3
 2 | 2 | 2
 1 | 1 | 1
(3 rows)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Result
   Output: foo.a, foo.b, foo.c
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: foo.a, foo.b, foo.c, (((((min((bar.e + 1))) * 2)) - foo.a))
         Merge Key: (((((min((bar.e + 1))) * 2)) - foo.a))
         ->  Sort
               Output: foo.a, foo.b, foo.c, (((((min((bar.e + 1))) * 2)) - foo.a))
               Sort Key: (((((min((bar.e + 1))) * 2)) - foo.a))
               ->  Nested Loop Left Join
                     Output: foo.a, foo.b, foo.c, ((((min((bar.e + 1))) * 2)) - foo.a)
                     Join Filter: true
                     ->  Partial Seq Scan on orca.foo
                           Output: foo.a, foo.b, foo.c
                     ->  Result
                           Output: ((min((bar.e + 1))) * 2)
                           ->  Materialize
                                 Output: (min((bar.e + 1)))
                                 ->  PX Broadcast 1:6  (slice2)
                                       Output: (min((bar.e + 1)))
                                       ->  Finalize Aggregate
                                             Output: min((bar.e + 1))
                                             ->  PX Coordinator 6:1  (slice3; segments: 6)
                                                   Output: (PARTIAL min((bar.e + 1)))
                                                   ->  Partial Aggregate
                                                         Output: PARTIAL min((bar.e + 1))
                                                         ->  Partial Seq Scan on orca.bar
                                                               Output: bar.e
 Optimizer: PolarDB PX Optimizer
(28 rows)

-- everything in the kitchen sink
select max(b), (select foo.a * count(bar.e) from bar), (with cte as (select e, min(d) as dd from bar group by e) select max(a) * sum(dd) from cte), count(*) from foo group by foo.a, (select min(g) from jazz where foo.a = (select max(g) from jazz group by h) group by h), (with cte as (select min(g) from jazz group by h) select a from cte) order by ((select min(bar.e + 1) * 2 from bar group by foo.a) - foo.a);
 max | ?column? | ?column? | count 
-----+----------+----------+-------
   3 |        9 |       18 |     1
   2 |        6 |       12 |     1
   1 |        3 |        6 |     1
(3 rows)

                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: (max(foo.b)), ((SubPlan 3)), ((SubPlan 4)), (count())
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (max(foo.b)), ((SubPlan 3)), ((SubPlan 4)), (count()), (((((min((bar.e + 1))) * 2)) - foo.a))
         Merge Key: (((((min((bar.e + 1))) * 2)) - foo.a))
         ->  Sort
               Output: (max(foo.b)), ((SubPlan 3)), ((SubPlan 4)), (count()), (((((min((bar.e + 1))) * 2)) - foo.a))
               Sort Key: (((((min((bar.e + 1))) * 2)) - foo.a))
               ->  Nested Loop Left Join
                     Output: (max(foo.b)), (SubPlan 3), (SubPlan 4), (count()), ((((min((bar.e + 1))) * 2)) - foo.a)
                     Join Filter: true
                     ->  GroupAggregate
                           Output: max(foo.b), max(foo.a), count(), foo.a, ((SubPlan 1)), ((SubPlan 2))
                           Group Key: foo.a, ((SubPlan 1)), ((SubPlan 2))
                           ->  Sort
                                 Output: foo.a, foo.b, ((SubPlan 1)), ((SubPlan 2))
                                 Sort Key: foo.a, ((SubPlan 1)), ((SubPlan 2))
                                 ->  PX Hash 6:6  (slice4; segments: 6)
                                       Output: foo.a, foo.b, ((SubPlan 1)), ((SubPlan 2))
                                       Hash Key: foo.a, ((SubPlan 1)), ((SubPlan 2))
                                       ->  Partial Seq Scan on orca.foo
                                             Output: foo.a, foo.b, (SubPlan 1), (SubPlan 2)
                                             SubPlan 1
                                               ->  Result
                                                     Output: (min(jazz.g))
                                                     ->  GroupAggregate
                                                           Output: min(jazz.g), jazz.h
                                                           Group Key: jazz.h
                                                           ->  Sort
                                                                 Output: jazz.g, jazz.h
                                                                 Sort Key: jazz.h
                                                                 ->  Result
                                                                       Output: jazz.g, jazz.h
                                                                       Filter: (foo.a = (max(jazz_1.g)))
                                                                       ->  Materialize
                                                                             Output: jazz.g, jazz.h, (max(jazz_1.g))
                                                                             ->  PX Broadcast 1:6  (slice5)
                                                                                   Output: jazz.g, jazz.h, (max(jazz_1.g))
                                                                                   ->  Nested Loop
                                                                                         Output: jazz.g, jazz.h, (max(jazz_1.g))
                                                                                         Join Filter: true
                                                                                         ->  Assert
                                                                                               Output: (max(jazz_1.g))
                                                                                               Assert Cond: ((row_number() OVER (?)) = 1)
                                                                                               ->  WindowAgg
                                                                                                     Output: row_number() OVER (?), (max(jazz_1.g))
                                                                                                     ->  PX Coordinator 6:1  (slice7; segments: 6)
                                                                                                           Output: (max(jazz_1.g))
                                                                                                           ->  Result
                                                                                                                 Output: (max(jazz_1.g))
                                                                                                                 ->  GroupAggregate
                                                                                                                       Output: max(jazz_1.g), jazz_1.h
                                                                                                                       Group Key: jazz_1.h
                                                                                                                       ->  Sort
                                                                                                                             Output: jazz_1.g, jazz_1.h
                                                                                                                             Sort Key: jazz_1.h
                                                                                                                             ->  PX Hash 6:6  (slice8; segments: 6)
                                                                                                                                   Output: jazz_1.g, jazz_1.h
                                                                                                                                   Hash Key: jazz_1.h
                                                                                                                                   ->  Partial Seq Scan on orca.jazz jazz_1
                                                                                                                                         Output: jazz_1.g, jazz_1.h
                                                                                         ->  Materialize
                                                                                               Output: jazz.g, jazz.h
                                                                                               ->  PX Coordinator 6:1  (slice6; segments: 6)
                                                                                                     Output: jazz.g, jazz.h
                                                                                                     ->  Partial Seq Scan on orca.jazz
                                                                                                           Output: jazz.g, jazz.h
                                             SubPlan 2
                                               ->  Result
                                                     Output: foo.a
                                                     ->  Materialize
                                                           ->  PX Broadcast 6:6  (slice9; segments: 6)
                                                                 ->  Result
                                                                       ->  GroupAggregate
                                                                             Output: min(jazz_2.g), jazz_2.h
                                                                             Group Key: jazz_2.h
                                                                             ->  Sort
                                                                                   Output: jazz_2.g, jazz_2.h
                                                                                   Sort Key: jazz_2.h
                                                                                   ->  PX Hash 6:6  (slice10; segments: 6)
                                                                                         Output: jazz_2.g, jazz_2.h
                                                                                         Hash Key: jazz_2.h
                                                                                         ->  Partial Seq Scan on orca.jazz jazz_2
                                                                                               Output: jazz_2.g, jazz_2.h
                     ->  Result
                           Output: ((min((bar.e + 1))) * 2)
                           ->  Materialize
                                 Output: (min((bar.e + 1)))
                                 ->  PX Broadcast 1:6  (slice2)
                                       Output: (min((bar.e + 1)))
                                       ->  Finalize Aggregate
                                             Output: min((bar.e + 1))
                                             ->  PX Coordinator 6:1  (slice3; segments: 6)
                                                   Output: (PARTIAL min((bar.e + 1)))
                                                   ->  Partial Aggregate
                                                         Output: PARTIAL min((bar.e + 1))
                                                         ->  Partial Seq Scan on orca.bar
                                                               Output: bar.e
                     SubPlan 3
                       ->  Result
                             Output: (foo.a * (count(bar_1.e)))
                             ->  Materialize
                                   Output: (count(bar_1.e))
                                   ->  PX Broadcast 1:6  (slice11)
                                         Output: (count(bar_1.e))
                                         ->  Finalize Aggregate
                                               Output: count(bar_1.e)
                                               ->  PX Coordinator 6:1  (slice12; segments: 6)
                                                     Output: (PARTIAL count(bar_1.e))
                                                     ->  Partial Aggregate
                                                           Output: PARTIAL count(bar_1.e)
                                                           ->  Partial Seq Scan on orca.bar bar_1
                                                                 Output: bar_1.e
                     SubPlan 4
                       ->  Result
                             Output: ((max(foo.a)) * (sum((min(bar_2.d)))))
                             ->  Materialize
                                   Output: (sum((min(bar_2.d))))
                                   ->  PX Broadcast 1:6  (slice13)
                                         Output: (sum((min(bar_2.d))))
                                         ->  Finalize Aggregate
                                               Output: sum((min(bar_2.d)))
                                               ->  PX Coordinator 6:1  (slice14; segments: 6)
                                                     Output: (PARTIAL sum((min(bar_2.d))))
                                                     ->  Partial Aggregate
                                                           Output: PARTIAL sum((min(bar_2.d)))
                                                           ->  GroupAggregate
                                                                 Output: min(bar_2.d), bar_2.e
                                                                 Group Key: bar_2.e
                                                                 ->  Sort
                                                                       Output: bar_2.e, bar_2.d
                                                                       Sort Key: bar_2.e
                                                                       ->  PX Hash 6:6  (slice15; segments: 6)
                                                                             Output: bar_2.e, bar_2.d
                                                                             Hash Key: bar_2.e
                                                                             ->  Partial Seq Scan on orca.bar bar_2
                                                                                   Output: bar_2.e, bar_2.d
 Optimizer: PolarDB PX Optimizer
(138 rows)

-- complex expression in group by & targetlist
select b + (a+1) from foo group by b, a+1;
 ?column? 
----------
        3
        5
        7
(3 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((b + ((a + 1))))
   ->  GroupAggregate
         Output: (b + ((a + 1)))
         Group Key: foo.b, ((foo.a + 1))
         ->  Sort
               Output: b, ((a + 1))
               Sort Key: foo.b, ((foo.a + 1))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: b, ((a + 1))
                     Hash Key: b, ((a + 1))
                     ->  Partial Seq Scan on orca.foo
                           Output: b, (a + 1)
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- subselects inside aggs
SELECT  foo.b+1, avg (( SELECT bar.f FROM bar WHERE bar.d = foo.b)) AS t FROM foo GROUP BY foo.b;
 ?column? |           t            
----------+------------------------
        2 | 1.00000000000000000000
        3 |     2.0000000000000000
        4 |     3.0000000000000000
(3 rows)

                     QUERY PLAN                      
-----------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((foo.b + 1)), (avg(((SubPlan 1))))
   ->  HashAggregate
         Output: (foo.b + 1), avg(((SubPlan 1)))
         Group Key: foo.b
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.b, ((SubPlan 1))
               Hash Key: foo.b
               ->  Partial Seq Scan on orca.foo
                     Output: foo.b, (SubPlan 1)
                     SubPlan 1
                       ->  Full Seq Scan on orca.bar
                             Output: bar.f
                             Filter: (bar.d = foo.b)
 Optimizer: PolarDB PX Optimizer
(15 rows)

SELECT foo.b+1, sum( 1 + (SELECT bar.f FROM bar WHERE bar.d = ANY (SELECT jazz.g FROM jazz WHERE jazz.h = foo.b))) AS t FROM foo GROUP BY foo.b;
 ?column? | t 
----------+---
        2 |  
        3 | 3
        4 |  
(3 rows)

                             QUERY PLAN                             
--------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((foo.b + 1)), (sum((1 + ((SubPlan 2)))))
   ->  HashAggregate
         Output: (foo.b + 1), sum((1 + ((SubPlan 2))))
         Group Key: foo.b
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.b, ((SubPlan 2))
               Hash Key: foo.b
               ->  Partial Seq Scan on orca.foo
                     Output: foo.b, (SubPlan 2)
                     SubPlan 2
                       ->  Result
                             Output: bar.f
                             ->  Full Seq Scan on orca.bar
                                   Output: bar.d, bar.f
                                   Filter: (SubPlan 1)
                                   SubPlan 1
                                     ->  Full Seq Scan on orca.jazz
                                           Output: jazz.g
                                           Filter: (jazz.h = bar.*)
 Optimizer: PolarDB PX Optimizer
(21 rows)

ERROR:  type integer is not composite
----COMPARE PX RESULT status not match(7, 2)
----COMPARE PX RESULT hash not match
select foo.b+1, sum((with cte as (select * from jazz) select 1 from cte where cte.h = foo.b)) as t FROM foo GROUP BY foo.b;
 ?column? | t 
----------+---
        2 |  
        3 | 1
        4 |  
(3 rows)

                         QUERY PLAN                         
------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((foo.b + 1)), (sum(((SubPlan 1))))
   ->  HashAggregate
         Output: (foo.b + 1), sum(((SubPlan 1)))
         Group Key: foo.b
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: foo.b, ((SubPlan 1))
               Hash Key: foo.b
               ->  Partial Seq Scan on orca.foo
                     Output: foo.b, (SubPlan 1)
                     SubPlan 1
                       ->  Result
                             Output: 1
                             ->  Full Seq Scan on orca.jazz
                                   Filter: (jazz.h = foo.b)
 Optimizer: PolarDB PX Optimizer
(16 rows)

-- ctes inside aggs
select foo.b+1, sum((with cte as (select * from jazz) select 1 from cte cte1, cte cte2 where cte1.h = foo.b)) as t FROM foo GROUP BY foo.b;
 ?column? | t 
----------+---
        2 |  
        3 | 1
        4 |  
(3 rows)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  No plan has been computed for required properties
drop table foo, bar, jazz;
create table orca.t77(C952 text);
insert into orca.t77 select 'text'::text;
insert into orca.t77 select 'mine'::text;
insert into orca.t77 select 'apple'::text;
insert into orca.t77 select 'orange'::text;
SELECT to_char(AVG( char_length(DT466.C952) ), '9999999.9999999'), MAX( char_length(DT466.C952) ) FROM orca.t77 DT466 GROUP BY char_length(DT466.C952);
     to_char      | max 
------------------+-----
        5.0000000 |   5
        4.0000000 |   4
        6.0000000 |   6
(3 rows)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (to_char(avg(char_length(c952)), '9999999.9999999'::text)), (max(char_length(c952)))
   ->  GroupAggregate
         Output: to_char(avg(char_length(c952)), '9999999.9999999'::text), max(char_length(c952))
         Group Key: (char_length(t77.c952))
         ->  Sort
               Output: c952, (char_length(c952))
               Sort Key: (char_length(t77.c952))
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: c952, (char_length(c952))
                     Hash Key: (char_length(c952))
                     ->  Partial Seq Scan on orca.t77
                           Output: c952, char_length(c952)
 Optimizer: PolarDB PX Optimizer
(14 rows)

create table orca.prod9 (sale integer, prodnm varchar,price integer);
insert into orca.prod9 values (100, 'shirts', 500);
insert into orca.prod9 values (200, 'pants',800);
insert into orca.prod9 values (300, 't-shirts', 300);
-- returning product and price using Having and Group by clause
select prodnm, price from orca.prod9 GROUP BY prodnm, price HAVING price !=300;
 prodnm | price 
--------+-------
 pants  |   800
 shirts |   500
(2 rows)

                       QUERY PLAN                       
--------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: prodnm, price
   ->  GroupAggregate
         Output: prodnm, price
         Group Key: prod9.prodnm, prod9.price
         ->  Sort
               Output: prodnm, price
               Sort Key: prod9.prodnm, prod9.price
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: prodnm, price
                     Hash Key: prodnm, price
                     ->  Partial Seq Scan on orca.prod9
                           Output: prodnm, price
                           Filter: (prod9.price <> 300)
 Optimizer: PolarDB PX Optimizer
(15 rows)

-- analyze on tables with dropped attributes
create table orca.toanalyze(a int, b int);
insert into orca.toanalyze values (1,1), (2,2), (3,3);
alter table orca.toanalyze drop column a;
analyze orca.toanalyze;
-- union
create table orca.ur (a int, b int);
create table orca.us (c int, d int);
create table orca.ut(a int);
create table orca.uu(c int, d bigint);
insert into orca.ur values (1,1);
insert into orca.ur values (1,2);
insert into orca.ur values (2,1);
insert into orca.us values (1,3);
insert into orca.ut values (3);
insert into orca.uu values (1,3);
select * from (select a, a from orca.ur union select c, d from orca.us) x(g,h);
 g | h 
---+---
 1 | 3
 2 | 2
 1 | 1
(3 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ur.a, ur.a
   ->  GroupAggregate
         Output: ur.a, ur.a
         Group Key: ur.a, ur.a
         ->  Sort
               Output: ur.a, ur.a
               Sort Key: ur.a, ur.a
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: ur.a, ur.a
                     Hash Key: ur.a, ur.a
                     ->  Append
                           ->  Partial Seq Scan on orca.ur
                                 Output: ur.a, ur.a
                           ->  Partial Seq Scan on orca.us
                                 Output: us.c, us.d
 Optimizer: PolarDB PX Optimizer
(17 rows)

select * from (select a, a from orca.ur union select c, d from orca.us) x(g,h), orca.ut t where t.a = x.h;
 g | h | a 
---+---+---
 1 | 3 | 3
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ur.a, ur.a, ut.a
   ->  Hash Join
         Output: ur.a, ur.a, ut.a
         Hash Cond: (ur.a = ut.a)
         ->  GroupAggregate
               Output: ur.a, ur.a
               Group Key: ur.a, ur.a
               ->  Sort
                     Output: ur.a, ur.a
                     Sort Key: ur.a, ur.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: ur.a, ur.a
                           Hash Key: ur.a, ur.a
                           ->  Append
                                 ->  Partial Seq Scan on orca.ur
                                       Output: ur.a, ur.a
                                 ->  Partial Seq Scan on orca.us
                                       Output: us.c, us.d
         ->  Hash
               Output: ut.a
               ->  Full Seq Scan on orca.ut
                     Output: ut.a
 Optimizer: PolarDB PX Optimizer
(24 rows)

select * from (select a, a from orca.ur union select c, d from orca.uu) x(g,h), orca.ut t where t.a = x.h;
 g | h | a 
---+---+---
 1 | 3 | 3
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ur.a, ((ur.a)::bigint), ut.a
   ->  Hash Join
         Output: ur.a, ((ur.a)::bigint), ut.a
         Hash Cond: (((ur.a)::bigint) = (ut.a)::bigint)
         ->  GroupAggregate
               Output: ur.a, ((ur.a)::bigint)
               Group Key: ur.a, ((ur.a)::bigint)
               ->  Sort
                     Output: ur.a, ((ur.a)::bigint)
                     Sort Key: ur.a, ((ur.a)::bigint)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: ur.a, ((ur.a)::bigint)
                           Hash Key: ur.a, ((ur.a)::bigint)
                           ->  Append
                                 ->  Partial Seq Scan on orca.ur
                                       Output: ur.a, ur.a
                                 ->  Partial Seq Scan on orca.uu
                                       Output: uu.c, uu.d
         ->  Hash
               Output: ut.a
               ->  Full Seq Scan on orca.ut
                     Output: ut.a
 Optimizer: PolarDB PX Optimizer
(24 rows)

select 1 AS two UNION select 2.2;
 two 
-----
   1
 2.2
(2 rows)

select 2.2 AS two UNION select 1;
 two 
-----
   1
 2.2
(2 rows)

select * from (select 2.2 AS two UNION select 1) x(a), (select 1.0 AS two UNION ALL select 1) y(a) where y.a = x.a;
 a |  a  
---+-----
 1 | 1.0
 1 |   1
(2 rows)

-- window functions inside inline CTE
CREATE TABLE orca.twf1 AS SELECT i as a, i+1 as b from generate_series(1,10)i;
CREATE TABLE orca.twf2 AS SELECT i as c, i+1 as d from generate_series(1,10)i;
set polar_px_optimizer_cte_inlining_bound=1000;
set polar_px_optimizer_cte_inlining = on;
WITH CTE(a,b) AS
(SELECT a,d FROM orca.twf1, orca.twf2 WHERE a = d),
CTE1(e,f) AS
( SELECT f1.a, rank() OVER (PARTITION BY f1.b ORDER BY CTE.a) FROM orca.twf1 f1, CTE )
SELECT * FROM CTE1,CTE WHERE CTE.a = CTE1.f and CTE.a = 2 ORDER BY 1;
 e  | f | a | b 
----+---+---+---
  1 | 2 | 2 | 2
  2 | 2 | 2 | 2
  3 | 2 | 2 | 2
  4 | 2 | 2 | 2
  5 | 2 | 2 | 2
  6 | 2 | 2 | 2
  7 | 2 | 2 | 2
  8 | 2 | 2 | 2
  9 | 2 | 2 | 2
 10 | 2 | 2 | 2
(10 rows)

                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: twf1_1.a, (rank() OVER (?)), share0_ref2.a, share0_ref2.d
   Merge Key: twf1_1.a
   ->  Sequence
         Output: twf1_1.a, (rank() OVER (?)), share0_ref2.a, share0_ref2.d
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.d
               ->  Hash Join
                     Output: twf1.a, twf2.d
                     Hash Cond: (twf1.a = twf2.d)
                     ->  Partial Seq Scan on orca.twf1
                           Output: twf1.a
                     ->  Hash
                           Output: twf2.d
                           ->  Full Seq Scan on orca.twf2
                                 Output: twf2.d
         ->  Sort
               Output: twf1_1.a, (rank() OVER (?)), share0_ref2.a, share0_ref2.d
               Sort Key: twf1_1.a
               ->  Hash Join
                     Output: twf1_1.a, (rank() OVER (?)), share0_ref2.a, share0_ref2.d
                     Hash Cond: (((rank() OVER (?)) = (share0_ref2.a)::bigint) AND ((rank() OVER (?)) = (share0_ref2.a)::bigint) AND ((rank() OVER (?)) = (share0_ref2.d)::bigint))
                     ->  Result
                           Output: twf1_1.a, (rank() OVER (?))
                           Filter: ((rank() OVER (?)) = 2)
                           ->  WindowAgg
                                 Output: rank() OVER (?), twf1_1.a, twf1_1.b, share0_ref3.a
                                 ->  Sort
                                       Output: twf1_1.a, twf1_1.b, share0_ref3.a
                                       Sort Key: twf1_1.b, share0_ref3.a
                                       ->  PX Hash 6:6  (slice2; segments: 6)
                                             Output: twf1_1.a, twf1_1.b, share0_ref3.a
                                             Hash Key: twf1_1.b
                                             ->  Nested Loop
                                                   Output: twf1_1.a, twf1_1.b, share0_ref3.a
                                                   Join Filter: true
                                                   ->  Partial Seq Scan on orca.twf1 twf1_1
                                                         Output: twf1_1.a, twf1_1.b
                                                   ->  Materialize
                                                         Output: share0_ref3.a
                                                         ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                               Output: share0_ref3.a
                                                               ->  Result
                                                                     Output: share0_ref3.a
                                                                     Filter: (share0_ref3.a = share0_ref3.d)
                                                                     ->  Shared Scan (Consumer; slice3; share0)
                                                                           Output: share0_ref3.a, share0_ref3.d
                     ->  Hash
                           Output: share0_ref2.a, share0_ref2.d
                           ->  PX Broadcast 6:6  (slice4; segments: 6)
                                 Output: share0_ref2.a, share0_ref2.d
                                 ->  Result
                                       Output: share0_ref2.a, share0_ref2.d
                                       Filter: ((share0_ref2.a = 2) AND (share0_ref2.d = 2) AND (share0_ref2.a = share0_ref2.d))
                                       ->  Shared Scan (Consumer; slice4; share0)
                                             Output: share0_ref2.a, share0_ref2.d
 Optimizer: PolarDB PX Optimizer
(57 rows)

REset polar_px_optimizer_cte_inlining;
REset polar_px_optimizer_cte_inlining_bound;
-- catalog queries
select 1 from pg_class c group by c.oid limit 1;
 ?column? 
----------
        1
(1 row)

-- CSQs
drop table if exists orca.tab1;
drop table if exists orca.tab2;
NOTICE:  table "tab2" does not exist, skipping
create table orca.tab1 (i, j) as select i,i%2 from generate_series(1,10) i;
create table orca.tab2 (a, b) as select 1, 2;
select * from orca.tab1 where 0 < (select count(*) from generate_series(1,i)) order by 1;
 i  | j 
----+---
  1 | 1
  2 | 0
  3 | 1
  4 | 0
  5 | 1
  6 | 0
  7 | 1
  8 | 0
  9 | 1
 10 | 0
(10 rows)

select * from orca.tab1 where i > (select b from orca.tab2);
 i  | j 
----+---
  3 | 1
  4 | 0
  5 | 1
  6 | 0
  7 | 1
  8 | 0
  9 | 1
 10 | 0
(8 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tab1.i, tab1.j
   ->  Partial Seq Scan on orca.tab1
         Output: tab1.i, tab1.j
         Filter: (tab1.i > (SubPlan 1))
         SubPlan 1
           ->  Full Seq Scan on orca.tab2
                 Output: tab2.b
 Optimizer: PolarDB PX Optimizer
(9 rows)

-- subqueries
select NULL in (select 1);
 ?column? 
----------
 
(1 row)

select 1 in (select 1);
 ?column? 
----------
 t
(1 row)

select 1 in (select 2);
 ?column? 
----------
 f
(1 row)

select NULL in (select 1/0);
ERROR:  division by zero
select 1 where 22 in (SELECT unnest(array[1,2]));
 ?column? 
----------
(0 rows)

select 1 where 22 not in (SELECT unnest(array[1,2]));
 ?column? 
----------
        1
(1 row)

select 1 where 22 in (SELECT generate_series(1,10));
 ?column? 
----------
(0 rows)

select 1 where 22 not in (SELECT generate_series(1,10));
 ?column? 
----------
        1
(1 row)

-- UDAs
CREATE FUNCTION sum_sfunc(anyelement,anyelement) returns anyelement AS 'select $1+$2' LANGUAGE SQL STRICT;
CREATE FUNCTION sum_combinefunc(anyelement,anyelement) returns anyelement AS 'select $1+$2' LANGUAGE SQL STRICT;
CREATE AGGREGATE myagg1(anyelement) (SFUNC = sum_sfunc, COMBINEFUNC = sum_combinefunc, STYPE = anyelement, INITCOND = '0');
SELECT myagg1(i) FROM orca.tab1;
 myagg1 
--------
     55
(1 row)

                   QUERY PLAN                    
-------------------------------------------------
 Aggregate
   Output: myagg1(i)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: i
         ->  Partial Seq Scan on orca.tab1
               Output: i
 Optimizer: PolarDB PX Optimizer
(7 rows)

CREATE FUNCTION sum_sfunc2(anyelement,anyelement,anyelement) returns anyelement AS 'select $1+$2+$3' LANGUAGE SQL STRICT;
CREATE AGGREGATE myagg2(anyelement,anyelement) (SFUNC = sum_sfunc2, STYPE = anyelement, INITCOND = '0');
SELECT myagg2(i,j) FROM orca.tab1;
 myagg2 
--------
     60
(1 row)

                   QUERY PLAN                    
-------------------------------------------------
 Aggregate
   Output: myagg2(i, j)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: i, j
         ->  Partial Seq Scan on orca.tab1
               Output: i, j
 Optimizer: PolarDB PX Optimizer
(7 rows)

CREATE FUNCTION gptfp(anyarray,anyelement) RETURNS anyarray AS 'select $1 || $2' LANGUAGE SQL;
CREATE FUNCTION gpffp(anyarray) RETURNS anyarray AS 'select $1' LANGUAGE SQL;
CREATE AGGREGATE myagg3(BASETYPE = anyelement, SFUNC = gptfp, STYPE = anyarray, FINALFUNC = gpffp, INITCOND = '{}');
CREATE TABLE array_table(f1 int, f2 int[], f3 text);
INSERT INTO array_table values(1,array[1],'a');
INSERT INTO array_table values(2,array[11],'b');
INSERT INTO array_table values(3,array[111],'c');
INSERT INTO array_table values(4,array[2],'a');
INSERT INTO array_table values(5,array[22],'b');
INSERT INTO array_table values(6,array[222],'c');
INSERT INTO array_table values(7,array[3],'a');
INSERT INTO array_table values(8,array[3],'b');
SELECT f3, myagg3(f1) from (select * from array_table order by f1 limit 10) as foo GROUP BY f3 ORDER BY f3;
 f3 | myagg3  
----+---------
 a  | {4,1,7}
 b  | {8,2,5}
 c  | {6,3}
(3 rows)

                             QUERY PLAN                             
--------------------------------------------------------------------
 GroupAggregate
   Output: f3, myagg3(f1)
   Group Key: array_table.f3
   ->  Sort
         Output: f1, f3
         Sort Key: array_table.f3
         ->  Limit
               Output: f1, f3
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: f1, f3
                     Merge Key: f1
                     ->  Sort
                           Output: f1, f3
                           Sort Key: array_table.f1
                           ->  Partial Seq Scan on orca.array_table
                                 Output: f1, f3
 Optimizer: PolarDB PX Optimizer
(17 rows)

-- MPP-22453: wrong result in indexscan when the indexqual compares different data types
create table mpp22453(a int, d date);
insert into mpp22453 values (1, '2012-01-01'), (2, '2012-01-02'), (3, '2012-12-31');
create index mpp22453_idx on mpp22453(d);
set polar_px_optimizer_enable_seqscan = off;
select * from mpp22453 where d > date '2012-01-31' + interval '1 day' ;
 a |     d      
---+------------
 3 | 12-31-2012
(1 row)

                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, d
   ->  Partial Index Scan using mpp22453_idx on orca.mpp22453
         Output: a, d
         Index Cond: (mpp22453.d > 'Wed Feb 01 00:00:00 2012'::timestamp without time zone)
 Optimizer: PolarDB PX Optimizer
(6 rows)

select * from mpp22453 where d > '2012-02-01';
 a |     d      
---+------------
 3 | 12-31-2012
(1 row)

                          QUERY PLAN                          
--------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, d
   ->  Partial Index Scan using mpp22453_idx on orca.mpp22453
         Output: a, d
         Index Cond: (mpp22453.d > '02-01-2012'::date)
 Optimizer: PolarDB PX Optimizer
(6 rows)

reset polar_px_optimizer_enable_seqscan;
-- MPP-22791: SIGSEGV when querying a table with default partition only
create table mpp22791(a int, b int) partition by range(b);
CREATE TABLE d PARTITION of mpp22791 default;
insert into mpp22791 values (1, 1), (2, 2), (3, 3);
select * from mpp22791 where b > 1;
 a | b 
---+---
 2 | 2
 3 | 3
(2 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: d.a, d.b
   ->  Append
         ->  Partial Seq Scan on orca.d
               Output: d.a, d.b
               Filter: (d.b > 1)
 Optimizer: PolarDB PX Optimizer
(7 rows)

select * from mpp22791 where b <= 3;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: d.a, d.b
   ->  Append
         ->  Partial Seq Scan on orca.d
               Output: d.a, d.b
               Filter: (d.b <= 3)
 Optimizer: PolarDB PX Optimizer
(7 rows)

-- MPP-20713, MPP-20714, MPP-20738: Const table get with a filter
select 1 as x where 1 in (2, 3);
 x 
---
(0 rows)

-- MPP-23081: keys of partitioned tables
create table orca.p1(a int) partition by range(a);
CREATE TABLE orcap1_p1 PARTITION of orca.p1 for values from (1) to (10);
CREATE TABLE orcap1_p2 PARTITION of orca.p1 for values from (10) to (20);
insert into orca.p1 select * from generate_series(2,15);
select count(*) from (select gp_segment_id,ctid,tableoid from orca.p1 group by gp_segment_id,ctid,tableoid) as foo;
ERROR:  column "gp_segment_id" does not exist
LINE 1: select count(*) from (select gp_segment_id,ctid,tableoid fro...
                                     ^
-- MPP-25194: histograms on text columns are dropped in ORCA. NDVs of these histograms should be added to NDVRemain
CREATE TABLE orca.tmp_verd_s_pp_provtabs_agt_0015_extract1 (
    uid136 character(16),
    tab_nr smallint,
    prdgrp character(5),
    bg smallint,
    typ142 smallint,
    ad_gsch smallint,
    guelt_ab date,
    guelt_bis date,
    guelt_stat text,
    verarb_ab timestamp(5) without time zone,
    u_erzeugen integer,
    grenze integer,
    erstellt_am_122 timestamp(5) without time zone,
    erstellt_am_135 timestamp(5) without time zone,
    erstellt_am_134 timestamp(5) without time zone
);
 set allow_system_table_mods=true;
 UPDATE pg_class
 SET
         relpages = 30915::int, reltuples = 7.28661e+07::real WHERE relname = 'tmp_verd_s_pp_provtabs_agt_0015_extract1' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'xvclin');
insert into pg_statistic
values (
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  1::smallint,
  'f',
  0::real,
  17::integer,
  264682::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  1054::oid,
  1058::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.000161451,0.000107634,0.000107634,0.000107634,0.000107634,0.000107634,0.000107634,0.000107634,0.000107634,0.000107634,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{8X8#1F8V92A2025G,YFAXQ§UBF210PA0P,2IIVIE8V92A2025G,9§BP8F8V92A2025G,35A9EE8V92A2025G,§AJ2Z§9MA210PA0P,3NUQ3E8V92A2025G,F7ZD4F8V92A2025G,$WHHEO§§E210PA0P,Z6EATH2BE210PA0P,N7I28E8V92A2025G,YU0K$E$§9210PA0P,3TAI1ANIF210PA0P,P#H8BF8V92A2025G,VTQ$N$D§92A201SC,N7ZD4F8V92A2025G,77BP8F8V92A2025G,39XOXY78H210PA01,#2#OX6NHH210PA01,2DG1J#XZH210PA01,MFEG$E8V92A2025G,M0HKWNGND210PA0P,FSXI67NSA210PA0P,C1L77E8V92A2025G,01#21E8V92A2025G}'::bpchar[],
  '{§00§1HKZC210PA0P,1D90GE8V92A2025G,2ULZI6L0O210PA01,489G7L8$I210PA01,5RE8FF8V92A2025G,76NIRFNIF210PA0P,8KOMKE8V92A2025G,#9Y#GPSHB210PA0P,BDAJ#D8V92A2025G,CV9Z7IYVK210PA01,#EC5FE8V92A2025G,FQWY§O1XC210PA0P,H8HL4E8V92A2025G,INC5FE8V92A2025G,K4MX0XHCF210PA0P,LKE8FF8V92A2025G,N03G9UM2F210PA0P,OHJ$#GFZ9210PA0P,PXU3T1OTB210PA0P,RCUA45F1H210PA01,SU§FRY#QI210PA01,UABHMLSLK210PA01,VRBP8F8V92A2025G,X65#KZIDC210PA0P,YLFG§#A2G210PA0P,ZZG8H29OC210PA0P,ZZZDBCEVA210PA0P}'::bpchar[],
  NULL::bpchar[],
  NULL::bpchar[],
  NULL::bpchar[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  2::smallint,
  'f',
  0::real,
  2::integer,
  205.116::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  94::oid,
  95::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.278637,0.272448,0.0303797,0.0301106,0.0249442,0.0234373,0.0231682,0.0191319,0.0169793,0.0162527,0.0142884,0.0141539,0.0125394,0.0103329,0.0098216,0.00944488,0.00850308,0.00715766,0.0066464,0.00656567,0.00591987,0.0050588,0.00454753,0.00449372,0.0044399}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{199,12,14,5,197,11,198,8,152,299,201,153,9,13,74,179,24,202,2,213,17,195,215,16,200}'::int2[],
  '{1,5,9,12,14,24,58,80,152,195,198,199,207,302,402}'::int2[],
  NULL::int2[],
  NULL::int2[],
  NULL::int2[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  3::smallint,
  'f',
  0::real,
  6::integer,
  201.005::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  1054::oid,
  1058::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.0478164,0.0439146,0.0406856,0.0239755,0.0154186,0.0149073,0.0148804,0.0143422,0.0141808,0.0139386,0.0138848,0.0138848,0.0137502,0.0134812,0.0134004,0.0133197,0.0133197,0.013239,0.0131852,0.0130775,0.0130775,0.0130237,0.0129699,0.0129699,0.012943}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{AG023,AG032,AG999,AG022,AG--B,AG-VB,AG--C,AG-VC,AG014,AG-VA,AG036,AGT4C,AG--A,AG037,AG009,AG015,AG003,AG002,AGT3C,AG025,AG019,AGT2C,AGT1C,AG005,AG031}'::bpchar[],
  '{AG001,AG004,AG007,AG010,AG013,AG017,AG020,AG022,AG023,AG026,AG030,AG032,AG034,AG037,AG040,AG045,AG122,AG999,AG--B,AGT1C,AGT4C,AG-VB,MA017,MA--A,MK081,MKRKV}'::bpchar[],
  NULL::bpchar[],
  NULL::bpchar[],
  NULL::bpchar[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  4::smallint,
  'f',
  0::real,
  2::integer,
  34::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  94::oid,
  95::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.1135,0.112881,0.111778,0.100288,0.0895245,0.0851384,0.0821785,0.0723569,0.0565616,0.0368646,0.0309986,0.0160375,0.00621586,0.00594677,0.0050588,0.00489734,0.00487044,0.00487044,0.00468208,0.00462826,0.00460135,0.00441299,0.00438608,0.00417081,0.00414391}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1,3,2,7,9,4,5,16,10,6,8,77,12,11,14,13,22,23,64,61,24,51,53,15,54}'::int2[],
  '{1,2,3,4,5,6,7,9,10,14,16,17,53,98}'::int2[],
  NULL::int2[],
  NULL::int2[],
  NULL::int2[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  5::smallint,
  'f',
  0::real,
  2::integer,
  1::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  94::oid,
  95::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{1}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1}'::int2[],
  '{1}'::int2[],
  NULL::int2[],
  NULL::int2[],
  NULL::int2[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  6::smallint,
  'f',
  0::real,
  2::integer,
  2::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  94::oid,
  95::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.850227,0.149773}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1,2}'::int2[],
  '{1,2}'::int2[],
  NULL::int2[],
  NULL::int2[],
  NULL::int2[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  7::smallint,
  'f',
  0::real,
  4::integer,
  591.134::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  1093::oid,
  1095::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.26042,0.0859995,0.0709308,0.0616473,0.0567231,0.0303797,0.0109787,0.0106289,0.00990232,0.00987541,0.00979469,0.00944488,0.00820709,0.00718457,0.00626968,0.00621586,0.00616204,0.00600059,0.00586605,0.00557006,0.00516643,0.00511261,0.0050857,0.0050857,0.0047628}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1994-01-01,1997-01-01,2005-07-01,1999-01-01,2003-09-01,2000-01-01,2001-01-01,1998-10-01,2001-05-01,1999-03-01,2013-01-01,2003-01-01,2008-01-01,2004-01-01,2009-01-01,2003-02-01,1998-09-01,2000-12-01,2007-04-01,1998-08-01,1998-01-01,2003-07-01,1998-11-01,2005-02-01,1999-04-01}'::date[],
  '{1900-01-01,1994-01-01,1997-01-01,1998-05-07,1999-01-01,1999-05-01,2000-01-01,2001-03-22,2002-10-01,2003-09-01,2004-08-01,2005-07-01,2007-01-01,2008-06-01,2010-04-01,2012-07-01,2014-12-01,2015-01-01}'::date[],
  NULL::date[],
  NULL::date[],
  NULL::date[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  8::smallint,
  'f',
  0::real,
  4::integer,
  474.232::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  1093::oid,
  1095::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.52111,0.0709308,0.0591987,0.0587412,0.0148804,0.010279,0.00990232,0.00931034,0.00791109,0.00718457,0.00688857,0.00608132,0.00557006,0.0053817,0.00503189,0.00500498,0.00457444,0.004117,0.00395555,0.00390173,0.00357883,0.00352501,0.00352501,0.00344429,0.00333665}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{9999-12-31,2005-07-01,1999-01-01,2003-09-01,2004-02-01,2001-05-01,2005-02-01,1999-03-01,1998-10-01,2000-01-01,2003-01-01,1998-09-01,1998-08-01,2008-01-01,2007-04-01,2000-12-01,1999-04-01,1998-11-01,2003-02-01,1994-01-01,2002-09-01,1999-02-01,2004-01-01,1998-07-01,2003-07-01}'::date[],
  '{1994-01-01,1998-11-01,1999-01-01,1999-04-01,2001-05-01,2003-07-01,2003-09-01,2004-02-01,2005-07-01,2007-02-01,2010-03-01,9999-12-31}'::date[],
  NULL::date[],
  NULL::date[],
  NULL::date[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  9::smallint,
  'f',
  0::real,
  2::integer,
  1::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  98::oid,
  664::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{1}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{H}'::text[],
  '{H}'::text[],
  NULL::text[],
  NULL::text[],
  NULL::text[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  10::smallint,
  'f',
  0::real,
  8::integer,
  1::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  2060::oid,
  2062::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{1}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1900-01-01 00:00:00}'::timestamp[],
  '{1900-01-01 00:00:00}'::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  11::smallint,
  'f',
  1::real,
  0::integer,
  -1::real,
  0::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::int4[],
  NULL::int4[],
  NULL::int4[],
  NULL::int4[],
  NULL::int4[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  12::smallint,
  'f',
  0::real,
  4::integer,
  1::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  96::oid,
  97::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{1}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1}'::int4[],
  '{1}'::int4[],
  NULL::int4[],
  NULL::int4[],
  NULL::int4[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  13::smallint,
  'f',
  0.991927::real,
  8::integer,
  301.416::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  2060::oid,
  2062::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{8.07255e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05,2.69085e-05}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{2004-01-05 13:45:06.18894,2007-03-20 12:02:33.73888,2009-12-15 12:33:55.32684,2012-09-21 09:58:09.70321,2012-02-13 14:56:03.11625,2000-10-02 09:56:01.24836,1998-01-14 10:11:29.43055,2014-01-08 14:41:44.85935,2012-06-21 12:46:37.48899,2013-07-23 14:27:52.27322,2011-10-27 16:17:10.01694,2005-07-13 16:55:30.7964,2003-06-05 14:53:13.71932,2002-07-22 10:22:31.0967,2011-12-27 16:12:54.85765,2001-01-12 11:40:09.16207,2005-12-30 08:46:31.30943,2007-03-01 08:29:36.765,2011-06-16 09:09:43.8651,2000-12-15 14:33:29.20083,2006-04-25 13:46:46.09684,2011-06-20 16:26:23.65135,2004-01-23 12:37:06.92535,2002-03-04 10:02:08.92547,2003-08-01 10:33:57.33683}'::timestamp[],
  '{1997-12-05 10:59:43.94611,2014-11-18 08:48:18.32773}'::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  14::smallint,
  'f',
  0.329817::real,
  8::integer,
  38109.5::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  2060::oid,
  2062::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.0715766,0.0621317,0.00546242,0.0044399,0.000134542,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05,8.07255e-05}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{1997-11-25 19:05:00.83798,1998-12-29 16:19:18.50226,1998-01-28 23:01:18.41289,2000-12-21 18:03:30.34549,2003-08-28 11:14:33.26306,2003-08-28 11:14:33.2622,1999-03-20 13:04:33.24015,2003-08-28 11:14:33.22312,2003-08-28 11:14:33.21933,2003-08-28 11:14:33.22082,2003-08-28 11:14:33.21425,2003-08-28 11:14:33.22336,2003-08-28 11:14:33.2092,2003-08-28 11:14:33.20251,2003-08-28 11:14:33.22145,2003-08-28 11:14:33.26235,2003-08-28 11:14:33.26525,2003-08-28 11:14:33.23714,2003-08-28 11:14:33.26667,2003-08-28 11:14:33.23978,2003-08-28 11:14:33.21527,2003-08-28 11:14:33.2227,1999-04-16 09:01:42.92689,2003-08-28 11:14:33.21846,2003-08-28 11:14:33.24725}'::timestamp[],
  '{1997-11-25 19:05:00.83798,1998-01-05 11:57:12.19545,1998-10-14 09:06:01.87217,1998-12-29 16:19:18.50226,1999-01-18 15:01:52.77062,1999-12-28 07:57:37.93632,2001-05-16 10:55:44.78317,2003-05-23 10:32:40.1846,2003-08-28 11:14:33.23985,2004-02-04 14:01:57.60942,2005-07-26 17:01:10.98951,2005-07-26 18:41:33.09864,2006-04-25 16:52:03.49003,2008-02-18 14:17:08.58924,2010-04-19 10:16:19.03194,2012-07-23 10:47:40.65789,2014-12-05 10:59:02.25493}'::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[]
),
(
  'orca.tmp_verd_s_pp_provtabs_agt_0015_extract1'::regclass,
  15::smallint,
  'f',
  0.678255::real,
  8::integer,
  7167.15::real,
  1::smallint,
  2::smallint,
  0::smallint,
  0::smallint,
  0::smallint,
  2060::oid,
  2062::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  0::oid,
  '{0.000376719,0.00034981,0.00034981,0.00034981,0.00034981,0.00034981,0.00034981,0.000322902,0.000322902,0.000322902,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000295993,0.000269085,0.000269085}'::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  NULL::real[],
  '{2012-09-07 14:14:23.95552,2012-09-07 14:14:36.8171,2008-12-02 09:02:19.06415,2012-03-16 15:57:15.10939,1999-06-08 13:59:56.59862,1998-10-29 14:57:47.93588,1997-07-10 09:55:34.68999,2003-03-26 11:18:44.43314,2002-02-27 15:07:42.12004,2002-02-27 15:07:13.65666,2003-03-26 11:22:07.7484,2013-11-29 13:16:25.79261,2007-09-06 09:14:10.7907,1998-10-29 14:54:04.23854,2003-04-11 07:54:56.90542,2006-03-09 15:42:27.40086,2000-05-31 10:27:52.92485,2006-01-23 17:12:44.80256,2003-01-28 10:44:17.44046,2007-11-01 15:11:21.99194,2006-03-09 15:42:56.14013,2004-03-31 10:58:47.12524,1999-06-08 14:02:11.91465,1997-07-11 14:52:47.95918,1999-06-08 13:58:15.07927}'::timestamp[],
  '{1997-07-09 10:42:54.69421,1997-09-16 10:30:42.71499,1999-06-08 14:32:08.31914,2002-02-27 15:07:13.67355,2003-04-08 16:31:58.80724,2004-05-05 10:18:01.33179,2006-03-13 16:19:59.61215,2007-09-06 09:13:41.71774,2013-11-29 13:16:37.17591,2014-12-03 09:24:25.20945}'::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[],
  NULL::timestamp[]
);
ERROR:  INSERT has more expressions than target columns
LINE 29:   '{8X8#1F8V92A2025G,YFAXQ§UBF210PA0P,2IIVIE8V92A2025G,9§BP8...
           ^
set polar_px_optimizer_segments = 256;
select a.*,  b.guelt_ab as guelt_ab_b, b.guelt_bis as guelt_bis_b
from orca.tmp_verd_s_pp_provtabs_agt_0015_extract1 a
left outer join  orca.tmp_verd_s_pp_provtabs_agt_0015_extract1 b
 ON  a.uid136=b.uid136 and a.tab_nr=b.tab_nr and  a.prdgrp=b.prdgrp and a.bg=b.bg and a.typ142=b.typ142 and a.ad_gsch=b.ad_gsch
AND a.guelt_ab <= b.guelt_ab AND a.guelt_bis > b.guelt_ab
;
 uid136 | tab_nr | prdgrp | bg | typ142 | ad_gsch | guelt_ab | guelt_bis | guelt_stat | verarb_ab | u_erzeugen | grenze | erstellt_am_122 | erstellt_am_135 | erstellt_am_134 | guelt_ab_b | guelt_bis_b 
--------+--------+--------+----+--------+---------+----------+-----------+------------+-----------+------------+--------+-----------------+-----------------+-----------------+------------+-------------
(0 rows)

                                                                                                                                                                                                                                                                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tmp_verd_s_pp_provtabs_agt_0015_extract1.uid136, tmp_verd_s_pp_provtabs_agt_0015_extract1.tab_nr, tmp_verd_s_pp_provtabs_agt_0015_extract1.prdgrp, tmp_verd_s_pp_provtabs_agt_0015_extract1.bg, tmp_verd_s_pp_provtabs_agt_0015_extract1.typ142, tmp_verd_s_pp_provtabs_agt_0015_extract1.ad_gsch, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_bis, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_stat, tmp_verd_s_pp_provtabs_agt_0015_extract1.verarb_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1.u_erzeugen, tmp_verd_s_pp_provtabs_agt_0015_extract1.grenze, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_122, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_135, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_134, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_bis
   ->  Hash Left Join
         Output: tmp_verd_s_pp_provtabs_agt_0015_extract1.uid136, tmp_verd_s_pp_provtabs_agt_0015_extract1.tab_nr, tmp_verd_s_pp_provtabs_agt_0015_extract1.prdgrp, tmp_verd_s_pp_provtabs_agt_0015_extract1.bg, tmp_verd_s_pp_provtabs_agt_0015_extract1.typ142, tmp_verd_s_pp_provtabs_agt_0015_extract1.ad_gsch, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_bis, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_stat, tmp_verd_s_pp_provtabs_agt_0015_extract1.verarb_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1.u_erzeugen, tmp_verd_s_pp_provtabs_agt_0015_extract1.grenze, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_122, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_135, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_134, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_bis
         Hash Cond: ((tmp_verd_s_pp_provtabs_agt_0015_extract1.uid136 = tmp_verd_s_pp_provtabs_agt_0015_extract1_1.uid136) AND (tmp_verd_s_pp_provtabs_agt_0015_extract1.tab_nr = tmp_verd_s_pp_provtabs_agt_0015_extract1_1.tab_nr) AND (tmp_verd_s_pp_provtabs_agt_0015_extract1.prdgrp = tmp_verd_s_pp_provtabs_agt_0015_extract1_1.prdgrp) AND (tmp_verd_s_pp_provtabs_agt_0015_extract1.bg = tmp_verd_s_pp_provtabs_agt_0015_extract1_1.bg) AND (tmp_verd_s_pp_provtabs_agt_0015_extract1.typ142 = tmp_verd_s_pp_provtabs_agt_0015_extract1_1.typ142) AND (tmp_verd_s_pp_provtabs_agt_0015_extract1.ad_gsch = tmp_verd_s_pp_provtabs_agt_0015_extract1_1.ad_gsch))
         Join Filter: ((tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_ab <= tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab) AND (tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_bis > tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab))
         ->  Partial Seq Scan on orca.tmp_verd_s_pp_provtabs_agt_0015_extract1
               Output: tmp_verd_s_pp_provtabs_agt_0015_extract1.uid136, tmp_verd_s_pp_provtabs_agt_0015_extract1.tab_nr, tmp_verd_s_pp_provtabs_agt_0015_extract1.prdgrp, tmp_verd_s_pp_provtabs_agt_0015_extract1.bg, tmp_verd_s_pp_provtabs_agt_0015_extract1.typ142, tmp_verd_s_pp_provtabs_agt_0015_extract1.ad_gsch, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_bis, tmp_verd_s_pp_provtabs_agt_0015_extract1.guelt_stat, tmp_verd_s_pp_provtabs_agt_0015_extract1.verarb_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1.u_erzeugen, tmp_verd_s_pp_provtabs_agt_0015_extract1.grenze, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_122, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_135, tmp_verd_s_pp_provtabs_agt_0015_extract1.erstellt_am_134
         ->  Hash
               Output: tmp_verd_s_pp_provtabs_agt_0015_extract1_1.uid136, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.tab_nr, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.prdgrp, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.bg, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.typ142, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.ad_gsch, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_bis
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: tmp_verd_s_pp_provtabs_agt_0015_extract1_1.uid136, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.tab_nr, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.prdgrp, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.bg, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.typ142, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.ad_gsch, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_bis
                     ->  Partial Seq Scan on orca.tmp_verd_s_pp_provtabs_agt_0015_extract1 tmp_verd_s_pp_provtabs_agt_0015_extract1_1
                           Output: tmp_verd_s_pp_provtabs_agt_0015_extract1_1.uid136, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.tab_nr, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.prdgrp, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.bg, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.typ142, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.ad_gsch, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_ab, tmp_verd_s_pp_provtabs_agt_0015_extract1_1.guelt_bis
 Optimizer: PolarDB PX Optimizer
(15 rows)

set polar_px_optimizer_segments = 3;
set allow_system_table_mods=false;
-- Arrayref
drop table if exists orca.arrtest;
NOTICE:  table "arrtest" does not exist, skipping
create table orca.arrtest (
 a int2[],
 b int4[][][],
 c name[],
 d text[][]
 );
insert into orca.arrtest (a[1:5], b[1:1][1:2][1:2], c, d)
values ('{1,2,3,4,5}', '{{{0,0},{1,2}}}', '{}', '{}');
select a[1:3], b[1][2][1], c[1], d[1][1] FROM orca.arrtest order by 1,2,3,4;
    a    | b | c | d 
---------+---+---+---
 {1,2,3} | 1 |   | 
(1 row)

                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (a[1:3]), (b[1][2][1]), (c[1]), (d[1][1])
   Merge Key: (a[1:3]), (b[1][2][1]), (c[1]), (d[1][1])
   ->  Sort
         Output: (a[1:3]), (b[1][2][1]), (c[1]), (d[1][1])
         Sort Key: (arrtest.a[1:3]), (arrtest.b[1][2][1]), (arrtest.c[1]), (arrtest.d[1][1])
         ->  Partial Seq Scan on orca.arrtest
               Output: a[1:3], b[1][2][1], c[1], d[1][1]
 Optimizer: PolarDB PX Optimizer
(9 rows)

select a[b[1][2][2]] from orca.arrtest;
 a 
---
 2
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (a[b[1][2][2]])
   ->  Partial Seq Scan on orca.arrtest
         Output: a[b[1][2][2]]
 Optimizer: PolarDB PX Optimizer
(5 rows)

-- MPP-20713, MPP-20714, MPP-20738: Const table get with a filter
select 1 as x where 1 in (2, 3);
 x 
---
(0 rows)

-- MPP-22918: join inner child with universal distribution
SELECT generate_series(1,10) EXCEPT SELECT 1;
 generate_series 
-----------------
              10
               2
               3
               5
               8
               4
               6
               9
               7
(9 rows)

-- MPP-23932: SetOp of const table and volatile function
SELECT generate_series(1,10) INTERSECT SELECT 1;
 generate_series 
-----------------
               1
(1 row)

SELECT generate_series(1,10) UNION SELECT 1;
 generate_series 
-----------------
              10
               2
               3
               5
               8
               4
               6
               9
               7
               1
(10 rows)

-- warning messages for missing stats
create table foo_missing_stats(a int, b int);
insert into foo_missing_stats select i, i%5 from generate_series(1,20) i;
create table bar_missing_stats(c int, d int);
insert into bar_missing_stats select i, i%8 from generate_series(1,30) i;
analyze foo_missing_stats;
analyze bar_missing_stats;
select count(*) from foo_missing_stats where a = 10;
 count 
-------
     1
(1 row)

                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.foo_missing_stats
               Filter: (foo_missing_stats.a = 10)
 Optimizer: PolarDB PX Optimizer
(6 rows)

with x as (select * from foo_missing_stats) select count(*) from x x1, x x2 where x1.a = x2.a;
 count 
-------
    20
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count())
   ->  Sequence
         Output: (count())
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b
               ->  Partial Seq Scan on orca.foo_missing_stats
                     Output: foo_missing_stats.a, foo_missing_stats.b
         ->  PX Hash 1:6  (slice2)
               Output: (count())
               ->  Finalize Aggregate
                     Output: count()
                     ->  PX Coordinator 6:1  (slice3; segments: 6)
                           Output: (PARTIAL count())
                           ->  Partial Aggregate
                                 Output: PARTIAL count()
                                 ->  Hash Join
                                       Hash Cond: (share0_ref3.a = share0_ref2.a)
                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                             Output: share0_ref3.a
                                             Hash Key: share0_ref3.a
                                             ->  Result
                                                   Output: share0_ref3.a
                                                   ->  Shared Scan (Consumer; slice4; share0)
                                                         Output: share0_ref3.a, share0_ref3.b
                                       ->  Hash
                                             Output: share0_ref2.a
                                             ->  PX Hash 6:6  (slice5; segments: 6)
                                                   Output: share0_ref2.a
                                                   Hash Key: share0_ref2.a
                                                   ->  Result
                                                         Output: share0_ref2.a
                                                         ->  Shared Scan (Consumer; slice5; share0)
                                                               Output: share0_ref2.a, share0_ref2.b
 Optimizer: PolarDB PX Optimizer
(35 rows)

with x as (select * from foo_missing_stats) select count(*) from x x1, x x2 where x1.a = x2.b;
 count 
-------
    16
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count())
   ->  Sequence
         Output: (count())
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b
               ->  Partial Seq Scan on orca.foo_missing_stats
                     Output: foo_missing_stats.a, foo_missing_stats.b
         ->  PX Hash 1:6  (slice2)
               Output: (count())
               ->  Finalize Aggregate
                     Output: count()
                     ->  PX Coordinator 6:1  (slice3; segments: 6)
                           Output: (PARTIAL count())
                           ->  Partial Aggregate
                                 Output: PARTIAL count()
                                 ->  Hash Join
                                       Hash Cond: (share0_ref3.a = share0_ref2.b)
                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                             Output: share0_ref3.a
                                             Hash Key: share0_ref3.a
                                             ->  Result
                                                   Output: share0_ref3.a
                                                   ->  Shared Scan (Consumer; slice4; share0)
                                                         Output: share0_ref3.a, share0_ref3.b
                                       ->  Hash
                                             Output: share0_ref2.b
                                             ->  PX Hash 6:6  (slice5; segments: 6)
                                                   Output: share0_ref2.b
                                                   Hash Key: share0_ref2.b
                                                   ->  Result
                                                         Output: share0_ref2.b
                                                         ->  Shared Scan (Consumer; slice5; share0)
                                                               Output: share0_ref2.a, share0_ref2.b
 Optimizer: PolarDB PX Optimizer
(35 rows)

set allow_system_table_mods=true;
delete from pg_statistic where starelid='foo_missing_stats'::regclass;
delete from pg_statistic where starelid='bar_missing_stats'::regclass;
set allow_system_table_mods=false;
select count(*) from foo_missing_stats where a = 10;
 count 
-------
     1
(1 row)

                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.foo_missing_stats
               Filter: (foo_missing_stats.a = 10)
 Optimizer: PolarDB PX Optimizer
(6 rows)

with x as (select * from foo_missing_stats) select count(*) from x x1, x x2 where x1.a = x2.a;
 count 
-------
    20
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count())
   ->  Sequence
         Output: (count())
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b
               ->  Partial Seq Scan on orca.foo_missing_stats
                     Output: foo_missing_stats.a, foo_missing_stats.b
         ->  PX Hash 1:6  (slice2)
               Output: (count())
               ->  Finalize Aggregate
                     Output: count()
                     ->  PX Coordinator 6:1  (slice3; segments: 6)
                           Output: (PARTIAL count())
                           ->  Partial Aggregate
                                 Output: PARTIAL count()
                                 ->  Hash Join
                                       Hash Cond: (share0_ref3.a = share0_ref2.a)
                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                             Output: share0_ref3.a
                                             Hash Key: share0_ref3.a
                                             ->  Result
                                                   Output: share0_ref3.a
                                                   ->  Shared Scan (Consumer; slice4; share0)
                                                         Output: share0_ref3.a, share0_ref3.b
                                       ->  Hash
                                             Output: share0_ref2.a
                                             ->  PX Hash 6:6  (slice5; segments: 6)
                                                   Output: share0_ref2.a
                                                   Hash Key: share0_ref2.a
                                                   ->  Result
                                                         Output: share0_ref2.a
                                                         ->  Shared Scan (Consumer; slice5; share0)
                                                               Output: share0_ref2.a, share0_ref2.b
 Optimizer: PolarDB PX Optimizer
(35 rows)

with x as (select * from foo_missing_stats) select count(*) from x x1, x x2 where x1.a = x2.b;
 count 
-------
    16
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count())
   ->  Sequence
         Output: (count())
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.b
               ->  Partial Seq Scan on orca.foo_missing_stats
                     Output: foo_missing_stats.a, foo_missing_stats.b
         ->  PX Hash 1:6  (slice2)
               Output: (count())
               ->  Finalize Aggregate
                     Output: count()
                     ->  PX Coordinator 6:1  (slice3; segments: 6)
                           Output: (PARTIAL count())
                           ->  Partial Aggregate
                                 Output: PARTIAL count()
                                 ->  Hash Join
                                       Hash Cond: (share0_ref3.a = share0_ref2.b)
                                       ->  PX Hash 6:6  (slice4; segments: 6)
                                             Output: share0_ref3.a
                                             Hash Key: share0_ref3.a
                                             ->  Result
                                                   Output: share0_ref3.a
                                                   ->  Shared Scan (Consumer; slice4; share0)
                                                         Output: share0_ref3.a, share0_ref3.b
                                       ->  Hash
                                             Output: share0_ref2.b
                                             ->  PX Hash 6:6  (slice5; segments: 6)
                                                   Output: share0_ref2.b
                                                   Hash Key: share0_ref2.b
                                                   ->  Result
                                                         Output: share0_ref2.b
                                                         ->  Shared Scan (Consumer; slice5; share0)
                                                               Output: share0_ref2.a, share0_ref2.b
 Optimizer: PolarDB PX Optimizer
(35 rows)

set polar_px_optimizer_print_missing_stats = off;
DROP TABLE IF EXISTS orca.table_with_small_statistic_precision_diff;
NOTICE:  table "table_with_small_statistic_precision_diff" does not exist, skipping
CREATE TABLE orca.table_with_small_statistic_precision_diff (
    col1 double precision
);
SET allow_system_table_mods=true;
DELETE FROM pg_statistic WHERE starelid='table_with_small_statistic_precision_diff'::regclass;
INSERT INTO pg_statistic VALUES (
'table_with_small_statistic_precision_diff'::regclass,
1::smallint,
True::boolean,
0::real,
8::integer,
0::real,
1::smallint,
2::smallint,
0::smallint,
0::smallint,
0::smallint,
670::oid,
672::oid,
0::oid,
0::oid,
0::oid,
0::oid,
0::oid,
0::oid,
0::oid,
0::oid,
E'{0.002}'::real[],
NULL::real[],
NULL::real[],
NULL::real[],
NULL::real[],
E'{-0.25475}'::float8[],
E'{-0.3,-0.2547399}'::float8[],
NULL::float8[],
NULL::float8[],
NULL::float8[]);
ERROR:  INSERT has more expressions than target columns
LINE 28: E'{-0.25475}'::float8[],
         ^
SET allow_system_table_mods=false;
SELECT *
FROM (
    SELECT
        *
    FROM orca.table_with_small_statistic_precision_diff
    UNION ALL
    SELECT
        *
    FROM orca.table_with_small_statistic_precision_diff
) x;
 col1 
------
(0 rows)

                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: table_with_small_statistic_precision_diff.col1
   ->  Append
         ->  Partial Seq Scan on orca.table_with_small_statistic_precision_diff
               Output: table_with_small_statistic_precision_diff.col1
         ->  Partial Seq Scan on orca.table_with_small_statistic_precision_diff table_with_small_statistic_precision_diff_1
               Output: table_with_small_statistic_precision_diff_1.col1
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Push components of disjunctive predicates
create table cust(cid integer, firstname text, lastname text) ;
create table datedim(date_sk integer, year integer, moy integer) ;
create table sales(item_sk integer, ticket_number integer, cid integer, date_sk integer, type text)
  ;
-- create a volatile function which should not be pushed
CREATE FUNCTION plusone(integer) RETURNS integer AS $$
BEGIN
    SELECT $1 + 1;
END;
$$ LANGUAGE plpgsql volatile;
-- force_explain
SET polar_px_optimizer_segments = 3;
explain (costs off) select c.cid cid,
       c.firstname firstname,
       c.lastname lastname,
       d.year dyear
from cust c, sales s, datedim d
where c.cid = s.cid and s.date_sk = d.date_sk and
      ((d.year = 2001 and lower(s.type) = 't1' and plusone(d.moy) = 5) or (d.moy = 4 and upper(s.type) = 'T2'));
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (c.cid = s.cid)
   ->  Seq Scan on cust c
   ->  Hash
         ->  Hash Join
               Hash Cond: (d.date_sk = s.date_sk)
               Join Filter: (((d.year = 2001) AND (lower(s.type) = 't1'::text) AND (plusone(d.moy) = 5)) OR ((d.moy = 4) AND (upper(s.type) = 'T2'::text)))
               ->  Seq Scan on datedim d
                     Filter: ((year = 2001) OR (moy = 4))
               ->  Hash
                     ->  Seq Scan on sales s
                           Filter: ((lower(type) = 't1'::text) OR (upper(type) = 'T2'::text))
(12 rows)

reset polar_px_optimizer_segments;
-- Bitmap indexes
drop table if exists orca.bm_test;
NOTICE:  table "bm_test" does not exist, skipping
create table orca.bm_test (i int, t text);
insert into orca.bm_test select i % 10, (i % 10)::text  from generate_series(1, 100) i;
analyze orca.bm_test;
create index bm_test_idx on orca.bm_test using bitmap (i);
ERROR:  access method "bitmap" does not exist
set polar_px_optimizer_enable_bitmapscan=on;
explain (costs off) select * from orca.bm_test where i=2 and t='2';
               QUERY PLAN                
-----------------------------------------
 Seq Scan on bm_test
   Filter: ((i = 2) AND (t = '2'::text))
(2 rows)

select * from orca.bm_test where i=2 and t='2';
 i | t 
---+---
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
 2 | 2
(10 rows)

                          QUERY PLAN                           
---------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: i, t
   ->  Partial Seq Scan on orca.bm_test
         Output: i, t
         Filter: ((bm_test.i = 2) AND (bm_test.t = '2'::text))
 Optimizer: PolarDB PX Optimizer
(6 rows)

reset polar_px_optimizer_enable_bitmapscan;
-- Dynamic bitmap indexes
drop table if exists orca.bm_dyn_test;
NOTICE:  table "bm_dyn_test" does not exist, skipping
create table orca.bm_dyn_test (i int, to_be_dropped char(5), j int, t text)  partition by list(j);
CREATE TABLE part0 PARTITION OF orca.bm_dyn_test FOR VALUES IN (0);
CREATE TABLE part1 PARTITION OF orca.bm_dyn_test FOR VALUES IN (1);
CREATE TABLE part2 PARTITION OF orca.bm_dyn_test FOR VALUES IN (2);
CREATE TABLE part3 PARTITION OF orca.bm_dyn_test FOR VALUES IN (3);
CREATE TABLE part4 PARTITION OF orca.bm_dyn_test FOR VALUES IN (4);
insert into orca.bm_dyn_test select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
create index bm_dyn_test_idx on orca.bm_dyn_test using bitmap (i);
ERROR:  access method "bitmap" does not exist
alter table orca.bm_dyn_test drop column to_be_dropped;
alter table orca.bm_dyn_test add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table orca.bm_dyn_test add partition part5 values(5);
                                                         ^
insert into orca.bm_dyn_test values(2, 5, '2');
ERROR:  no partition of relation "bm_dyn_test" found for row
DETAIL:  Partition key of the failing row contains (j) = (5).
set polar_px_optimizer_enable_bitmapscan=on;
-- start_ignore
analyze orca.bm_dyn_test;
-- end_ignore
-- gather on 1 segment because of direct dispatch
explain (costs off) select * from orca.bm_dyn_test where i=2 and t='2';
                  QUERY PLAN                   
-----------------------------------------------
 Append
   ->  Seq Scan on part0
         Filter: ((i = 2) AND (t = '2'::text))
   ->  Seq Scan on part1
         Filter: ((i = 2) AND (t = '2'::text))
   ->  Seq Scan on part2
         Filter: ((i = 2) AND (t = '2'::text))
   ->  Seq Scan on part3
         Filter: ((i = 2) AND (t = '2'::text))
   ->  Seq Scan on part4
         Filter: ((i = 2) AND (t = '2'::text))
(11 rows)

select * from orca.bm_dyn_test where i=2 and t='2';
 i | j | t 
---+---+---
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
(10 rows)

                           QUERY PLAN                            
-----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part0.i, part0.j, part0.t
   ->  Append
         ->  Partial Seq Scan on orca.part0
               Output: part0.i, part0.j, part0.t
               Filter: ((part0.i = 2) AND (part0.t = '2'::text))
         ->  Partial Seq Scan on orca.part1
               Output: part1.i, part1.j, part1.t
               Filter: ((part1.i = 2) AND (part1.t = '2'::text))
         ->  Partial Seq Scan on orca.part2
               Output: part2.i, part2.j, part2.t
               Filter: ((part2.i = 2) AND (part2.t = '2'::text))
         ->  Partial Seq Scan on orca.part3
               Output: part3.i, part3.j, part3.t
               Filter: ((part3.i = 2) AND (part3.t = '2'::text))
         ->  Partial Seq Scan on orca.part4
               Output: part4.i, part4.j, part4.t
               Filter: ((part4.i = 2) AND (part4.t = '2'::text))
 Optimizer: PolarDB PX Optimizer
(19 rows)

reset polar_px_optimizer_enable_bitmapscan;
-- Now, create a partial index
drop table if exists orca.bm_dyn_test_onepart;
NOTICE:  table "bm_dyn_test_onepart" does not exist, skipping
create table orca.bm_dyn_test_onepart (i int, to_be_dropped char(5), j int, t text)
   partition by list(j);
CREATE TABLE part0 PARTITION OF orca.bm_dyn_test_onepart FOR VALUES IN (0);
ERROR:  relation "part0" already exists
CREATE TABLE part1 PARTITION OF orca.bm_dyn_test_onepart FOR VALUES IN (1);
ERROR:  relation "part1" already exists
CREATE TABLE part2 PARTITION OF orca.bm_dyn_test_onepart FOR VALUES IN (2);
ERROR:  relation "part2" already exists
CREATE TABLE part3 PARTITION OF orca.bm_dyn_test_onepart FOR VALUES IN (3);
ERROR:  relation "part3" already exists
CREATE TABLE part4 PARTITION OF orca.bm_dyn_test_onepart FOR VALUES IN (4);
ERROR:  relation "part4" already exists
insert into orca.bm_dyn_test_onepart select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  no partition of relation "bm_dyn_test_onepart" found for row
DETAIL:  Partition key of the failing row contains (j) = (1).
create index bm_test_idx_part on orca.bm_dyn_test_onepart_1_prt_part2 using bitmap (i);
ERROR:  relation "orca.bm_dyn_test_onepart_1_prt_part2" does not exist
alter table orca.bm_dyn_test_onepart drop column to_be_dropped;
alter table orca.bm_dyn_test_onepart add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: ...able orca.bm_dyn_test_onepart add partition part5 values(5);
                                                             ^
insert into orca.bm_dyn_test_onepart values(2, 5, '2');
ERROR:  no partition of relation "bm_dyn_test_onepart" found for row
DETAIL:  Partition key of the failing row contains (j) = (5).
set polar_px_optimizer_enable_bitmapscan=on;
set polar_px_optimizer_enable_dynamictablescan = off;
-- start_ignore
analyze orca.bm_dyn_test_onepart;
-- end_ignore
-- gather on 1 segment because of direct dispatch
explain (costs off) select * from orca.bm_dyn_test_onepart where i=2 and t='2';
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

select * from orca.bm_dyn_test_onepart where i=2 and t='2';
 i | j | t 
---+---+---
(0 rows)

reset polar_px_optimizer_enable_dynamictablescan;
reset polar_px_optimizer_enable_bitmapscan;
-- More BitmapTableScan & BitmapIndexScan tests
set polar_px_optimizer_enable_bitmapscan=on;
create schema bm;
-- Bitmap index scan on Heterogeneous parts with dropped columns
drop table if exists bm.het_bm;
NOTICE:  table "het_bm" does not exist, skipping
create table bm.het_bm (i int, to_be_dropped char(5), j int, t text)  partition by list(j);
CREATE TABLE part0 PARTITION OF bm.het_bm FOR VALUES IN (0);
ERROR:  relation "part0" already exists
CREATE TABLE part1 PARTITION OF bm.het_bm FOR VALUES IN (1);
ERROR:  relation "part1" already exists
CREATE TABLE part2 PARTITION OF bm.het_bm FOR VALUES IN (2);
ERROR:  relation "part2" already exists
CREATE TABLE part3 PARTITION OF bm.het_bm FOR VALUES IN (3);
ERROR:  relation "part3" already exists
CREATE TABLE part4 PARTITION OF bm.het_bm FOR VALUES IN (4);
ERROR:  relation "part4" already exists
insert into bm.het_bm select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  no partition of relation "het_bm" found for row
DETAIL:  Partition key of the failing row contains (j) = (1).
create index het_bm_idx on bm.het_bm using bitmap (i);
ERROR:  access method "bitmap" does not exist
alter table bm.het_bm drop column to_be_dropped;
alter table bm.het_bm add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table bm.het_bm add partition part5 values(5);
                                                  ^
insert into bm.het_bm values(2, 5, '2');
ERROR:  no partition of relation "het_bm" found for row
DETAIL:  Partition key of the failing row contains (j) = (5).
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.het_bm where i=2 and t='2';
 i_sum | j_sum | t_sum 
-------+-------+-------
       |       |      
(1 row)

-- Bitmap index scan on heap parts with dropped columns
drop table if exists bm.hom_bm_heap;
NOTICE:  table "hom_bm_heap" does not exist, skipping
create table bm.hom_bm_heap (i int, to_be_dropped char(5), j int, t text)  partition by list(j);
CREATE TABLE part0 PARTITION OF bm.hom_bm_heap FOR VALUES IN (0);
ERROR:  relation "part0" already exists
CREATE TABLE part1 PARTITION OF bm.hom_bm_heap FOR VALUES IN (1);
ERROR:  relation "part1" already exists
CREATE TABLE part2 PARTITION OF bm.hom_bm_heap FOR VALUES IN (2);
ERROR:  relation "part2" already exists
CREATE TABLE part3 PARTITION OF bm.hom_bm_heap FOR VALUES IN (3);
ERROR:  relation "part3" already exists
CREATE TABLE part4 PARTITION OF bm.hom_bm_heap FOR VALUES IN (4);
ERROR:  relation "part4" already exists
insert into bm.hom_bm_heap select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  no partition of relation "hom_bm_heap" found for row
DETAIL:  Partition key of the failing row contains (j) = (1).
create index hom_bm_heap_idx on bm.hom_bm_heap using bitmap (i);
ERROR:  access method "bitmap" does not exist
alter table bm.hom_bm_heap drop column to_be_dropped;
alter table bm.hom_bm_heap add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table bm.hom_bm_heap add partition part5 values(5);
                                                       ^
insert into bm.hom_bm_heap values(2, 5, '2');
ERROR:  no partition of relation "hom_bm_heap" found for row
DETAIL:  Partition key of the failing row contains (j) = (5).
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.hom_bm_heap where i=2 and t='2';
 i_sum | j_sum | t_sum 
-------+-------+-------
       |       |      
(1 row)

-- Bitmap index scan on AO parts with dropped columns
drop table if exists bm.hom_bm_ao;
NOTICE:  table "hom_bm_ao" does not exist, skipping
create table bm.hom_bm_ao (i int, to_be_dropped char(5), j int, t text)
with ( compresslevel=5, orientation=row)
 partition by list(j);
ERROR:  syntax error at or near "row"
LINE 2: with ( compresslevel=5, orientation=row)
                                            ^
 CREATE TABLE part0 PARTITION OF bm.hom_bm_ao FOR VALUES IN (0);
ERROR:  relation "bm.hom_bm_ao" does not exist
CREATE TABLE part1 PARTITION OF bm.hom_bm_ao FOR VALUES IN (1);
ERROR:  relation "bm.hom_bm_ao" does not exist
CREATE TABLE part2 PARTITION OF bm.hom_bm_ao FOR VALUES IN (2);
ERROR:  relation "bm.hom_bm_ao" does not exist
CREATE TABLE part3 PARTITION OF bm.hom_bm_ao FOR VALUES IN (3);
ERROR:  relation "bm.hom_bm_ao" does not exist
CREATE TABLE part4 PARTITION OF bm.hom_bm_ao FOR VALUES IN (4);
ERROR:  relation "bm.hom_bm_ao" does not exist
insert into bm.hom_bm_ao select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  relation "bm.hom_bm_ao" does not exist
LINE 1: insert into bm.hom_bm_ao select i % 10, 'drop', i % 5, (i % ...
                    ^
create index hom_bm_ao_idx on bm.hom_bm_ao using bitmap (i);
ERROR:  relation "bm.hom_bm_ao" does not exist
alter table bm.hom_bm_ao drop column to_be_dropped;
ERROR:  relation "bm.hom_bm_ao" does not exist
alter table bm.hom_bm_ao add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table bm.hom_bm_ao add partition part5 values(5);
                                                     ^
insert into bm.hom_bm_ao values(2, 5, '2');
ERROR:  relation "bm.hom_bm_ao" does not exist
LINE 1: insert into bm.hom_bm_ao values(2, 5, '2');
                    ^
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.hom_bm_ao where i=2 and t='2';
ERROR:  relation "bm.hom_bm_ao" does not exist
LINE 1: ...) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.hom_bm_...
                                                             ^
-- Bitmap index scan on AOCO parts with dropped columns
drop table if exists bm.hom_bm_aoco;
NOTICE:  table "hom_bm_aoco" does not exist, skipping
create table bm.hom_bm_aoco (i int, to_be_dropped char(5), j int, t text)
with ( compresslevel=5, orientation=column)
 partition by list(j);
ERROR:  syntax error at or near "partition"
LINE 3:  partition by list(j);
         ^
CREATE TABLE part0 PARTITION OF bm.hom_bm_aoco FOR VALUES IN (0);
ERROR:  relation "bm.hom_bm_aoco" does not exist
CREATE TABLE part1 PARTITION OF bm.hom_bm_aoco FOR VALUES IN (1);
ERROR:  relation "bm.hom_bm_aoco" does not exist
CREATE TABLE part2 PARTITION OF bm.hom_bm_aoco FOR VALUES IN (2);
ERROR:  relation "bm.hom_bm_aoco" does not exist
CREATE TABLE part3 PARTITION OF bm.hom_bm_aoco FOR VALUES IN (3);
ERROR:  relation "bm.hom_bm_aoco" does not exist
CREATE TABLE part4 PARTITION OF bm.hom_bm_aoco FOR VALUES IN (4);
ERROR:  relation "bm.hom_bm_aoco" does not exist
insert into bm.hom_bm_aoco select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  relation "bm.hom_bm_aoco" does not exist
LINE 1: insert into bm.hom_bm_aoco select i % 10, 'drop', i % 5, (i ...
                    ^
create index hom_bm_aoco_idx on bm.hom_bm_aoco using bitmap (i);
ERROR:  relation "bm.hom_bm_aoco" does not exist
alter table bm.hom_bm_aoco drop column to_be_dropped;
ERROR:  relation "bm.hom_bm_aoco" does not exist
alter table bm.hom_bm_aoco add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table bm.hom_bm_aoco add partition part5 values(5);
                                                       ^
insert into bm.hom_bm_aoco values(2, 5, '2');
ERROR:  relation "bm.hom_bm_aoco" does not exist
LINE 1: insert into bm.hom_bm_aoco values(2, 5, '2');
                    ^
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.hom_bm_aoco where i=2 and t='2';
ERROR:  relation "bm.hom_bm_aoco" does not exist
LINE 1: ...) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.hom_bm_...
                                                             ^
-- Create index before dropped column
drop table if exists bm.het_bm;
create table bm.het_bm (i int, to_be_dropped char(5), j int, t text)  partition by list(j);
CREATE TABLE part0 PARTITION OF bm.het_bm FOR VALUES IN (0);
ERROR:  relation "part0" already exists
CREATE TABLE part1 PARTITION OF bm.het_bm FOR VALUES IN (1);
ERROR:  relation "part1" already exists
CREATE TABLE part2 PARTITION OF bm.het_bm FOR VALUES IN (2);
ERROR:  relation "part2" already exists
CREATE TABLE part3 PARTITION OF bm.het_bm FOR VALUES IN (3);
ERROR:  relation "part3" already exists
CREATE TABLE part4 PARTITION OF bm.het_bm FOR VALUES IN (4);
ERROR:  relation "part4" already exists
insert into bm.het_bm select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  no partition of relation "het_bm" found for row
DETAIL:  Partition key of the failing row contains (j) = (1).
-- Create index before dropping a column
create index het_bm_i_idx on bm.het_bm using bitmap (i);
ERROR:  access method "bitmap" does not exist
create index het_bm_j_idx on bm.het_bm using bitmap (j);
ERROR:  access method "bitmap" does not exist
alter table bm.het_bm drop column to_be_dropped;
alter table bm.het_bm add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table bm.het_bm add partition part5 values(5);
                                                  ^
insert into bm.het_bm values(2, 5, '2');
ERROR:  no partition of relation "het_bm" found for row
DETAIL:  Partition key of the failing row contains (j) = (5).
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.het_bm where i=2 and j=2;
 i_sum | j_sum | t_sum 
-------+-------+-------
       |       |      
(1 row)

select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.het_bm where i=2 and t='2';
 i_sum | j_sum | t_sum 
-------+-------+-------
       |       |      
(1 row)

-- Drop and recreate index after we dropped column
drop index bm.het_bm_i_idx;
ERROR:  index "het_bm_i_idx" does not exist
drop index bm.het_bm_j_idx;
ERROR:  index "het_bm_j_idx" does not exist
create index het_bm_i_idx on bm.het_bm using bitmap (i);
ERROR:  access method "bitmap" does not exist
create index het_bm_j_idx on bm.het_bm using bitmap (j);
ERROR:  access method "bitmap" does not exist
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.het_bm where j=2 or j=3;
 i_sum | j_sum | t_sum 
-------+-------+-------
       |       |      
(1 row)

-- Create index after dropped column
drop table if exists bm.het_bm;
create table bm.het_bm (i int, to_be_dropped char(5), j int, t text)  partition by list(j);
CREATE TABLE part0 PARTITION OF bm.het_bm FOR VALUES IN (0);
ERROR:  relation "part0" already exists
CREATE TABLE part1 PARTITION OF bm.het_bm FOR VALUES IN (1);
ERROR:  relation "part1" already exists
CREATE TABLE part2 PARTITION OF bm.het_bm FOR VALUES IN (2);
ERROR:  relation "part2" already exists
CREATE TABLE part3 PARTITION OF bm.het_bm FOR VALUES IN (3);
ERROR:  relation "part3" already exists
CREATE TABLE part4 PARTITION OF bm.het_bm FOR VALUES IN (4);
ERROR:  relation "part4" already exists
insert into bm.het_bm select i % 10, 'drop', i % 5, (i % 10)::text  from generate_series(1, 100) i;
ERROR:  no partition of relation "het_bm" found for row
DETAIL:  Partition key of the failing row contains (j) = (1).
alter table bm.het_bm drop column to_be_dropped;
alter table bm.het_bm add partition part5 values(5);
ERROR:  syntax error at or near "values"
LINE 1: alter table bm.het_bm add partition part5 values(5);
                                                  ^
-- Create index after dropping a column but before we insert into newly created part
create index het_bm_i_idx on bm.het_bm using bitmap (i);
ERROR:  access method "bitmap" does not exist
create index het_bm_j_idx on bm.het_bm using bitmap (j);
ERROR:  access method "bitmap" does not exist
insert into bm.het_bm values(2, 5, '2');
ERROR:  no partition of relation "het_bm" found for row
DETAIL:  Partition key of the failing row contains (j) = (5).
select sum(i) i_sum, sum(j) j_sum, sum(t::integer) t_sum from bm.het_bm where j=2 or j=3;
 i_sum | j_sum | t_sum 
-------+-------+-------
       |       |      
(1 row)

-- Rescan bitmap index
drop table if exists bm.outer_tab;
NOTICE:  table "outer_tab" does not exist, skipping
create table bm.outer_tab
(
id serial,
code character varying(25),
name character varying(40)
);
insert into bm.outer_tab select i % 10, i % 5, i % 2 from generate_series(1, 100) i;
set polar_px_optimizer_enable_hashjoin = off;
select count(1) from bm.outer_tab;
 count 
-------
   100
(1 row)

                     QUERY PLAN                     
----------------------------------------------------
 Finalize Aggregate
   Output: count(1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count(1))
         ->  Partial Aggregate
               Output: PARTIAL count(1)
               ->  Partial Seq Scan on bm.outer_tab
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(1) from bm.het_bm;
 count 
-------
     0
(1 row)

select sum(id) id_sum, sum(i) i_sum, sum(j) j_sum from bm.outer_tab as ot join bm.het_bm as het_bm on ot.id = het_bm.j
where het_bm.i between 2 and 5;
 id_sum | i_sum | j_sum 
--------+-------+-------
        |       |      
(1 row)

set client_min_messages='warning';
drop schema bm cascade;
reset polar_px_optimizer_enable_hashjoin;
reset polar_px_optimizer_enable_bitmapscan;
-- End of BitmapTableScan & BitmapIndexScan tests
set polar_px_optimizer_enable_constant_expression_evaluation=on;
CREATE TABLE my_tt_agg_opt (
    symbol character(16),
    event_ts bigint,
    trade_price numeric,
    trade_volume bigint
) ;
CREATE TABLE my_tq_agg_opt_part (
    ets bigint,
    sym character varying(16),
    bid_price numeric,
    ask_price numeric,
    end_ts bigint
) 
CREATE TABLE my_tq_agg_opt_part_p1 PARTITION of my_tq_agg_opt_part for values from (0) to (200000);
ERROR:  syntax error at or near "CREATE"
LINE 8: CREATE TABLE my_tq_agg_opt_part_p1 PARTITION of my_tq_agg_op...
        ^
CREATE TABLE my_tq_agg_opt_part_p2 PARTITION of my_tq_agg_opt_part for values from (200000) to (900000);
ERROR:  relation "my_tq_agg_opt_part" does not exist
CREATE INDEX my_tq_agg_opt_part_ets_end_ts_ix_1 ON my_tq_agg_opt_part_1_prt_p1 USING btree (ets, end_ts);
ERROR:  relation "my_tq_agg_opt_part_1_prt_p1" does not exist
CREATE INDEX my_tq_agg_opt_part_ets_end_ts_ix_2 ON my_tq_agg_opt_part_1_prt_p2 USING btree (ets);
ERROR:  relation "my_tq_agg_opt_part_1_prt_p2" does not exist
CREATE FUNCTION plusone(numeric) RETURNS numeric AS $$
BEGIN
    SELECT $1 + 1;
END;
$$ LANGUAGE plpgsql volatile;
-- start_ignore
select disable_xform('CXformInnerJoin2DynamicIndexGetApply');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformInnerJoin2DynamicIndexGetApply')...
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select disable_xform('CXformInnerJoin2HashJoin');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformInnerJoin2HashJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select disable_xform('CXformInnerJoin2IndexGetApply');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformInnerJoin2IndexGetApply');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select disable_xform('CXformInnerJoin2NLJoin');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformInnerJoin2NLJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
set polar_px_optimizer_enable_partial_index=on;
ERROR:  unrecognized configuration parameter "polar_px_optimizer_enable_partial_index"
set polar_px_optimizer_enable_indexjoin=on;
-- force_explain
SET polar_px_optimizer_segments = 3;
explain (costs off) selectn selecty_tt_agg_opt tt, my_tq_agg_opt_part tq
WHERE tq.sym = tt.symbol AND
      plusone(tq.bid_price) < tt.trade_price AND
      tt.event_ts >= tq.ets AND
      tt.event_ts <  tq.end_ts
GROUP BY 1
ORDER BY 1 asc ;
ERROR:  syntax error at or near "selectn"
LINE 1: explain (costs off) selectn selecty_tt_agg_opt tt, my_tq_agg...
                            ^
reset polar_px_optimizer_segments;
reset polar_px_optimizer_enable_constant_expression_evaluation;
reset polar_px_optimizer_enable_indexjoin;
reset polar_px_optimizer_enable_partial_index;
ERROR:  unrecognized configuration parameter "polar_px_optimizer_enable_partial_index"
-- start_ignore
select enable_xform('CXformInnerJoin2DynamicIndexGetApply');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformInnerJoin2DynamicIndexGetApply');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select enable_xform('CXformInnerJoin2HashJoin');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformInnerJoin2HashJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select enable_xform('CXformInnerJoin2IndexGetApply');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformInnerJoin2IndexGetApply');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select enable_xform('CXformInnerJoin2NLJoin');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformInnerJoin2NLJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
-- MPP-25661: IndexScan crashing for qual with reference to outer tuple
drop table if exists idxscan_outer;
create table idxscan_outer
(
id serial,
code character varying(25),
name character varying(40)
);
drop table if exists idxscan_inner;
create table idxscan_inner
(
ordernum int unique,
productid int,
comment character varying(40)
);
-- Have more rows in one table, so that the planner will
-- choose to make that the outer side of the join.
insert into idxscan_outer values (1, 'a', 'aaa');
insert into idxscan_outer values (2, 'b', 'bbb');
insert into idxscan_outer values (3, 'c', 'ccc');
insert into idxscan_outer values (4, 'd', 'ddd');
insert into idxscan_outer values (5, 'e', 'eee');
insert into idxscan_outer values (6, 'f', 'fff');
insert into idxscan_outer values (7, 'g', 'ggg');
insert into idxscan_outer values (8, 'h', 'hhh');
insert into idxscan_outer values (9, 'i', 'iii');
insert into idxscan_inner values (11, 1, 'xxxx');
insert into idxscan_inner values (24, 2, 'yyyy');
insert into idxscan_inner values (13, 3, 'zzzz');
analyze idxscan_outer;
analyze idxscan_inner;
set polar_px_optimizer_enable_hashjoin = off;
explain (costs off) select id, comment from idxscan_outer as o join idxscan_inner as i on o.id = i.productid
where ordernum between 10 and 20;
                          QUERY PLAN                           
---------------------------------------------------------------
 Hash Join
   Hash Cond: (o.id = i.productid)
   ->  Seq Scan on idxscan_outer o
   ->  Hash
         ->  Seq Scan on idxscan_inner i
               Filter: ((ordernum >= 10) AND (ordernum <= 20))
(6 rows)

select id, comment from idxscan_outer as o join idxscan_inner as i on o.id = i.productid
where ordernum between 10 and 20;
 id | comment 
----+---------
  1 | xxxx
  3 | zzzz
(2 rows)

                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: idxscan_outer.id, idxscan_inner.comment
   ->  Nested Loop
         Output: idxscan_outer.id, idxscan_inner.comment
         Join Filter: (idxscan_outer.id = idxscan_inner.productid)
         ->  Partial Index Scan using idxscan_inner_ordernum_key on orca.idxscan_inner
               Output: idxscan_inner.productid, idxscan_inner.comment
               Index Cond: ((idxscan_inner.ordernum >= 10) AND (idxscan_inner.ordernum <= 20))
         ->  Materialize
               Output: idxscan_outer.id
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: idxscan_outer.id
                     ->  Partial Seq Scan on orca.idxscan_outer
                           Output: idxscan_outer.id
 Optimizer: PolarDB PX Optimizer
(15 rows)

reset polar_px_optimizer_enable_hashjoin;
drop table idxscan_outer;
drop table idxscan_inner;
drop table if exists ggg;
NOTICE:  table "ggg" does not exist, skipping
create table ggg (a char(1), b char(2), d char(3));
insert into ggg values ('x', 'a', 'c');
insert into ggg values ('x', 'a');
insert into ggg values ('x');
-- MPP-25700 Fix to TO_DATE on hybrid datums during constant expression evaluation
drop table if exists orca.t3;
NOTICE:  table "t3" does not exist, skipping
create table orca.t3 (c1 timestamp without time zone);
insert into orca.t3 values  ('2015-07-03 00:00:00'::timestamp without time zone);
select to_char(c1, 'YYYY-MM-DD HH24:MI:SS') from orca.t3 where c1 = TO_DATE('2015-07-03','YYYY-MM-DD');
       to_char       
---------------------
 2015-07-03 00:00:00
(1 row)

                                QUERY PLAN                                 
---------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (to_char(c1, 'YYYY-MM-DD HH24:MI:SS'::text))
   ->  Partial Seq Scan on orca.t3
         Output: to_char(c1, 'YYYY-MM-DD HH24:MI:SS'::text)
         Filter: (t3.c1 = to_date('2015-07-03'::text, 'YYYY-MM-DD'::text))
 Optimizer: PolarDB PX Optimizer
(6 rows)

select to_char(c1, 'YYYY-MM-DD HH24:MI:SS') from orca.t3 where c1 = '2015-07-03'::date;
       to_char       
---------------------
 2015-07-03 00:00:00
(1 row)

                         QUERY PLAN                         
------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (to_char(c1, 'YYYY-MM-DD HH24:MI:SS'::text))
   ->  Partial Seq Scan on orca.t3
         Output: to_char(c1, 'YYYY-MM-DD HH24:MI:SS'::text)
         Filter: (t3.c1 = '07-03-2015'::date)
 Optimizer: PolarDB PX Optimizer
(6 rows)

-- MPP-25806: multi-column index
create table orca.index_test (a int, b int, c int, d int, e int, constraint index_test_pkey PRIMARY KEY (a, b, c, d));
insert into orca.index_test select i,i%2,i%3,i%4,i%5 from generate_series(1,100) i;
analyze orca.index_test;
-- force_explain
explain (costs off) select * from orca.index_test where a = 5;
       QUERY PLAN       
------------------------
 Seq Scan on index_test
   Filter: (a = 5)
(2 rows)

-- force_explain
explain (costs off) select * from orca.index_test where c = 5;
       QUERY PLAN       
------------------------
 Seq Scan on index_test
   Filter: (c = 5)
(2 rows)

-- force_explain
explain (costs off) select * from orca.index_test where a = 5 and c = 5;
           QUERY PLAN            
---------------------------------
 Seq Scan on index_test
   Filter: ((a = 5) AND (c = 5))
(2 rows)

-- renaming columns
select * from (values (2),(null)) v(k);
 k 
---
 2
  
(2 rows)

-- Checking if ORCA correctly populates canSetTag in PlannedStmt for multiple statements because of rules
drop table if exists can_set_tag_target;
NOTICE:  table "can_set_tag_target" does not exist, skipping
create table can_set_tag_target
(
	x int,
	y int,
	z char
);
drop table if exists can_set_tag_audit;
NOTICE:  table "can_set_tag_audit" does not exist, skipping
create table can_set_tag_audit
(
	t timestamp without time zone,
	x int,
	y int,
	z char
);
create rule can_set_tag_audit_update AS
    ON UPDATE TO can_set_tag_target DO  INSERT INTO can_set_tag_audit (t, x, y, z)
  VALUES (now(), old.x, old.y, old.z);
insert into can_set_tag_target select i, i + 1, i + 2 from generate_series(1,2) as i;
create role unpriv;
grant all on can_set_tag_target to unpriv;
grant all on can_set_tag_audit to unpriv;
set role unpriv;
show optimizer;
ERROR:  unrecognized configuration parameter "optimizer"
update can_set_tag_target set y = y + 1;
select count(1) from can_set_tag_audit;
 count 
-------
     2
(1 row)

                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.can_set_tag_audit
 Optimizer: PolarDB PX Optimizer
(5 rows)

reset role;
revoke all on can_set_tag_target from unpriv;
revoke all on can_set_tag_audit from unpriv;
drop role unpriv;
drop table can_set_tag_target;
drop table can_set_tag_audit;
-- start_ignore
create language plpython3u;
ERROR:  language "plpython3u" already exists
-- end_ignore
-- Checking if ORCA uses parser's canSetTag for CREATE TABLE AS SELECT
create or replace function canSetTag_Func(x int) returns int as $$
    if (x is None):
        return 0
    else:
        return x * 3
$$ language plpython3u;
create table canSetTag_input_data (domain integer, class integer, attr text, value integer)
   ;
insert into canSetTag_input_data values(1, 1, 'A', 1);
insert into canSetTag_input_data values(2, 1, 'A', 0);
insert into canSetTag_input_data values(3, 0, 'B', 1);
create table canSetTag_bug_table as
SELECT attr, class, (select canSetTag_Func(count(distinct class)::int) from canSetTag_input_data)
   as dclass FROM canSetTag_input_data GROUP BY attr, class ;
drop function canSetTag_Func(x int);
drop table canSetTag_bug_table;
drop table canSetTag_input_data;
-- Test B-Tree index scan with in list
CREATE TABLE btree_test as SELECT i a, i b FROM generate_series(1,100) i ;
ANALYZE btree_test;
CREATE INDEX btree_test_index ON btree_test(a);
set polar_px_optimizer_enable_seqscan = off;
-- start_ignore
select disable_xform('CXformSelect2IndexGet');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformSelect2IndexGet');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
explain (costs off) select * FROM btree_test WHERE a in (1, 47);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on btree_test
   Filter: (a = ANY ('{1,47}'::integer[]))
(2 rows)

explain (costs off) select * FROM btree_test WHERE a in ('2', 47);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on btree_test
   Filter: (a = ANY ('{2,47}'::integer[]))
(2 rows)

explain (costs off) select * FROM btree_test WHERE a in ('1', '2');
                QUERY PLAN                
------------------------------------------
 Seq Scan on btree_test
   Filter: (a = ANY ('{1,2}'::integer[]))
(2 rows)

explain (costs off) select * FROM btree_test WHERE a in ('1', '2', 47);
                 QUERY PLAN                  
---------------------------------------------
 Seq Scan on btree_test
   Filter: (a = ANY ('{1,2,47}'::integer[]))
(2 rows)

SELECT * FROM btree_test WHERE a in ('1', '2', 47);
 a  | b  
----+----
  1 |  1
  2 |  2
 47 | 47
(3 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Bitmap Heap Scan on orca.btree_test
         Output: a, b
         Recheck Cond: (btree_test.a = ANY ('{1,2,47}'::integer[]))
         ->  Partial Bitmap Index Scan on btree_test_index
               Index Cond: (btree_test.a = ANY ('{1,2,47}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(8 rows)

CREATE INDEX btree_test_index_ab ON btree_test using btree(a,b);
explain (costs off) select * FROM btree_test WHERE a in (1, 2, 47) AND b > 1;
                        QUERY PLAN                         
-----------------------------------------------------------
 Seq Scan on btree_test
   Filter: ((b > 1) AND (a = ANY ('{1,2,47}'::integer[])))
(2 rows)

SELECT * FROM btree_test WHERE a in (1, 2, 47) AND b > 1;
 a  | b  
----+----
  2 |  2
 47 | 47
(2 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Index Scan using btree_test_index_ab on orca.btree_test
         Output: a, b
         Index Cond: (btree_test.b > 1)
         Filter: (btree_test.a = ANY ('{1,2,47}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(7 rows)

-- start_ignore
select enable_xform('CXformSelect2IndexGet');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformSelect2IndexGet');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
reset polar_px_optimizer_enable_seqscan;
-- Test Bitmap index scan with in list
CREATE TABLE bitmap_test as SELECT * FROM generate_series(1,100) as a ;
ANALYZE bitmap_test;
CREATE INDEX bitmap_index ON bitmap_test USING BITMAP(a);
ERROR:  access method "bitmap" does not exist
explain (costs off) select * FROM bitmap_test WHERE a in (1);
       QUERY PLAN        
-------------------------
 Seq Scan on bitmap_test
   Filter: (a = 1)
(2 rows)

explain (costs off) select * FROM bitmap_test WHERE a in (1, 47);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on bitmap_test
   Filter: (a = ANY ('{1,47}'::integer[]))
(2 rows)

explain (costs off) select * FROM bitmap_test WHERE a in ('2', 47);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on bitmap_test
   Filter: (a = ANY ('{2,47}'::integer[]))
(2 rows)

explain (costs off) select * FROM bitmap_test WHERE a in ('1', '2');
                QUERY PLAN                
------------------------------------------
 Seq Scan on bitmap_test
   Filter: (a = ANY ('{1,2}'::integer[]))
(2 rows)

explain (costs off) select * FROM bitmap_test WHERE a in ('1', '2', 47);
                 QUERY PLAN                  
---------------------------------------------
 Seq Scan on bitmap_test
   Filter: (a = ANY ('{1,2,47}'::integer[]))
(2 rows)

-- Test Logging for unsupported features in ORCA
-- start_ignore
drop table if exists foo;
-- end_ignore
create table foo(a int, b int) ;
-- The amount of log messages you get depends on a lot of options, but any
-- difference in the output will make the test fail. Disable log_statement
-- and log_min_duration_statement, they are the most obvious ones.
explain (costs off) select count(*) from foo group by cube(a,b);
      QUERY PLAN       
-----------------------
 MixedAggregate
   Hash Key: a, b
   Hash Key: a
   Hash Key: b
   Group Key: ()
   ->  Seq Scan on foo
(6 rows)

-- TVF accepts ANYENUM, ANYELEMENT returns ANYENUM, ANYARRAY
CREATE TYPE rainbow AS ENUM('red','yellow','blue');
CREATE FUNCTION func_enum_element(ANYENUM, ANYELEMENT) RETURNS TABLE(a ANYENUM, b ANYARRAY)
AS $$ SELECT $1, ARRAY[$2] $$ LANGUAGE SQL STABLE;
SELECT * FROM func_enum_element('red'::rainbow, 'blue'::rainbow::anyelement);
  a  |   b    
-----+--------
 red | {blue}
(1 row)

DROP FUNCTION IF EXISTS func_enum_element(ANYENUM, ANYELEMENT);
-- TVF accepts ANYELEMENT, ANYARRAY returns ANYELEMENT, ANYENUM
CREATE FUNCTION func_element_array(ANYELEMENT, ANYARRAY) RETURNS TABLE(a ANYELEMENT, b ANYENUM)
AS $$ SELECT $1, $2[1]$$ LANGUAGE SQL STABLE;
SELECT * FROM func_element_array('red'::rainbow, ARRAY['blue'::rainbow]);
  a  |  b   
-----+------
 red | blue
(1 row)

DROP FUNCTION IF EXISTS func_element_array(ANYELEMENT, ANYARRAY);
-- TVF accepts ANYARRAY, ANYENUM returns ANYELEMENT
CREATE FUNCTION func_element_array(ANYARRAY, ANYENUM) RETURNS TABLE(a ANYELEMENT, b ANYELEMENT)
AS $$ SELECT $1[1], $2 $$ LANGUAGE SQL STABLE;
SELECT * FROM func_element_array(ARRAY['blue'::rainbow], 'blue'::rainbow);
  a   |  b   
------+------
 blue | blue
(1 row)

DROP FUNCTION IF EXISTS func_element_array(ANYARRAY, ANYENUM);
-- TVF accepts ANYARRAY argument returns ANYELEMENT, ANYENUM
CREATE FUNCTION func_array(ANYARRAY) RETURNS TABLE(a ANYELEMENT, b ANYENUM)
AS $$ SELECT $1[1], $1[2] $$ LANGUAGE SQL STABLE;
SELECT * FROM func_array(ARRAY['blue'::rainbow, 'yellow'::rainbow]);
  a   |   b    
------+--------
 blue | yellow
(1 row)

DROP FUNCTION IF EXISTS func_array(ANYARRAY);
-- TVF accepts ANYELEMENT, VARIADIC ARRAY returns ANYARRAY
CREATE FUNCTION func_element_variadic(ANYELEMENT, VARIADIC ANYARRAY) RETURNS TABLE(a ANYARRAY)
AS $$ SELECT array_prepend($1, $2); $$ LANGUAGE SQL STABLE;
SELECT * FROM func_element_variadic(1.1, 1.1, 2.2, 3.3);
         a         
-------------------
 {1.1,1.1,2.2,3.3}
(1 row)

DROP FUNCTION IF EXISTS func_element_variadic(ANYELEMENT, VARIADIC ANYARRAY);
-- TVF accepts ANYNONARRAY returns ANYNONARRAY
CREATE FUNCTION func_nonarray(ANYNONARRAY) RETURNS TABLE(a ANYNONARRAY)
AS $$ SELECT $1; $$ LANGUAGE SQL STABLE;
SELECT * FROM func_nonarray(5);
 a 
---
 5
(1 row)

DROP FUNCTION IF EXISTS func_nonarray(ANYNONARRAY);
-- TVF accepts ANYNONARRAY, ANYENUM returns ANYARRAY
CREATE FUNCTION func_nonarray_enum(ANYNONARRAY, ANYENUM) RETURNS TABLE(a ANYARRAY)
AS $$ SELECT ARRAY[$1, $2]; $$ LANGUAGE SQL STABLE;
SELECT * FROM func_nonarray_enum('blue'::rainbow, 'red'::rainbow);
     a      
------------
 {blue,red}
(1 row)

DROP FUNCTION IF EXISTS func_nonarray_enum(ANYNONARRAY, ANYENUM);
-- TVF accepts ANYARRAY, ANYNONARRAY, ANYENUM returns ANYNONARRAY
CREATE FUNCTION func_array_nonarray_enum(ANYARRAY, ANYNONARRAY, ANYENUM) RETURNS TABLE(a ANYNONARRAY)
AS $$ SELECT $1[1]; $$ LANGUAGE SQL STABLE;
SELECT * FROM func_array_nonarray_enum(ARRAY['blue'::rainbow, 'red'::rainbow], 'red'::rainbow, 'yellow'::rainbow);
  a   
------
 blue
(1 row)

DROP FUNCTION IF EXISTS func_array_nonarray_enum(ANYARRAY, ANYNONARRAY, ANYENUM);
--TVF accepts ANYENUM, ANYELEMENT, ANYELEMENT return ANYENUM, ANYARRAY
CREATE FUNCTION return_enum_as_array(ANYENUM, ANYELEMENT, ANYELEMENT) RETURNS TABLE (ae ANYENUM, aa ANYARRAY)
AS $$ SELECT $1, array[$2, $3] $$ LANGUAGE SQL STABLE;
SELECT * FROM return_enum_as_array('red'::rainbow, 'yellow'::rainbow, 'blue'::rainbow);
 ae  |      aa       
-----+---------------
 red | {yellow,blue}
(1 row)

DROP FUNCTION IF EXISTS return_enum_as_array(ANYENUM, ANYELEMENT, ANYELEMENT);
-- start_ignore
drop table foo;
-- end_ignore
-- Test GPDB Expr (T_ArrayCoerceExpr) conversion to Scalar Array Coerce Expr
-- start_ignore
create table foo (a int, b character varying(10));
-- end_ignore
-- Query should not fallback to planner
explain (costs off) select * from foo where b in ('1', '2');
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on foo
   Filter: ((b)::text = ANY ('{1,2}'::text[]))
(2 rows)

set polar_px_optimizer_enable_ctas = off;
create table foo_ctas(a) as (select generate_series(1,10));
reset polar_px_optimizer_enable_ctas;
-- Test to ensure that ORCA produces correct results for a query with an Agg on top of LOJ
-- start_ignore
create table input_tab1 (a int, b int);
create table input_tab2 (c int, d int);
insert into input_tab1 values (1, 1);
analyze input_tab1;
insert into input_tab1 values (NULL, NULL);
set polar_px_optimizer_force_multistage_agg = off;
set polar_px_optimizer_force_three_stage_scalar_dqa = off;
-- end_ignore
explain (costs off) select count(*), t2.c from input_tab1 t1 left join input_tab2 t2 on t1.a = t2.c group by t2.c;
                    QUERY PLAN                     
---------------------------------------------------
 GroupAggregate
   Group Key: t2.c
   ->  Sort
         Sort Key: t2.c
         ->  Hash Right Join
               Hash Cond: (t2.c = t1.a)
               ->  Seq Scan on input_tab2 t2
               ->  Hash
                     ->  Seq Scan on input_tab1 t1
(9 rows)

select count(*), t2.c from input_tab1 t1 left join input_tab2 t2 on t1.a = t2.c group by t2.c;
 count | c 
-------+---
     2 |  
(1 row)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: (count()), input_tab2.c
   ->  Finalize GroupAggregate
         Output: count(), input_tab2.c
         Group Key: input_tab2.c
         ->  Sort
               Output: input_tab2.c, (PARTIAL count())
               Sort Key: input_tab2.c
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: input_tab2.c, (PARTIAL count())
                     Hash Key: input_tab2.c
                     ->  Partial GroupAggregate
                           Output: input_tab2.c, PARTIAL count()
                           Group Key: input_tab2.c
                           ->  Sort
                                 Output: input_tab2.c
                                 Sort Key: input_tab2.c
                                 ->  Hash Left Join
                                       Output: input_tab2.c
                                       Hash Cond: (input_tab1.a = input_tab2.c)
                                       ->  Partial Seq Scan on orca.input_tab1
                                             Output: input_tab1.a
                                       ->  Hash
                                             Output: input_tab2.c
                                             ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                   Output: input_tab2.c
                                                   ->  Partial Seq Scan on orca.input_tab2
                                                         Output: input_tab2.c
 Optimizer: PolarDB PX Optimizer
(29 rows)

-- start_ignore
reset polar_px_optimizer_force_multistage_agg;
reset polar_px_optimizer_force_three_stage_scalar_dqa;
-- end_ignore
--
-- Test to ensure orca produces correct equivalence class for an alias projected by a LOJ and thus producing correct results.
-- Previously, orca produced an incorrect filter (cd2 = cd) on top of LOJ which led to incorrect results as column 'cd' is
-- produced by a nullable side of LOJ (tab2).
--
-- start_ignore
CREATE TABLE tab_1 (id VARCHAR(32)) ;
INSERT INTO tab_1 VALUES('qwert'), ('vbn');
ANALYZE tab_1;
CREATE TABLE tab_2(key VARCHAR(200) NOT NULL, id VARCHAR(32) NOT NULL, cd VARCHAR(2) NOT NULL) ;
INSERT INTO tab_2 VALUES('abc', 'rew', 'dr');
ANALYZE tab_2;
INSERT INTO tab_2 VALUES('tyu', 'rer', 'fd');
CREATE TABLE tab_3 (region TEXT, code TEXT) ;
INSERT INTO tab_3 VALUES('cvb' ,'tyu');
ANALYZE tab_3;
INSERT INTO tab_3 VALUES('hjj' ,'xyz');
-- end_ignore
explain (costs off) select Count(*)
FROM   (SELECT *
        FROM   (SELECT tab_2.cd AS CD1,
                       tab_2.cd AS CD2
                FROM   tab_1
                       LEFT JOIN tab_2
                              ON tab_1.id = tab_2.id) f
        UNION ALL
        SELECT region,
               code
        FROM   tab_3)a;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Nested Loop Left Join
               Join Filter: ((tab_1.id)::text = (tab_2.id)::text)
               ->  Seq Scan on tab_1
               ->  Materialize
                     ->  Seq Scan on tab_2
         ->  Subquery Scan on "*SELECT* 2"
               ->  Seq Scan on tab_3
(9 rows)

SELECT Count(*)
FROM   (SELECT *
        FROM   (SELECT tab_2.cd AS CD1,
                       tab_2.cd AS CD2
                FROM   tab_1
                       LEFT JOIN tab_2
                              ON tab_1.id = tab_2.id) f
        UNION ALL
        SELECT region,
               code
        FROM   tab_3)a;
 count 
-------
     4
(1 row)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Append
               ->  Hash Left Join
                     Hash Cond: ((tab_1.id)::text = (tab_2.id)::text)
                     ->  Partial Seq Scan on orca.tab_1
                           Output: tab_1.id
                     ->  Hash
                           Output: tab_2.id, tab_2.cd
                           ->  PX Broadcast 6:6  (slice2; segments: 6)
                                 Output: tab_2.id, tab_2.cd
                                 ->  Partial Seq Scan on orca.tab_2
                                       Output: tab_2.id, tab_2.cd
               ->  Partial Seq Scan on orca.tab_3
 Optimizer: PolarDB PX Optimizer
(16 rows)

--
-- Test to ensure that ORCA produces correct results with both blocking and
-- streaming materialze as controlled by optimizer_enable_streaming_material
-- GUC.
--
-- start_ignore
create table t_outer (c1 integer);
create table t_inner (c2 integer);
insert into t_outer values (generate_series (1,10));
insert into t_inner values (generate_series (1,300));
-- end_ignore
set polar_px_optimizer_enable_streaming_material = on;
select c1 from t_outer where not c1 =all (select c2 from t_inner);
 c1 
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t_outer.c1
   ->  Partial Seq Scan on orca.t_outer
         Output: t_outer.c1
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Materialize
                 Output: t_inner.c2
                 ->  PX Broadcast 6:6  (slice2; segments: 6)
                       Output: t_inner.c2
                       ->  Partial Seq Scan on orca.t_inner
                             Output: t_inner.c2
 Optimizer: PolarDB PX Optimizer
(13 rows)

set polar_px_optimizer_enable_streaming_material = off;
select c1 from t_outer where not c1 =all (select c2 from t_inner);
 c1 
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t_outer.c1
   ->  Partial Seq Scan on orca.t_outer
         Output: t_outer.c1
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Materialize
                 Output: t_inner.c2
                 ->  PX Broadcast 6:6  (slice2; segments: 6)
                       Output: t_inner.c2
                       ->  Partial Seq Scan on orca.t_inner
                             Output: t_inner.c2
 Optimizer: PolarDB PX Optimizer
(13 rows)

reset polar_px_optimizer_enable_streaming_material;
-- Ensure that ORCA rescans the subquery in case of skip-level correlation with
-- materialization
drop table if exists wst0, wst1, wst2;
NOTICE:  table "wst0" does not exist, skipping
NOTICE:  table "wst1" does not exist, skipping
NOTICE:  table "wst2" does not exist, skipping
create table wst0(a0 int, b0 int);
create table wst1(a1 int, b1 int);
create table wst2(a2 int, b2 int);
insert into wst0 select i, i from generate_series(1,10) i;
insert into wst1 select i, i from generate_series(1,10) i;
insert into wst2 select i, i from generate_series(1,10) i;
-- NB: the rank() is need to force materialization (via Sort) in the subplan
select count(*) from wst0 where exists (select 1, rank() over (order by wst1.a1) from wst1 where a1 = (select b2 from wst2 where a0=a2+5));
 count 
-------
     5
(1 row)

                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count()
   ->  Result
         Output: wst0.a0
         Filter: (SubPlan 2)
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: wst0.a0
               ->  Partial Seq Scan on orca.wst0
                     Output: wst0.a0
         SubPlan 2
           ->  WindowAgg
                 Output: wst1.a1
                 ->  Sort
                       Output: wst1.a1
                       Sort Key: wst1.a1
                       ->  Result
                             Output: wst1.a1
                             Filter: (wst1.a1 = (SubPlan 1))
                             ->  Materialize
                                   Output: wst1.a1
                                   ->  PX Coordinator 6:1  (slice2; segments: 6)
                                         Output: wst1.a1
                                         ->  Partial Seq Scan on orca.wst1
                                               Output: wst1.a1
                             SubPlan 1
                               ->  Result
                                     Output: wst2.b2
                                     Filter: (wst0.a0 = (wst2.a2 + 5))
                                     ->  Materialize
                                           Output: wst2.a2, wst2.b2
                                           ->  PX Coordinator 6:1  (slice3; segments: 6)
                                                 Output: wst2.a2, wst2.b2
                                                 ->  Partial Seq Scan on orca.wst2
                                                       Output: wst2.a2, wst2.b2
 Optimizer: PolarDB PX Optimizer
(35 rows)

--
-- Test to ensure sane behavior when DML queries are optimized by ORCA by
-- enforcing a non-master gather motion, controlled by
-- optimizer_enable_gather_on_segment_for_DML GUC
--
--
-- CTAS with global-local aggregation
--
-- start_ignore
create table test1 (a int, b int);
insert into test1 select generate_series(1,100),generate_series(1,100);
-- end_ignore
create table t_new as select avg(a) from test1 join (select i from unnest(array[1,2,3]) i) t on (test1.a = t.i);
select * from t_new;
        avg         
--------------------
 2.0000000000000000
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: avg
   ->  Partial Seq Scan on orca.t_new
         Output: avg
 Optimizer: PolarDB PX Optimizer
(5 rows)

-- start_ignore
drop table t_new;
set polar_px_optimizer_enable_gather_on_segment_for_DML=off;
-- end_ignore
create table t_new as select avg(a) from test1 join (select i from unnest(array[1,2,3]) i) t on (test1.a = t.i);
select * from t_new;
        avg         
--------------------
 2.0000000000000000
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: avg
   ->  Partial Seq Scan on orca.t_new
         Output: avg
 Optimizer: PolarDB PX Optimizer
(5 rows)

-- start_ignore
reset polar_px_optimizer_enable_gather_on_segment_for_DML;
-- end_ignore
--
-- Insert with outer references in the subquery
--
-- start_ignore
create table x_tab(a int);
create table y_tab(a int);
create table z_tab(a int);
insert into x_tab values(1);
insert into y_tab values(0);
insert into z_tab values(1);
-- end_ignore
insert into x_tab select * from x_tab where exists (select * from x_tab where x_tab.a = (select x_tab.a + y_tab.a from y_tab));
select * from x_tab;
 a 
---
 1
 1
(2 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.x_tab
         Output: a
 Optimizer: PolarDB PX Optimizer
(5 rows)

--
-- Insert with Union All with an universal child
--
insert into y_tab select 1 union all select a from x_tab limit 10;
select * from y_tab;
 a 
---
 0
 1
 1
 1
(4 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.y_tab
         Output: a
 Optimizer: PolarDB PX Optimizer
(5 rows)

--
-- Insert with a function containing a SQL
--
create or replace function test_func_pg_stats()
returns integer
as $$ declare cnt int; begin execute 'select count(*) from pg_statistic' into cnt; return cnt; end $$
language plpgsql volatile READS SQL DATA;
ERROR:  syntax error at or near "READS"
LINE 4: language plpgsql volatile READS SQL DATA;
                                  ^
insert into y_tab select test_func_pg_stats() from x_tab limit 2;
ERROR:  function test_func_pg_stats() does not exist
LINE 1: insert into y_tab select test_func_pg_stats() from x_tab lim...
                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select count(*) from y_tab;
 count 
-------
     4
(1 row)

                   QUERY PLAN                    
-------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on orca.y_tab
 Optimizer: PolarDB PX Optimizer
(5 rows)

--
-- Delete with Hash Join with a universal child
--
delete from x_tab where exists (select z_tab.a from z_tab join (select 1 as g) as tab on z_tab.a = tab.g);
select * from x_tab;
 a 
---
(0 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.x_tab
         Output: a
 Optimizer: PolarDB PX Optimizer
(5 rows)

-- start_ignore
drop table bar;
ERROR:  table "bar" does not exist
-- end_ignore
-- TVF with a subplan that generates an RTABLE entry
create table bar(name text);
insert into bar values('person');
select * from unnest((select string_to_array(name, ',') from bar)) as a;
   a    
--------
 person
(1 row)

-- Query should not fall back to planner and handle implicit cast properly
CREATE TYPE myint;
CREATE FUNCTION myintout(myint) RETURNS cstring AS 'int4out' LANGUAGE INTERNAL STRICT IMMUTABLE;
NOTICE:  argument type myint is only a shell
CREATE FUNCTION myintin(cstring) RETURNS myint AS 'int4in' LANGUAGE INTERNAL STRICT IMMUTABLE;
NOTICE:  return type myint is only a shell
CREATE TYPE myint
(
	INPUT=myintin,
	OUTPUT=myintout,
	INTERNALLENGTH=4,
	PASSEDBYVALUE
);
CREATE FUNCTION myint_int8(myint) RETURNS int8 AS 'int48' LANGUAGE INTERNAL STRICT IMMUTABLE;
CREATE CAST (myint AS int8) WITH FUNCTION myint_int8(myint) AS IMPLICIT;
CREATE TABLE csq_cast_param_outer (a int, b myint);
INSERT INTO csq_cast_param_outer VALUES
	(1, '42'),
	(2, '12');
CREATE TABLE csq_cast_param_inner (c int, d myint);
INSERT INTO csq_cast_param_inner VALUES
	(11, '11'),
	(101, '12');
explain (costs off) select a FROM csq_cast_param_outer WHERE b in (SELECT CASE WHEN a > 1 THEN d ELSE '42' END FROM csq_cast_param_inner);
                QUERY PLAN                
------------------------------------------
 Seq Scan on csq_cast_param_outer
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Seq Scan on csq_cast_param_inner
(4 rows)

SELECT a FROM csq_cast_param_outer WHERE b in (SELECT CASE WHEN a > 1 THEN d ELSE '42' END FROM csq_cast_param_inner);
 a 
---
 1
 2
(2 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: csq_cast_param_outer.a
   ->  Partial Seq Scan on orca.csq_cast_param_outer
         Output: csq_cast_param_outer.a
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 Output: CASE WHEN (csq_cast_param_outer.a > 1) THEN csq_cast_param_inner.d ELSE '42'::myint END
                 ->  Materialize
                       Output: csq_cast_param_inner.d
                       ->  PX Broadcast 6:6  (slice2; segments: 6)
                             Output: csq_cast_param_inner.d
                             ->  Partial Seq Scan on orca.csq_cast_param_inner
                                   Output: csq_cast_param_inner.d
 Optimizer: PolarDB PX Optimizer
(15 rows)

DROP CAST (myint as int8);
CREATE FUNCTION myint_numeric(myint) RETURNS numeric AS 'int4_numeric' LANGUAGE INTERNAL STRICT IMMUTABLE;
CREATE CAST (myint AS numeric) WITH FUNCTION myint_numeric(myint) AS IMPLICIT;
explain (costs off) select a FROM csq_cast_param_outer WHERE b in (SELECT CASE WHEN a > 1 THEN d ELSE '42' END FROM csq_cast_param_inner);
                QUERY PLAN                
------------------------------------------
 Seq Scan on csq_cast_param_outer
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Seq Scan on csq_cast_param_inner
(4 rows)

SELECT a FROM csq_cast_param_outer WHERE b in (SELECT CASE WHEN a > 1 THEN d ELSE '42' END FROM csq_cast_param_inner);
 a 
---
 1
 2
(2 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: csq_cast_param_outer.a
   ->  Partial Seq Scan on orca.csq_cast_param_outer
         Output: csq_cast_param_outer.a
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 Output: CASE WHEN (csq_cast_param_outer.a > 1) THEN csq_cast_param_inner.d ELSE '42'::myint END
                 ->  Materialize
                       Output: csq_cast_param_inner.d
                       ->  PX Broadcast 6:6  (slice2; segments: 6)
                             Output: csq_cast_param_inner.d
                             ->  Partial Seq Scan on orca.csq_cast_param_inner
                                   Output: csq_cast_param_inner.d
 Optimizer: PolarDB PX Optimizer
(15 rows)

SELECT a FROM ggg WHERE a IN (NULL, 'x');
 a 
---
 x
 x
 x
(3 rows)

                      QUERY PLAN                      
------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.ggg
         Output: a
         Filter: (ggg.a = ANY ('{NULL,x}'::bpchar[]))
 Optimizer: PolarDB PX Optimizer
(6 rows)

explain (costs off) select a FROM ggg WHERE a NOT IN (NULL, '');
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on ggg
   Filter: (a <> ALL ('{NULL,""}'::bpchar[]))
(2 rows)

explain (costs off) select a FROM ggg WHERE a IN (NULL, 'x');
                 QUERY PLAN                 
--------------------------------------------
 Seq Scan on ggg
   Filter: (a = ANY ('{NULL,x}'::bpchar[]))
(2 rows)

-- result node with one time filter and filter
CREATE TABLE onetimefilter1 (a int, b int);
CREATE TABLE onetimefilter2 (a int, b int);
INSERT INTO onetimefilter1 SELECT i, i FROM generate_series(1,10)i;
INSERT INTO onetimefilter2 SELECT i, i FROM generate_series(1,10)i;
ANALYZE onetimefilter1;
ANALYZE onetimefilter2;
EXPLAIN WITH abc AS (SELECT onetimefilter1.a, onetimefilter1.b FROM onetimefilter1, onetimefilter2 WHERE onetimefilter1.a=onetimefilter2.a) SELECT (SELECT 1 FROM abc WHERE f1.b = f2.b LIMIT 1), COALESCE((SELECT 2 FROM abc WHERE f1.a=random() AND f1.a=2), 0), (SELECT b FROM abc WHERE b=f1.b) FROM onetimefilter1 f1, onetimefilter2 f2 WHERE f1.b = f2.b;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Hash Join  (cost=3.69..10.18 rows=10 width=12)
   Hash Cond: (f1.b = f2.b)
   CTE abc
     ->  Hash Join  (cost=1.23..2.46 rows=10 width=8)
           Hash Cond: (onetimefilter1.a = onetimefilter2.a)
           ->  Seq Scan on onetimefilter1  (cost=0.00..1.10 rows=10 width=8)
           ->  Hash  (cost=1.10..1.10 rows=10 width=4)
                 ->  Seq Scan on onetimefilter2  (cost=0.00..1.10 rows=10 width=4)
   ->  Seq Scan on onetimefilter1 f1  (cost=0.00..1.10 rows=10 width=8)
   ->  Hash  (cost=1.10..1.10 rows=10 width=4)
         ->  Seq Scan on onetimefilter2 f2  (cost=0.00..1.10 rows=10 width=4)
   SubPlan 2
     ->  Limit  (cost=0.00..0.02 rows=1 width=4)
           ->  Result  (cost=0.00..0.20 rows=10 width=4)
                 One-Time Filter: (f1.b = f2.b)
                 ->  CTE Scan on abc  (cost=0.00..0.20 rows=10 width=0)
   SubPlan 3
     ->  Result  (cost=0.00..0.28 rows=1 width=4)
           One-Time Filter: (f1.a = 2)
           ->  CTE Scan on abc abc_1  (cost=0.00..0.28 rows=1 width=0)
                 Filter: ((f1.a)::double precision = random())
   SubPlan 4
     ->  CTE Scan on abc abc_2  (cost=0.00..0.22 rows=1 width=4)
           Filter: (b = f1.b)
(24 rows)

WITH abc AS (SELECT onetimefilter1.a, onetimefilter1.b FROM onetimefilter1, onetimefilter2 WHERE onetimefilter1.a=onetimefilter2.a) SELECT (SELECT 1 FROM abc WHERE f1.b = f2.b LIMIT 1), COALESCE((SELECT 2 FROM abc WHERE f1.a=random() AND f1.a=2), 0), (SELECT b FROM abc WHERE b=f1.b) FROM onetimefilter1 f1, onetimefilter2 f2 WHERE f1.b = f2.b;
 ?column? | coalesce | b  
----------+----------+----
        1 |        0 |  1
        1 |        0 |  2
        1 |        0 |  3
        1 |        0 |  4
        1 |        0 |  5
        1 |        0 |  6
        1 |        0 |  7
        1 |        0 |  8
        1 |        0 |  9
        1 |        0 | 10
(10 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ((SubPlan 1)), (COALESCE((SubPlan 2), 0)), ((SubPlan 3))
   ->  Sequence
         Output: ((SubPlan 1)), (COALESCE((SubPlan 2), 0)), ((SubPlan 3))
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref4.a, share0_ref4.b
               ->  Hash Join
                     Output: onetimefilter1.a, onetimefilter1.b
                     Hash Cond: (onetimefilter1.a = onetimefilter2.a)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: onetimefilter1.a, onetimefilter1.b
                           Hash Key: onetimefilter1.a
                           ->  Partial Seq Scan on orca.onetimefilter1
                                 Output: onetimefilter1.a, onetimefilter1.b
                     ->  Hash
                           Output: onetimefilter2.a
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: onetimefilter2.a
                                 Hash Key: onetimefilter2.a
                                 ->  Partial Seq Scan on orca.onetimefilter2
                                       Output: onetimefilter2.a
         ->  Hash Join
               Output: (SubPlan 1), COALESCE((SubPlan 2), 0), (SubPlan 3)
               Hash Cond: (onetimefilter1_1.b = onetimefilter2_1.b)
               ->  PX Hash 6:6  (slice4; segments: 6)
                     Output: onetimefilter1_1.a, onetimefilter1_1.b
                     Hash Key: onetimefilter1_1.b
                     ->  Partial Seq Scan on orca.onetimefilter1 onetimefilter1_1
                           Output: onetimefilter1_1.a, onetimefilter1_1.b
               ->  Hash
                     Output: onetimefilter2_1.b
                     ->  PX Hash 6:6  (slice5; segments: 6)
                           Output: onetimefilter2_1.b
                           Hash Key: onetimefilter2_1.b
                           ->  Partial Seq Scan on orca.onetimefilter2 onetimefilter2_1
                                 Output: onetimefilter2_1.b
               SubPlan 1
                 ->  Result
                       Output: 1
                       ->  Limit
                             ->  Result
                                   One-Time Filter: (onetimefilter1_1.b = onetimefilter2_1.b)
                                   ->  Materialize
                                         ->  PX Broadcast 6:6  (slice6; segments: 6)
                                               ->  Result
                                                     ->  Shared Scan (Consumer; slice6; share0)
                                                           Output: share0_ref1.a, share0_ref1.b
               SubPlan 2
                 ->  Result
                       Output: 2
                       ->  Result
                             One-Time Filter: (onetimefilter1_1.a = 2)
                             Filter: ((onetimefilter1_1.a)::double precision = random())
                             ->  Materialize
                                   ->  PX Broadcast 6:6  (slice7; segments: 6)
                                         ->  Result
                                               ->  Shared Scan (Consumer; slice7; share0)
                                                     Output: share0_ref2.a, share0_ref2.b
               SubPlan 3
                 ->  Result
                       Output: share0_ref3.b
                       Filter: (share0_ref3.b = onetimefilter1_1.b)
                       ->  Materialize
                             Output: share0_ref3.b
                             ->  PX Broadcast 6:6  (slice8; segments: 6)
                                   Output: share0_ref3.b
                                   ->  Result
                                         Output: share0_ref3.b
                                         ->  Shared Scan (Consumer; slice8; share0)
                                               Output: share0_ref3.a, share0_ref3.b
 Optimizer: PolarDB PX Optimizer
(71 rows)

-- full joins with predicates
DROP TABLE IF EXISTS ffoo, fbar;
NOTICE:  table "ffoo" does not exist, skipping
NOTICE:  table "fbar" does not exist, skipping
CREATE TABLE ffoo (a, b) AS (VALUES (1, 2), (2, 3), (4, 5), (5, 6), (6, 7)) ;
CREATE TABLE fbar (c, d) AS (VALUES (1, 42), (2, 43), (4, 45), (5, 46)) ;
SELECT d FROM ffoo FULL OUTER JOIN fbar ON a = c WHERE b BETWEEN 5 and 9;
 d  
----
 45
 46
   
(3 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fbar.d
   ->  Hash Left Join
         Output: fbar.d
         Hash Cond: (ffoo.a = fbar.c)
         ->  Partial Seq Scan on orca.ffoo
               Output: ffoo.a
               Filter: ((ffoo.b >= 5) AND (ffoo.b <= 9))
         ->  Hash
               Output: fbar.c, fbar.d
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: fbar.c, fbar.d
                     ->  Partial Seq Scan on orca.fbar
                           Output: fbar.c, fbar.d
 Optimizer: PolarDB PX Optimizer
(15 rows)

-- test index left outer joins on bitmap and btree indexes on partitioned tables with and without select clause
DROP TABLE IF EXISTS touter, tinner;
NOTICE:  table "touter" does not exist, skipping
NOTICE:  table "tinner" does not exist, skipping
CREATE TABLE touter(a int, b int) ;
CREATE TABLE tinnerbitmap(a int, b int)  PARTITION BY range(b);
CREATE TABLE tinnerbtree(a int, b int)  PARTITION BY range(b);
CREATE TABLE tinnerbitmap_p1 PARTITION of tinnerbitmap for values from (0) to (3);
CREATE TABLE tinnerbitmap_p2 PARTITION of tinnerbitmap for values from (3) to (6);
CREATE TABLE tinnerbtree_p1 PARTITION of tinnerbtree for values from (0) to (3);
CREATE TABLE tinnerbtree_p2 PARTITION of tinnerbtree for values from (3) to (6);
INSERT INTO touter SELECT i, i%6 FROM generate_series(1,10) i;
INSERT INTO tinnerbitmap select i, i%6 FROM generate_series(1,1000) i;
INSERT INTO tinnerbtree select i, i%6 FROM generate_series(1,1000) i;
CREATE INDEX tinnerbitmap_ix ON tinnerbitmap USING bitmap(a);
ERROR:  access method "bitmap" does not exist
CREATE INDEX tinnerbtree_ix ON tinnerbtree USING btree(a);
SELECT * FROM touter LEFT JOIN tinnerbitmap ON touter.a = tinnerbitmap.a;
 a  | b | a  | b 
----+---+----+---
  1 | 1 |  1 | 1
  2 | 2 |  2 | 2
  3 | 3 |  3 | 3
  4 | 4 |  4 | 4
  5 | 5 |  5 | 5
  6 | 0 |  6 | 0
  7 | 1 |  7 | 1
  8 | 2 |  8 | 2
  9 | 3 |  9 | 3
 10 | 4 | 10 | 4
(10 rows)

                                QUERY PLAN                                
--------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: touter.a, touter.b, tinnerbitmap_p1.a, tinnerbitmap_p1.b
   ->  Hash Right Join
         Output: touter.a, touter.b, tinnerbitmap_p1.a, tinnerbitmap_p1.b
         Hash Cond: (tinnerbitmap_p1.a = touter.a)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: tinnerbitmap_p1.a, tinnerbitmap_p1.b
               Hash Key: tinnerbitmap_p1.a
               ->  Append
                     ->  Partial Seq Scan on orca.tinnerbitmap_p1
                           Output: tinnerbitmap_p1.a, tinnerbitmap_p1.b
                     ->  Partial Seq Scan on orca.tinnerbitmap_p2
                           Output: tinnerbitmap_p2.a, tinnerbitmap_p2.b
         ->  Hash
               Output: touter.a, touter.b
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: touter.a, touter.b
                     Hash Key: touter.a
                     ->  Partial Seq Scan on orca.touter
                           Output: touter.a, touter.b
 Optimizer: PolarDB PX Optimizer
(21 rows)

SELECT * FROM touter LEFT JOIN tinnerbitmap ON touter.a = tinnerbitmap.a AND tinnerbitmap.b=10;
 a  | b | a | b 
----+---+---+---
  1 | 1 |   |  
  2 | 2 |   |  
  3 | 3 |   |  
  4 | 4 |   |  
  5 | 5 |   |  
  6 | 0 |   |  
  7 | 1 |   |  
  8 | 2 |   |  
  9 | 3 |   |  
 10 | 4 |   |  
(10 rows)

SELECT * FROM touter LEFT JOIN tinnerbtree ON touter.a = tinnerbtree.a;
 a  | b | a  | b 
----+---+----+---
  1 | 1 |  1 | 1
  2 | 2 |  2 | 2
  3 | 3 |  3 | 3
  4 | 4 |  4 | 4
  5 | 5 |  5 | 5
  6 | 0 |  6 | 0
  7 | 1 |  7 | 1
  8 | 2 |  8 | 2
  9 | 3 |  9 | 3
 10 | 4 | 10 | 4
(10 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: touter.a, touter.b, tinnerbtree_p1.a, tinnerbtree_p1.b
   ->  Nested Loop Left Join
         Output: touter.a, touter.b, tinnerbtree_p1.a, tinnerbtree_p1.b
         Join Filter: true
         ->  Partial Seq Scan on orca.touter
               Output: touter.a, touter.b
         ->  Append
               ->  Full Index Scan using tinnerbtree_p1_a_idx on orca.tinnerbtree_p1
                     Output: tinnerbtree_p1.a, tinnerbtree_p1.b
                     Index Cond: (tinnerbtree_p1.a = touter.a)
               ->  Full Index Scan using tinnerbtree_p2_a_idx on orca.tinnerbtree_p2
                     Output: tinnerbtree_p2.a, tinnerbtree_p2.b
                     Index Cond: (tinnerbtree_p2.a = touter.a)
 Optimizer: PolarDB PX Optimizer
(15 rows)

SELECT * FROM touter LEFT JOIN tinnerbtree ON touter.a = tinnerbtree.a AND tinnerbtree.b=10;
 a  | b | a | b 
----+---+---+---
  1 | 1 |   |  
  2 | 2 |   |  
  3 | 3 |   |  
  4 | 4 |   |  
  5 | 5 |   |  
  6 | 0 |   |  
  7 | 1 |   |  
  8 | 2 |   |  
  9 | 3 |   |  
 10 | 4 |   |  
(10 rows)

-- test subplan in a qual under dynamic scan
CREATE TABLE ds_part ( a INT, b INT, c INT) PARTITION BY RANGE(c);
CREATE TABLE ds_part_p1 PARTITION of ds_part for values from (1) to (3);
CREATE TABLE ds_part_p1 PARTITION of ds_part for values from (3) to (5);
ERROR:  relation "ds_part_p1" already exists
CREATE TABLE ds_part_p1 PARTITION of ds_part for values from (5) to (6);
ERROR:  relation "ds_part_p1" already exists
CREATE TABLE ds_part_p1 PARTITION of ds_part for values from (7) to (9);
ERROR:  relation "ds_part_p1" already exists
CREATE TABLE ds_part_deflt PARTITION of ds_part default;
CREATE TABLE non_part1 (c INT);
CREATE TABLE non_part2 (e INT, f INT);
INSERT INTO ds_part SELECT i, i, i FROM generate_series (1, 1000)i; 
INSERT INTO non_part1 SELECT i FROM generate_series(1, 100)i; 
INSERT INTO non_part2 SELECT i, i FROM generate_series(1, 100)i;
set polar_px_optimizer_enforce_subplans TO ON;
analyze ds_part;
analyze non_part1;
analyze non_part2;
SELECT * FROM ds_part, non_part2 WHERE ds_part.c = non_part2.e AND non_part2.f = 10 AND a IN ( SELECT b + 1 FROM non_part1);
 a | b | c | e | f 
---+---+---+---+---
(0 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c, non_part2.e, non_part2.f
   ->  Hash Join
         Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c, non_part2.e, non_part2.f
         Hash Cond: (ds_part_p1.c = non_part2.e)
         ->  Result
               Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c
               Filter: (SubPlan 1)
               ->  Append
                     Partition Selectors: $0
                     ->  Partial Seq Scan on orca.ds_part_p1
                           Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c
                           Filter: (ds_part_p1.a = (ds_part_p1.b + 1))
                     ->  Partial Seq Scan on orca.ds_part_deflt
                           Output: ds_part_deflt.a, ds_part_deflt.b, ds_part_deflt.c
                           Filter: (ds_part_deflt.a = (ds_part_deflt.b + 1))
               SubPlan 1
                 ->  Materialize
                       Output: non_part1.ctid
                       ->  PX Broadcast 1:6  (slice2)
                             Output: non_part1.ctid
                             ->  Limit
                                   Output: non_part1.ctid
                                   ->  PX Coordinator 6:1  (slice3; segments: 6)
                                         Output: non_part1.ctid
                                         ->  Limit
                                               Output: non_part1.ctid
                                               ->  Partial Seq Scan on orca.non_part1
                                                     Output: non_part1.ctid
         ->  Hash
               Output: non_part2.e, non_part2.f
               ->  Partition Selector (selector id: $0)
                     Output: non_part2.e, non_part2.f
                     ->  PX Broadcast 6:6  (slice4; segments: 6)
                           Output: non_part2.e, non_part2.f
                           ->  Partial Seq Scan on orca.non_part2
                                 Output: non_part2.e, non_part2.f
                                 Filter: (non_part2.f = 10)
 Optimizer: PolarDB PX Optimizer
(39 rows)

explain (costs off) select * FROM ds_part, non_part2 WHERE ds_part.c = non_part2.e AND non_part2.f = 10 AND a IN ( SELECT b + 1 FROM non_part1);
                 QUERY PLAN                  
---------------------------------------------
 Nested Loop
   Join Filter: (ds_part_p1.c = non_part2.e)
   ->  Seq Scan on non_part2
         Filter: (f = 10)
   ->  Append
         ->  Seq Scan on ds_part_p1
               Filter: (SubPlan 1)
               SubPlan 1
                 ->  Seq Scan on non_part1
         ->  Seq Scan on ds_part_deflt
               Filter: (SubPlan 1)
(11 rows)

SELECT *, a IN ( SELECT b + 1 FROM non_part1) FROM ds_part, non_part2 WHERE ds_part.c = non_part2.e AND non_part2.f = 10 AND a IN ( SELECT b FROM non_part1);
 a  | b  | c  | e  | f  | ?column? 
----+----+----+----+----+----------
 10 | 10 | 10 | 10 | 10 | f
(1 row)

                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c, non_part2.e, non_part2.f, (((ds_part_p1.a = (ds_part_p1.b + 1)) AND ((SubPlan 2) > '0'::bigint)))
   ->  Hash Join
         Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c, non_part2.e, non_part2.f, ((ds_part_p1.a = (ds_part_p1.b + 1)) AND ((SubPlan 2) > '0'::bigint))
         Hash Cond: (ds_part_p1.c = non_part2.e)
         ->  Result
               Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c
               Filter: (SubPlan 1)
               ->  Append
                     Partition Selectors: $0
                     ->  Partial Seq Scan on orca.ds_part_p1
                           Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c
                           Filter: (ds_part_p1.a = ds_part_p1.b)
                     ->  Partial Seq Scan on orca.ds_part_deflt
                           Output: ds_part_deflt.a, ds_part_deflt.b, ds_part_deflt.c
                           Filter: (ds_part_deflt.a = ds_part_deflt.b)
               SubPlan 1
                 ->  Materialize
                       Output: non_part1.ctid
                       ->  PX Broadcast 1:6  (slice2)
                             Output: non_part1.ctid
                             ->  Limit
                                   Output: non_part1.ctid
                                   ->  PX Coordinator 6:1  (slice3; segments: 6)
                                         Output: non_part1.ctid
                                         ->  Limit
                                               Output: non_part1.ctid
                                               ->  Partial Seq Scan on orca.non_part1
                                                     Output: non_part1.ctid
         ->  Hash
               Output: non_part2.e, non_part2.f
               ->  Partition Selector (selector id: $0)
                     Output: non_part2.e, non_part2.f
                     ->  PX Broadcast 6:6  (slice4; segments: 6)
                           Output: non_part2.e, non_part2.f
                           ->  Partial Seq Scan on orca.non_part2
                                 Output: non_part2.e, non_part2.f
                                 Filter: (non_part2.f = 10)
         SubPlan 2
           ->  Materialize
                 Output: (count())
                 ->  PX Broadcast 1:6  (slice5)
                       Output: (count())
                       ->  Finalize Aggregate
                             Output: count()
                             ->  PX Coordinator 6:1  (slice6; segments: 6)
                                   Output: (PARTIAL count())
                                   ->  Partial Aggregate
                                         Output: PARTIAL count()
                                         ->  Partial Seq Scan on orca.non_part1 non_part1_1
 Optimizer: PolarDB PX Optimizer
(51 rows)

CREATE INDEX ds_idx ON ds_part(a);
analyze ds_part;
SELECT *, a IN ( SELECT b + 1 FROM non_part1) FROM ds_part, non_part2 WHERE ds_part.c = non_part2.e AND non_part2.f = 10 AND a IN ( SELECT b FROM non_part1);
 a  | b  | c  | e  | f  | ?column? 
----+----+----+----+----+----------
 10 | 10 | 10 | 10 | 10 | f
(1 row)

                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c, non_part2.e, non_part2.f, (((ds_part_p1.a = (ds_part_p1.b + 1)) AND ((SubPlan 2) > '0'::bigint)))
   ->  Hash Join
         Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c, non_part2.e, non_part2.f, ((ds_part_p1.a = (ds_part_p1.b + 1)) AND ((SubPlan 2) > '0'::bigint))
         Hash Cond: (ds_part_p1.c = non_part2.e)
         ->  Result
               Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c
               Filter: (SubPlan 1)
               ->  Append
                     Partition Selectors: $0
                     ->  Partial Seq Scan on orca.ds_part_p1
                           Output: ds_part_p1.a, ds_part_p1.b, ds_part_p1.c
                           Filter: (ds_part_p1.a = ds_part_p1.b)
                     ->  Partial Seq Scan on orca.ds_part_deflt
                           Output: ds_part_deflt.a, ds_part_deflt.b, ds_part_deflt.c
                           Filter: (ds_part_deflt.a = ds_part_deflt.b)
               SubPlan 1
                 ->  Materialize
                       Output: non_part1.ctid
                       ->  PX Broadcast 1:6  (slice2)
                             Output: non_part1.ctid
                             ->  Limit
                                   Output: non_part1.ctid
                                   ->  PX Coordinator 6:1  (slice3; segments: 6)
                                         Output: non_part1.ctid
                                         ->  Limit
                                               Output: non_part1.ctid
                                               ->  Partial Seq Scan on orca.non_part1
                                                     Output: non_part1.ctid
         ->  Hash
               Output: non_part2.e, non_part2.f
               ->  Partition Selector (selector id: $0)
                     Output: non_part2.e, non_part2.f
                     ->  PX Broadcast 6:6  (slice4; segments: 6)
                           Output: non_part2.e, non_part2.f
                           ->  Partial Seq Scan on orca.non_part2
                                 Output: non_part2.e, non_part2.f
                                 Filter: (non_part2.f = 10)
         SubPlan 2
           ->  Materialize
                 Output: (count())
                 ->  PX Broadcast 1:6  (slice5)
                       Output: (count())
                       ->  Finalize Aggregate
                             Output: count()
                             ->  PX Coordinator 6:1  (slice6; segments: 6)
                                   Output: (PARTIAL count())
                                   ->  Partial Aggregate
                                         Output: PARTIAL count()
                                         ->  Partial Seq Scan on orca.non_part1 non_part1_1
 Optimizer: PolarDB PX Optimizer
(51 rows)

REset polar_px_optimizer_enforce_subplans;
-- implied predicate must be generated for the type cast(ident) scalar array cmp const array
CREATE TABLE varchar_sc_array_cmp(a varchar);
INSERT INTO varchar_sc_array_cmp VALUES ('a'), ('b'), ('c'), ('d');
explain (costs off) select * FROM varchar_sc_array_cmp t1, varchar_sc_array_cmp t2 where t1.a = t2.a and t1.a in ('b', 'c');
                        QUERY PLAN                         
-----------------------------------------------------------
 Hash Join
   Hash Cond: ((t2.a)::text = (t1.a)::text)
   ->  Seq Scan on varchar_sc_array_cmp t2
   ->  Hash
         ->  Seq Scan on varchar_sc_array_cmp t1
               Filter: ((a)::text = ANY ('{b,c}'::text[]))
(6 rows)

SELECT * FROM varchar_sc_array_cmp t1, varchar_sc_array_cmp t2 where t1.a = t2.a and t1.a in ('b', 'c');
 a | a 
---+---
 b | b
 c | c
(2 rows)

                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: varchar_sc_array_cmp.a, varchar_sc_array_cmp_1.a
   ->  Hash Join
         Output: varchar_sc_array_cmp.a, varchar_sc_array_cmp_1.a
         Hash Cond: ((varchar_sc_array_cmp.a)::text = (varchar_sc_array_cmp_1.a)::text)
         ->  Partial Seq Scan on orca.varchar_sc_array_cmp
               Output: varchar_sc_array_cmp.a
               Filter: (((varchar_sc_array_cmp.a)::text = ANY ('{b,c}'::text[])) AND (varchar_sc_array_cmp.a = ANY ('{b,c}'::character varying[])))
         ->  Hash
               Output: varchar_sc_array_cmp_1.a
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: varchar_sc_array_cmp_1.a
                     ->  Partial Seq Scan on orca.varchar_sc_array_cmp varchar_sc_array_cmp_1
                           Output: varchar_sc_array_cmp_1.a
                           Filter: (varchar_sc_array_cmp_1.a = ANY ('{b,c}'::character varying[]))
 Optimizer: PolarDB PX Optimizer
(16 rows)

SET polar_px_optimizer_array_constraints=on;
explain (costs off) select * FROM varchar_sc_array_cmp t1, varchar_sc_array_cmp t2 where t1.a = t2.a and (t1.a in ('b', 'c') OR t1.a = 'a');
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((t2.a)::text = (t1.a)::text)
   ->  Seq Scan on varchar_sc_array_cmp t2
   ->  Hash
         ->  Seq Scan on varchar_sc_array_cmp t1
               Filter: (((a)::text = ANY ('{b,c}'::text[])) OR ((a)::text = 'a'::text))
(6 rows)

SELECT * FROM varchar_sc_array_cmp t1, varchar_sc_array_cmp t2 where t1.a = t2.a and (t1.a in ('b', 'c') OR t1.a = 'a');
 a | a 
---+---
 a | a
 b | b
 c | c
(3 rows)

                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: varchar_sc_array_cmp.a, varchar_sc_array_cmp_1.a
   ->  Hash Join
         Output: varchar_sc_array_cmp.a, varchar_sc_array_cmp_1.a
         Hash Cond: ((varchar_sc_array_cmp.a)::text = (varchar_sc_array_cmp_1.a)::text)
         ->  Partial Seq Scan on orca.varchar_sc_array_cmp
               Output: varchar_sc_array_cmp.a
               Filter: ((((varchar_sc_array_cmp.a)::text = ANY ('{b,c}'::text[])) OR ((varchar_sc_array_cmp.a)::text = 'a'::text)) AND (varchar_sc_array_cmp.a = ANY ('{a,b,c}'::character varying[])))
         ->  Hash
               Output: varchar_sc_array_cmp_1.a
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: varchar_sc_array_cmp_1.a
                     ->  Partial Seq Scan on orca.varchar_sc_array_cmp varchar_sc_array_cmp_1
                           Output: varchar_sc_array_cmp_1.a
                           Filter: (varchar_sc_array_cmp_1.a = ANY ('{a,b,c}'::character varying[]))
 Optimizer: PolarDB PX Optimizer
(16 rows)

DROP TABLE varchar_sc_array_cmp;
-- table constraints on nullable columns
-- start_ignore
DROP TABLE IF EXISTS tc0, tc1, tc2, tc3, tc4;
NOTICE:  table "tc0" does not exist, skipping
NOTICE:  table "tc1" does not exist, skipping
NOTICE:  table "tc2" does not exist, skipping
NOTICE:  table "tc3" does not exist, skipping
NOTICE:  table "tc4" does not exist, skipping
-- end_ignore
CREATE TABLE tc0 (a int check (a = 5));
INSERT INTO tc0 VALUES (NULL);
-- FIXME: Planner gives wrong result
SELECT * from tc0 where a IS NULL;
 a 
---
  
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.tc0
         Output: a
         Filter: (tc0.a IS NULL)
 Optimizer: PolarDB PX Optimizer
(6 rows)

CREATE TABLE tc1 (a int check (a between 1 and 2 or a != 3 and a > 5));
INSERT INTO tc1 VALUES (NULL);
SELECT * from tc1 where a IS NULL;
 a 
---
  
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.tc1
         Output: a
         Filter: (tc1.a IS NULL)
 Optimizer: PolarDB PX Optimizer
(6 rows)

CREATE TABLE tc2 (a int check (a in (1,2)));
INSERT INTO tc2 VALUES (NULL);
SELECT * from tc2 where a IS NULL;
 a 
---
  
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.tc2
         Output: a
         Filter: (tc2.a IS NULL)
 Optimizer: PolarDB PX Optimizer
(6 rows)

set polar_px_optimizer_array_constraints = on;
CREATE TABLE tc3 (a int check (a = ANY (ARRAY[1,2])));
INSERT INTO tc3 VALUES (NULL);
SELECT * from tc3 where a IS NULL;
 a 
---
  
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a
   ->  Partial Seq Scan on orca.tc3
         Output: a
         Filter: (tc3.a IS NULL)
 Optimizer: PolarDB PX Optimizer
(6 rows)

reset polar_px_optimizer_array_constraints;
CREATE TABLE tc4 (a int, b int, check(a + b > 1 and a = b));
INSERT INTO tc4 VALUES(NULL, NULL);
SELECT * from tc4 where a IS NULL;
 a | b 
---+---
   |  
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, b
   ->  Partial Seq Scan on orca.tc4
         Output: a, b
         Filter: (tc4.a IS NULL)
 Optimizer: PolarDB PX Optimizer
(6 rows)

CREATE EXTENSION IF NOT EXISTS citext;
drop table if exists tt, tc;
NOTICE:  table "tt" does not exist, skipping
NOTICE:  table "tc" does not exist, skipping
create table tc (a int, c citext) ;
create table tt (b int, v varchar) ;
insert into tc values (1, 'a'), (1, 'A');
insert into tt values (1, 'a'), (1, 'A');
insert into tc values (1, 'b'), (1, 'B');
insert into tt values (1, 'b'), (1, 'B');
select * from tc, tt where c = v;
 a | c | b | v 
---+---+---+---
 1 | a | 1 | a
 1 | A | 1 | A
 1 | b | 1 | b
 1 | B | 1 | B
(4 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tc.a, tc.c, tt.b, tt.v
   ->  Hash Join
         Output: tc.a, tc.c, tt.b, tt.v
         Hash Cond: ((tc.c)::text = (tt.v)::text)
         ->  Partial Seq Scan on orca.tc
               Output: tc.a, tc.c
         ->  Hash
               Output: tt.b, tt.v
               ->  PX Broadcast 6:6  (slice2; segments: 6)
                     Output: tt.b, tt.v
                     ->  Partial Seq Scan on orca.tt
                           Output: tt.b, tt.v
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- bitmap scan on bitmap index
create index tc_idx on tc using bitmap(c);
ERROR:  access method "bitmap" does not exist
select * from tc where c='a';
 a | c 
---+---
 1 | a
 1 | A
(2 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: a, c
   ->  Partial Seq Scan on orca.tc
         Output: a, c
         Filter: (tc.c = 'a'::citext)
 Optimizer: PolarDB PX Optimizer
(6 rows)

explain (costs off) select * from tc where c='a';
         QUERY PLAN          
-----------------------------
 Seq Scan on tc
   Filter: (c = 'a'::citext)
(2 rows)

-- test gpexpand phase 1
-- right now, these will fall back to planner
drop table if exists noexp_hash, gpexp_hash, gpexp_rand, gpexp_repl;
NOTICE:  table "noexp_hash" does not exist, skipping
NOTICE:  table "gpexp_hash" does not exist, skipping
NOTICE:  table "gpexp_rand" does not exist, skipping
NOTICE:  table "gpexp_repl" does not exist, skipping
create table noexp_hash(a int, b int) ;
insert into  noexp_hash select i, i from generate_series(1,50) i;
analyze noexp_hash;
-- three tables that will be expanded (simulated)
create table gpexp_hash(a int, b int) ;
create table gpexp_rand(a int, b int) ;
create table gpexp_repl(a int, b int) distributed replicated;
ERROR:  syntax error at or near "distributed"
LINE 1: create table gpexp_repl(a int, b int) distributed replicated...
                                              ^
-- simulate a cluster with one segment less than we have now
set allow_system_table_mods = true;
update gp_distribution_policy set numsegments = numsegments-1 where localoid = 'gpexp_hash'::regclass and numsegments > 1;
ERROR:  relation "gp_distribution_policy" does not exist
LINE 1: update gp_distribution_policy set numsegments = numsegments-...
               ^
update gp_distribution_policy set numsegments = numsegments-1 where localoid = 'gpexp_rand'::regclass and numsegments > 1;
ERROR:  relation "gp_distribution_policy" does not exist
LINE 1: update gp_distribution_policy set numsegments = numsegments-...
               ^
update gp_distribution_policy set numsegments = numsegments-1 where localoid = 'gpexp_repl'::regclass and numsegments > 1;
ERROR:  relation "gp_distribution_policy" does not exist
LINE 1: update gp_distribution_policy set numsegments = numsegments-...
               ^
reset allow_system_table_mods;
-- populate the tables on this smaller cluster
explain (costs off) insert into gpexp_hash select i, i from generate_series(1,50) i;
                QUERY PLAN                
------------------------------------------
 Insert on gpexp_hash
   ->  Function Scan on generate_series i
(2 rows)

insert into gpexp_hash select i, i from generate_series(1,50) i;
insert into gpexp_rand select i, i from generate_series(1,50) i;
insert into gpexp_repl select i, i from generate_series(1,50) i;
ERROR:  relation "gpexp_repl" does not exist
LINE 1: insert into gpexp_repl select i, i from generate_series(1,50...
                    ^
analyze gpexp_hash;
analyze gpexp_rand;
analyze gpexp_repl;
ERROR:  relation "gpexp_repl" does not exist
-- the segment ids in the unmodified table should have one extra number
select max(noexp_hash.gp_segment_id) - max(gpexp_hash.gp_segment_id) as expect_one
from noexp_hash, gpexp_hash;
ERROR:  column noexp_hash.gp_segment_id does not exist
LINE 1: select max(noexp_hash.gp_segment_id) - max(gpexp_hash.gp_seg...
                   ^
-- join should have a redistribute motion for gpexp_hash
explain (costs off) select count(*) from noexp_hash n join gpexp_hash x on n.a=x.a;
                 QUERY PLAN                 
--------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (n.a = x.a)
         ->  Seq Scan on noexp_hash n
         ->  Hash
               ->  Seq Scan on gpexp_hash x
(6 rows)

select count(*) from noexp_hash n join gpexp_hash x on n.a=x.a;
 count 
-------
    50
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Hash Join
                     Hash Cond: (noexp_hash.a = gpexp_hash.a)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: noexp_hash.a
                           Hash Key: noexp_hash.a
                           ->  Partial Seq Scan on orca.noexp_hash
                                 Output: noexp_hash.a
                     ->  Hash
                           Output: gpexp_hash.a
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: gpexp_hash.a
                                 Hash Key: gpexp_hash.a
                                 ->  Partial Seq Scan on orca.gpexp_hash
                                       Output: gpexp_hash.a
 Optimizer: PolarDB PX Optimizer
(21 rows)

delete from gpexp_hash where b between 21 and 50;
select count(*) from gpexp_hash;
 count 
-------
    20
(1 row)

                      QUERY PLAN                       
-------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on orca.gpexp_hash
 Optimizer: PolarDB PX Optimizer
(8 rows)

update gpexp_hash set b=-1 where b between 11 and 100;
select b, count(*) from gpexp_hash group by b order by b;
 b  | count 
----+-------
 -1 |    10
  1 |     1
  2 |     1
  3 |     1
  4 |     1
  5 |     1
  6 |     1
  7 |     1
  8 |     1
  9 |     1
 10 |     1
(11 rows)

                         QUERY PLAN                          
-------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: b, (count())
   Merge Key: b
   ->  GroupAggregate
         Output: b, count()
         Group Key: gpexp_hash.b
         ->  Sort
               Output: b
               Sort Key: gpexp_hash.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: b
                     Hash Key: b
                     ->  Partial Seq Scan on orca.gpexp_hash
                           Output: b
 Optimizer: PolarDB PX Optimizer
(15 rows)

explain (costs off) update gpexp_rand set b=(select b from gpexp_hash where gpexp_rand.a = gpexp_hash.a);
                 QUERY PLAN                 
--------------------------------------------
 Update on gpexp_rand
   ->  Seq Scan on gpexp_rand
         SubPlan 1
           ->  Seq Scan on gpexp_hash
                 Filter: (gpexp_rand.a = a)
(5 rows)

update gpexp_rand set b=(select b from gpexp_hash where gpexp_rand.a = gpexp_hash.a);
select b, count(*) from gpexp_rand group by b order by b;
 b  | count 
----+-------
 -1 |    10
  1 |     1
  2 |     1
  3 |     1
  4 |     1
  5 |     1
  6 |     1
  7 |     1
  8 |     1
  9 |     1
 10 |     1
    |    30
(12 rows)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: b, (count())
   Merge Key: b
   ->  Finalize GroupAggregate
         Output: b, count()
         Group Key: gpexp_rand.b
         ->  Sort
               Output: b, (PARTIAL count())
               Sort Key: gpexp_rand.b
               ->  PX Hash 6:6  (slice2; segments: 6)
                     Output: b, (PARTIAL count())
                     Hash Key: b
                     ->  Partial GroupAggregate
                           Output: b, PARTIAL count()
                           Group Key: gpexp_rand.b
                           ->  Sort
                                 Output: b
                                 Sort Key: gpexp_rand.b
                                 ->  Partial Seq Scan on orca.gpexp_rand
                                       Output: b
 Optimizer: PolarDB PX Optimizer
(21 rows)

delete from gpexp_repl where b >= 20;
ERROR:  relation "gpexp_repl" does not exist
LINE 1: delete from gpexp_repl where b >= 20;
                    ^
explain (costs off) insert into gpexp_repl values (20, 20);
ERROR:  relation "gpexp_repl" does not exist
LINE 1: explain (costs off) insert into gpexp_repl values (20, 20);
                                        ^
insert into gpexp_repl values (20, 20);
ERROR:  relation "gpexp_repl" does not exist
LINE 1: insert into gpexp_repl values (20, 20);
                    ^
explain (costs off) select count(*) from gpexp_hash h join gpexp_repl r on h.a=r.a;
ERROR:  relation "gpexp_repl" does not exist
LINE 1: ...costs off) select count(*) from gpexp_hash h join gpexp_repl...
                                                             ^
select count(*) as expect_20 from gpexp_hash h join gpexp_repl r on h.a=r.a;
ERROR:  relation "gpexp_repl" does not exist
LINE 1: ...lect count(*) as expect_20 from gpexp_hash h join gpexp_repl...
                                                             ^
explain (costs off) select count(*) as expect_20 from noexp_hash h join gpexp_repl r on h.a=r.a;
ERROR:  relation "gpexp_repl" does not exist
LINE 1: ...lect count(*) as expect_20 from noexp_hash h join gpexp_repl...
                                                             ^
select count(*) as expect_20 from noexp_hash h join gpexp_repl r on h.a=r.a;
ERROR:  relation "gpexp_repl" does not exist
LINE 1: ...lect count(*) as expect_20 from noexp_hash h join gpexp_repl...
                                                             ^
create table part1(a int, b int) partition by range(b);
ERROR:  relation "part1" already exists
create table part2(a int, b int) partition by range(b);
ERROR:  relation "part2" already exists
CREATE TABLE part1_p1 PARTITION of part1 for values from (1) to (2);
ERROR:  "part1" is not partitioned
CREATE TABLE part1_p2 PARTITION of part1 for values from (2) to (3);
ERROR:  "part1" is not partitioned
CREATE TABLE part1_p3 PARTITION of part1 for values from (3) to (4);
ERROR:  "part1" is not partitioned
CREATE TABLE part1_p4 PARTITION of part1 for values from (4) to (5);
ERROR:  "part1" is not partitioned
CREATE TABLE part2_p1 PARTITION of part2 for values from (1) to (2);
ERROR:  "part2" is not partitioned
CREATE TABLE part2_p2 PARTITION of part2 for values from (2) to (3);
ERROR:  "part2" is not partitioned
CREATE TABLE part2_p3 PARTITION of part2 for values from (3) to (4);
ERROR:  "part2" is not partitioned
CREATE TABLE part2_p4 PARTITION of part2 for values from (4) to (5);
ERROR:  "part2" is not partitioned
insert into part1 select i, (i % 2) + 1 from generate_series(1, 1000) i;
ERROR:  new row for relation "part1" violates partition constraint
DETAIL:  Failing row contains (1, 2, null).
insert into part2 select i, (i % 2) + 1 from generate_series(1, 100) i;
ERROR:  new row for relation "part2" violates partition constraint
DETAIL:  Failing row contains (2, 1, null).
-- make sure some child partitions have not been analyzed. This just means that
-- stats are missing for some child partition but not necessarily that the relation
-- is empty. So we should not flag this as an empty relation 
analyze part1_1_prt_1;
ERROR:  relation "part1_1_prt_1" does not exist
analyze part1_1_prt_2;
ERROR:  relation "part1_1_prt_2" does not exist
analyze part2_1_prt_1;
ERROR:  relation "part2_1_prt_1" does not exist
analyze part2_1_prt_2;
ERROR:  relation "part2_1_prt_2" does not exist
-- the plan should contain a 2 stage limit. If we incorrectly estimate that the
-- relation is empty, we would end up choosing a single stage limit. 
explain (costs off) select * from part1, part2 where part1.b = part2.b limit 5;
ERROR:  column part1.b does not exist
LINE 1: ...lain (costs off) select * from part1, part2 where part1.b = ...
                                                             ^
-- test opfamily handling in ORCA
-- start_ignore
DROP FUNCTION abseq(int, int) CASCADE;
ERROR:  function abseq(integer, integer) does not exist
DROP FUNCTION abslt(int, int) CASCADE;
ERROR:  function abslt(integer, integer) does not exist
DROP FUNCTION absgt(int, int) CASCADE;
ERROR:  function absgt(integer, integer) does not exist
DROP FUNCTION abscmp(int, int) CASCADE;
ERROR:  function abscmp(integer, integer) does not exist
-- end_ignore
CREATE FUNCTION abseq(int, int) RETURNS BOOL AS
$$
  begin return abs($1) = abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE OPERATOR |=| (
  PROCEDURE = abseq,
  LEFTARG = int,
  RIGHTARG = int,
  COMMUTATOR = |=|,
  hashes, merges);
CREATE FUNCTION abshashfunc(int) RETURNS int AS
$$
  begin return hashint4(abs($1)); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE FUNCTION abslt(int, int) RETURNS BOOL AS
$$
  begin return abs($1) < abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE OPERATOR |<| (
  PROCEDURE = abslt,
  LEFTARG = int,
  RIGHTARG = int);
CREATE FUNCTION absgt(int, int) RETURNS BOOL AS
$$
  begin return abs($1) > abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE OPERATOR |>| (
  PROCEDURE = absgt,
  LEFTARG = int,
  RIGHTARG = int);
CREATE FUNCTION abscmp(int, int) RETURNS int AS
$$
  begin return btint4cmp(abs($1),abs($2)); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
DROP TABLE IF EXISTS atab_old_hash;
NOTICE:  table "atab_old_hash" does not exist, skipping
DROP TABLE IF EXISTS btab_old_hash;
NOTICE:  table "btab_old_hash" does not exist, skipping
CREATE TABLE atab_old_hash (a int) ;
CREATE TABLE btab_old_hash (b int) ;
INSERT INTO atab_old_hash VALUES (-1), (0), (1);
INSERT INTO btab_old_hash VALUES (-1), (0), (1), (2);
ANALYZE atab_old_hash;
ANALYZE btab_old_hash;
-- Test simple join using the new operator(s) before creating the opclass/opfamily
explain (costs off) select a, b FROM atab_old_hash INNER JOIN btab_old_hash ON a |=| b;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Hash Cond: (atab_old_hash.a |=| btab_old_hash.b)
   ->  Seq Scan on atab_old_hash
   ->  Hash
         ->  Seq Scan on btab_old_hash
(5 rows)

--SELECT a, b FROM atab_old_hash INNER JOIN btab_old_hash ON a |=| b;
CREATE OPERATOR CLASS abs_int_hash_ops FOR TYPE int4
  USING hash AS
  OPERATOR 1 |=|,
  FUNCTION 1 abshashfunc(int);
CREATE OPERATOR CLASS abs_int_btree_ops FOR TYPE int4
  USING btree AS
  OPERATOR 1 |<|,
  OPERATOR 3 |=|,
  OPERATOR 5 |>|,
  FUNCTION 1 abscmp(int, int);
-- OK test different kinds of joins
explain (costs off) select a, b FROM atab_old_hash INNER JOIN btab_old_hash ON a |=| b;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Hash Cond: (atab_old_hash.a |=| btab_old_hash.b)
   ->  Seq Scan on atab_old_hash
   ->  Hash
         ->  Seq Scan on btab_old_hash
(5 rows)

SELECT a, b FROM atab_old_hash INNER JOIN btab_old_hash ON a |=| b;
 a  | b  
----+----
 -1 |  1
 -1 | -1
  0 |  0
  1 |  1
  1 | -1
(5 rows)

                           QUERY PLAN                           
----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: atab_old_hash.a, btab_old_hash.b
   ->  Hash Join
         Output: atab_old_hash.a, btab_old_hash.b
         Hash Cond: (atab_old_hash.a |=| btab_old_hash.b)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: atab_old_hash.a
               Hash Key: atab_old_hash.a
               ->  Partial Seq Scan on orca.atab_old_hash
                     Output: atab_old_hash.a
         ->  Hash
               Output: btab_old_hash.b
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: btab_old_hash.b
                     Hash Key: btab_old_hash.b
                     ->  Partial Seq Scan on orca.btab_old_hash
                           Output: btab_old_hash.b
 Optimizer: PolarDB PX Optimizer
(18 rows)

explain (costs off) select a, b FROM btab_old_hash LEFT OUTER JOIN atab_old_hash ON a |=| b;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Right Join
   Hash Cond: (atab_old_hash.a |=| btab_old_hash.b)
   ->  Seq Scan on atab_old_hash
   ->  Hash
         ->  Seq Scan on btab_old_hash
(5 rows)

SELECT a, b FROM btab_old_hash LEFT OUTER JOIN atab_old_hash ON a |=| b;
 a  | b  
----+----
 -1 |  1
 -1 | -1
  0 |  0
  1 |  1
  1 | -1
    |  2
(6 rows)

                           QUERY PLAN                           
----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: atab_old_hash.a, btab_old_hash.b
   ->  Hash Left Join
         Output: atab_old_hash.a, btab_old_hash.b
         Hash Cond: (btab_old_hash.b |=| atab_old_hash.a)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: btab_old_hash.b
               Hash Key: btab_old_hash.b
               ->  Partial Seq Scan on orca.btab_old_hash
                     Output: btab_old_hash.b
         ->  Hash
               Output: atab_old_hash.a
               ->  PX Hash 6:6  (slice3; segments: 6)
                     Output: atab_old_hash.a
                     Hash Key: atab_old_hash.a
                     ->  Partial Seq Scan on orca.atab_old_hash
                           Output: atab_old_hash.a
 Optimizer: PolarDB PX Optimizer
(18 rows)

SET polar_px_optimizer_expand_fulljoin = on;
explain (costs off) select a, b FROM atab_old_hash FULL JOIN btab_old_hash ON a |=| b;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Full Join
   Hash Cond: (atab_old_hash.a |=| btab_old_hash.b)
   ->  Seq Scan on atab_old_hash
   ->  Hash
         ->  Seq Scan on btab_old_hash
(5 rows)

SELECT a, b FROM atab_old_hash FULL JOIN btab_old_hash ON a |=| b;
 a  | b  
----+----
 -1 |  1
 -1 | -1
  0 |  0
  1 |  1
  1 | -1
    |  2
(6 rows)

                                                                                                                 QUERY PLAN                                                                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: share0_ref2.a, share1_ref2.b
   ->  Sequence
         Output: share0_ref2.a, share1_ref2.b
         ->  Shared Scan (Producer; slice1; share0)
               Output: share0_ref1.a, share0_ref1.ctid, share0_ref1.xmin, share0_ref1.cmin, share0_ref1.xmax, share0_ref1.cmax, share0_ref1.tableoid, share0_ref1._px_worker_id, share0_ref1._root_ctid
               ->  Partial Seq Scan on orca.atab_old_hash
                     Output: atab_old_hash.a, atab_old_hash.ctid, atab_old_hash.xmin, atab_old_hash.cmin, atab_old_hash.xmax, atab_old_hash.cmax, atab_old_hash.tableoid, atab_old_hash._px_worker_id, atab_old_hash._root_ctid
         ->  Sequence
               Output: share0_ref2.a, share1_ref2.b
               ->  Shared Scan (Producer; slice1; share1)
                     Output: share1_ref1.b, share1_ref1.ctid, share1_ref1.xmin, share1_ref1.cmin, share1_ref1.xmax, share1_ref1.cmax, share1_ref1.tableoid, share1_ref1._px_worker_id, share1_ref1._root_ctid
                     ->  Partial Seq Scan on orca.btab_old_hash
                           Output: btab_old_hash.b, btab_old_hash.ctid, btab_old_hash.xmin, btab_old_hash.cmin, btab_old_hash.xmax, btab_old_hash.cmax, btab_old_hash.tableoid, btab_old_hash._px_worker_id, btab_old_hash._root_ctid
               ->  Append
                     ->  Hash Left Join
                           Output: share0_ref2.a, share1_ref2.b
                           Hash Cond: (share0_ref2.a |=| share1_ref2.b)
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: share0_ref2.a
                                 Hash Key: share0_ref2.a
                                 ->  Result
                                       Output: share0_ref2.a
                                       ->  Shared Scan (Consumer; slice2; share0)
                                             Output: share0_ref2.a, share0_ref2.ctid, share0_ref2.xmin, share0_ref2.cmin, share0_ref2.xmax, share0_ref2.cmax, share0_ref2.tableoid, share0_ref2._px_worker_id, share0_ref2._root_ctid
                           ->  Hash
                                 Output: share1_ref2.b
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: share1_ref2.b
                                       Hash Key: share1_ref2.b
                                       ->  Result
                                             Output: share1_ref2.b
                                             ->  Shared Scan (Consumer; slice3; share1)
                                                   Output: share1_ref2.b, share1_ref2.ctid, share1_ref2.xmin, share1_ref2.cmin, share1_ref2.xmax, share1_ref2.cmax, share1_ref2.tableoid, share1_ref2._px_worker_id, share1_ref2._root_ctid
                     ->  Hash Anti Join
                           Output: NULL::integer, share1_ref3.b
                           Hash Cond: (share1_ref3.b |=| share0_ref3.a)
                           ->  PX Hash 6:6  (slice4; segments: 6)
                                 Output: share1_ref3.b
                                 Hash Key: share1_ref3.b
                                 ->  Result
                                       Output: share1_ref3.b
                                       ->  Shared Scan (Consumer; slice4; share1)
                                             Output: share1_ref3.b, share1_ref3.ctid, share1_ref3.xmin, share1_ref3.cmin, share1_ref3.xmax, share1_ref3.cmax, share1_ref3.tableoid, share1_ref3._px_worker_id, share1_ref3._root_ctid
                           ->  Hash
                                 Output: share0_ref3.a
                                 ->  PX Hash 6:6  (slice5; segments: 6)
                                       Output: share0_ref3.a
                                       Hash Key: share0_ref3.a
                                       ->  Result
                                             Output: share0_ref3.a
                                             ->  Shared Scan (Consumer; slice5; share0)
                                                   Output: share0_ref3.a, share0_ref3.ctid, share0_ref3.xmin, share0_ref3.cmin, share0_ref3.xmax, share0_ref3.cmax, share0_ref3.tableoid, share0_ref3._px_worker_id, share0_ref3._root_ctid
 Optimizer: PolarDB PX Optimizer
(54 rows)

reset polar_px_optimizer_expand_fulljoin;
-- Test rescanned materialize that is not directly above a motion
DROP TABLE IF EXISTS foo1 CASCADE;
NOTICE:  table "foo1" does not exist, skipping
DROP TABLE IF EXISTS foo2 CASCADE;
NOTICE:  table "foo2" does not exist, skipping
DROP TABLE IF EXISTS foo3 CASCADE;
NOTICE:  table "foo3" does not exist, skipping
CREATE table foo1(a int);
CREATE table foo2(a int, b int, c int);
CREATE table foo3(a int, b int);
CREATE index f2c on foo2 using bitmap(c);
ERROR:  access method "bitmap" does not exist
INSERT INTO foo1 values (1), (2);
INSERT INTO foo2 values (1,1,1), (2,2,2);
INSERT INTO foo3 values (1,1), (2,2);
ANALYZE foo1;
ANALYZE foo2;
ANALYZE foo3;
set polar_px_optimizer_join_order=query;
-- we ignore enable/disable_xform statements as their output will differ if the server is compiled without Orca (the xform won't exist)
-- start_ignore
select disable_xform('CXformInnerJoin2HashJoin');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformInnerJoin2HashJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
explain (costs off) select 1 FROM foo1, foo2 WHERE foo1.a = foo2.a AND foo2.c = 3 AND foo2.b IN (SELECT b FROM foo3);
               QUERY PLAN               
----------------------------------------
 Nested Loop Semi Join
   Join Filter: (foo2.b = foo3.b)
   ->  Nested Loop
         Join Filter: (foo1.a = foo2.a)
         ->  Seq Scan on foo2
               Filter: (c = 3)
         ->  Seq Scan on foo1
   ->  Seq Scan on foo3
(8 rows)

SELECT 1 FROM foo1, foo2 WHERE foo1.a = foo2.a AND foo2.c = 3 AND foo2.b IN (SELECT b FROM foo3);
 ?column? 
----------
(0 rows)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Result
   Output: 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Hash Join
               Hash Cond: (foo1.a = foo2.a)
               ->  Partial Seq Scan on orca.foo1
                     Output: foo1.a
               ->  Hash
                     Output: foo2.a
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: foo2.a
                           ->  Hash Semi Join
                                 Output: foo2.a
                                 Hash Cond: (foo2.b = foo3.b)
                                 ->  Partial Seq Scan on orca.foo2
                                       Output: foo2.a, foo2.b
                                       Filter: (foo2.c = 3)
                                 ->  Hash
                                       Output: foo3.b
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             Output: foo3.b
                                             ->  Partial Seq Scan on orca.foo3
                                                   Output: foo3.b
 Optimizer: PolarDB PX Optimizer
(24 rows)

reset polar_px_optimizer_join_order;
-- start_ignore
select enable_xform('CXformInnerJoin2HashJoin');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformInnerJoin2HashJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
-- Test that duplicate sensitive redistributes don't have invalid projection (eg: element that can't be hashed)
drop table if exists t55;
NOTICE:  table "t55" does not exist, skipping
drop table if exists tp;
NOTICE:  table "tp" does not exist, skipping
create table t55 (c int, lid int);
insert into t55 select i, i from generate_series(1, 1000) i;
analyze t55;
set polar_px_optimizer_join_order = query;
-- force_explain
explain verbose
CREATE TABLE TP AS
WITH META AS (SELECT '2020-01-01' AS VALID_DT, '99' AS LOAD_ID)
SELECT DISTINCT L1.c, L1.lid
FROM t55 L1 CROSS JOIN META
WHERE L1.lid = int4in(textout(meta.load_id));
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Unique  (cost=21.31..21.32 rows=1 width=8)
   Output: l1.c, l1.lid
   CTE meta
     ->  Result  (cost=0.00..0.01 rows=1 width=64)
           Output: '2020-01-01'::text, '99'::text
   ->  Sort  (cost=21.30..21.31 rows=1 width=8)
         Output: l1.c, l1.lid
         Sort Key: l1.c, l1.lid
         ->  Hash Join  (cost=0.03..21.29 rows=1 width=8)
               Output: l1.c, l1.lid
               Hash Cond: (l1.lid = int4in(textout(meta.load_id)))
               ->  Seq Scan on orca.t55 l1  (cost=0.00..15.00 rows=1000 width=8)
                     Output: l1.c, l1.lid
               ->  Hash  (cost=0.02..0.02 rows=1 width=32)
                     Output: meta.load_id
                     ->  CTE Scan on meta  (cost=0.00..0.02 rows=1 width=32)
                           Output: meta.load_id
(17 rows)

CREATE TABLE TP AS
WITH META AS (SELECT '2020-01-01' AS VALID_DT, '99' AS LOAD_ID)
SELECT DISTINCT L1.c, L1.lid
FROM t55 L1 CROSS JOIN META
WHERE L1.lid = int4in(textout(meta.load_id));
reset polar_px_optimizer_join_order;
SELECT * from tp;
 c  | lid 
----+-----
 99 |  99
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c, lid
   ->  Partial Seq Scan on orca.tp
         Output: c, lid
 Optimizer: PolarDB PX Optimizer
(5 rows)

-- Test partition selection for lossy casts
create table lossycastrangepart(a float, b float) partition by range(b);
CREATE TABLE lossycastrangepart_p1 PARTITION of lossycastrangepart for values from (0) to (10);
CREATE TABLE lossycastrangepart_p2 PARTITION of lossycastrangepart for values from (10) to (20);
CREATE TABLE lossycastrangepart_p3 PARTITION of lossycastrangepart for values from (20) to (30);
CREATE TABLE lossycastrangepart_p4 PARTITION of lossycastrangepart for values from (30) to (40);
insert into lossycastrangepart (values (5.1,5.1), (9.9,9.9), (10.1,10.1), (9.1,9.1), (10.9,10.9), (11.1,11.1), (21.0,21.0)); 
explain (costs off) select * from lossycastrangepart where b::int = 10;
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on lossycastrangepart_p1
         Filter: ((b)::integer = 10)
   ->  Seq Scan on lossycastrangepart_p2
         Filter: ((b)::integer = 10)
   ->  Seq Scan on lossycastrangepart_p3
         Filter: ((b)::integer = 10)
   ->  Seq Scan on lossycastrangepart_p4
         Filter: ((b)::integer = 10)
(9 rows)

select * from lossycastrangepart where b::int = 10;
  a   |  b   
------+------
  9.9 |  9.9
 10.1 | 10.1
(2 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
   ->  Append
         ->  Partial Seq Scan on orca.lossycastrangepart_p1
               Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
               Filter: (int4(lossycastrangepart_p1.b) = 10)
         ->  Partial Seq Scan on orca.lossycastrangepart_p2
               Output: lossycastrangepart_p2.a, lossycastrangepart_p2.b
               Filter: (int4(lossycastrangepart_p2.b) = 10)
         ->  Partial Seq Scan on orca.lossycastrangepart_p3
               Output: lossycastrangepart_p3.a, lossycastrangepart_p3.b
               Filter: (int4(lossycastrangepart_p3.b) = 10)
         ->  Partial Seq Scan on orca.lossycastrangepart_p4
               Output: lossycastrangepart_p4.a, lossycastrangepart_p4.b
               Filter: (int4(lossycastrangepart_p4.b) = 10)
 Optimizer: PolarDB PX Optimizer
(16 rows)

explain (costs off) select * from lossycastrangepart where b::int = 11;
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on lossycastrangepart_p1
         Filter: ((b)::integer = 11)
   ->  Seq Scan on lossycastrangepart_p2
         Filter: ((b)::integer = 11)
   ->  Seq Scan on lossycastrangepart_p3
         Filter: ((b)::integer = 11)
   ->  Seq Scan on lossycastrangepart_p4
         Filter: ((b)::integer = 11)
(9 rows)

select * from lossycastrangepart where b::int = 11;
  a   |  b   
------+------
 10.9 | 10.9
 11.1 | 11.1
(2 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
   ->  Append
         ->  Partial Seq Scan on orca.lossycastrangepart_p1
               Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
               Filter: (int4(lossycastrangepart_p1.b) = 11)
         ->  Partial Seq Scan on orca.lossycastrangepart_p2
               Output: lossycastrangepart_p2.a, lossycastrangepart_p2.b
               Filter: (int4(lossycastrangepart_p2.b) = 11)
         ->  Partial Seq Scan on orca.lossycastrangepart_p3
               Output: lossycastrangepart_p3.a, lossycastrangepart_p3.b
               Filter: (int4(lossycastrangepart_p3.b) = 11)
         ->  Partial Seq Scan on orca.lossycastrangepart_p4
               Output: lossycastrangepart_p4.a, lossycastrangepart_p4.b
               Filter: (int4(lossycastrangepart_p4.b) = 11)
 Optimizer: PolarDB PX Optimizer
(16 rows)

explain (costs off) select * from lossycastrangepart where b::int < 10;
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on lossycastrangepart_p1
         Filter: ((b)::integer < 10)
   ->  Seq Scan on lossycastrangepart_p2
         Filter: ((b)::integer < 10)
   ->  Seq Scan on lossycastrangepart_p3
         Filter: ((b)::integer < 10)
   ->  Seq Scan on lossycastrangepart_p4
         Filter: ((b)::integer < 10)
(9 rows)

select * from lossycastrangepart where b::int < 10;
  a  |  b  
-----+-----
 5.1 | 5.1
 9.1 | 9.1
(2 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
   ->  Append
         ->  Partial Seq Scan on orca.lossycastrangepart_p1
               Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
               Filter: (int4(lossycastrangepart_p1.b) < 10)
         ->  Partial Seq Scan on orca.lossycastrangepart_p2
               Output: lossycastrangepart_p2.a, lossycastrangepart_p2.b
               Filter: (int4(lossycastrangepart_p2.b) < 10)
         ->  Partial Seq Scan on orca.lossycastrangepart_p3
               Output: lossycastrangepart_p3.a, lossycastrangepart_p3.b
               Filter: (int4(lossycastrangepart_p3.b) < 10)
         ->  Partial Seq Scan on orca.lossycastrangepart_p4
               Output: lossycastrangepart_p4.a, lossycastrangepart_p4.b
               Filter: (int4(lossycastrangepart_p4.b) < 10)
 Optimizer: PolarDB PX Optimizer
(16 rows)

explain (costs off) select * from lossycastrangepart where b::int < 11;
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on lossycastrangepart_p1
         Filter: ((b)::integer < 11)
   ->  Seq Scan on lossycastrangepart_p2
         Filter: ((b)::integer < 11)
   ->  Seq Scan on lossycastrangepart_p3
         Filter: ((b)::integer < 11)
   ->  Seq Scan on lossycastrangepart_p4
         Filter: ((b)::integer < 11)
(9 rows)

select * from lossycastrangepart where b::int < 11;
  a   |  b   
------+------
  5.1 |  5.1
  9.9 |  9.9
  9.1 |  9.1
 10.1 | 10.1
(4 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
   ->  Append
         ->  Partial Seq Scan on orca.lossycastrangepart_p1
               Output: lossycastrangepart_p1.a, lossycastrangepart_p1.b
               Filter: (int4(lossycastrangepart_p1.b) < 11)
         ->  Partial Seq Scan on orca.lossycastrangepart_p2
               Output: lossycastrangepart_p2.a, lossycastrangepart_p2.b
               Filter: (int4(lossycastrangepart_p2.b) < 11)
         ->  Partial Seq Scan on orca.lossycastrangepart_p3
               Output: lossycastrangepart_p3.a, lossycastrangepart_p3.b
               Filter: (int4(lossycastrangepart_p3.b) < 11)
         ->  Partial Seq Scan on orca.lossycastrangepart_p4
               Output: lossycastrangepart_p4.a, lossycastrangepart_p4.b
               Filter: (int4(lossycastrangepart_p4.b) < 11)
 Optimizer: PolarDB PX Optimizer
(16 rows)

create table lossycastlistpart( a int, b float) partition by list(b);
 (partition l1 values(1.7, 2.1), partition l2 values(1.3, 2.7), partition l3 values(1.8, 2.8));
ERROR:  syntax error at or near "partition"
LINE 1: (partition l1 values(1.7, 2.1), partition l2 values(1.3, 2.7...
         ^
CREATE TABLE l1 PARTITION OF lossycastlistpart FOR VALUES IN (1.7, 2.1);
CREATE TABLE l2 PARTITION OF lossycastlistpart FOR VALUES IN (1.3, 2.7);
CREATE TABLE l3 PARTITION OF lossycastlistpart FOR VALUES IN (1.8, 2.8);
insert into lossycastlistpart (values (1.0,2.1), (1.0,1.3), (10.1,2.1), (9.1,2.7), (10.9,1.8), (11.1,2.8), (21.0,1.7));
explain (costs off) select * from lossycastlistpart where b::int < 2;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on l2
         Filter: ((b)::integer < 2)
   ->  Seq Scan on l1
         Filter: ((b)::integer < 2)
   ->  Seq Scan on l3
         Filter: ((b)::integer < 2)
(7 rows)

select * from lossycastlistpart where b::int < 2;
 a |  b  
---+-----
 1 | 1.3
(1 row)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: l2.a, l2.b
   ->  Append
         ->  Partial Seq Scan on orca.l2
               Output: l2.a, l2.b
               Filter: (int4(l2.b) < 2)
         ->  Partial Seq Scan on orca.l1
               Output: l1.a, l1.b
               Filter: (int4(l1.b) < 2)
         ->  Partial Seq Scan on orca.l3
               Output: l3.a, l3.b
               Filter: (int4(l3.b) < 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

explain (costs off) select * from lossycastlistpart where b::int = 2;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on l2
         Filter: ((b)::integer = 2)
   ->  Seq Scan on l1
         Filter: ((b)::integer = 2)
   ->  Seq Scan on l3
         Filter: ((b)::integer = 2)
(7 rows)

select * from lossycastlistpart where b::int = 2;
 a  |  b  
----+-----
  1 | 2.1
 10 | 2.1
 21 | 1.7
 11 | 1.8
(4 rows)

                QUERY PLAN                 
-------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: l2.a, l2.b
   ->  Append
         ->  Partial Seq Scan on orca.l2
               Output: l2.a, l2.b
               Filter: (int4(l2.b) = 2)
         ->  Partial Seq Scan on orca.l1
               Output: l1.a, l1.b
               Filter: (int4(l1.b) = 2)
         ->  Partial Seq Scan on orca.l3
               Output: l3.a, l3.b
               Filter: (int4(l3.b) = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

--Test lossy casted NEQ on range partitioned table
drop table if exists sales;
create table sales(id int, prod_id int, cust_id int, sales_ts timestamp)
partition by range(sales_ts);
CREATE TABLE sales_p1 PARTITION of sales for values from (timestamp '2010-01-01 00:00:00') to (timestamp '2010-01-05 00:00:00');
ERROR:  syntax error at or near "timestamp"
LINE 1: ...ABLE sales_p1 PARTITION of sales for values from (timestamp ...
                                                             ^
CREATE TABLE sales_p2 PARTITION of sales for values from (timestamp '2010-01-05 00:00:00') to (timestamp '2010-01-10 00:00:00');
ERROR:  syntax error at or near "timestamp"
LINE 1: ...ABLE sales_p2 PARTITION of sales for values from (timestamp ...
                                                             ^
CREATE TABLE sales_p3 PARTITION of sales for values from (timestamp '2010-01-10 00:00:00') to (timestamp '2010-01-15 00:00:00');
ERROR:  syntax error at or near "timestamp"
LINE 1: ...ABLE sales_p3 PARTITION of sales for values from (timestamp ...
                                                             ^
CREATE TABLE sales_p4 PARTITION of sales for values from (timestamp '2010-01-15 00:00:00') to (timestamp '2010-01-20 00:00:00');
ERROR:  syntax error at or near "timestamp"
LINE 1: ...ABLE sales_p4 PARTITION of sales for values from (timestamp ...
                                                             ^
CREATE TABLE sales_p5 PARTITION of sales for values from (timestamp '2010-01-20 00:00:00') to (timestamp '2010-01-25 00:00:00');
ERROR:  syntax error at or near "timestamp"
LINE 1: ...ABLE sales_p5 PARTITION of sales for values from (timestamp ...
                                                             ^
CREATE TABLE sales_p6 PARTITION of sales for values from (timestamp '2010-01-25 00:00:00') to (timestamp '2010-02-02 23:59:59');
ERROR:  syntax error at or near "timestamp"
LINE 1: ...ABLE sales_p6 PARTITION of sales for values from (timestamp ...
                                                             ^
insert into sales select i, i%100, i%1000, timestamp '2010-01-01 00:00:00' + i * interval '1 day' from generate_series(1,20) i;
ERROR:  no partition of relation "sales" found for row
DETAIL:  Partition key of the failing row contains (sales_ts) = (Sat Jan 02 00:00:00 2010).
select * from sales where sales_ts::date != '2010-01-05' order by sales_ts;
 id | prod_id | cust_id | sales_ts 
----+---------+---------+----------
(0 rows)

-- validate lossy cast logic can handle BCCs
drop table if exists part_tbl_varchar;
NOTICE:  table "part_tbl_varchar" does not exist, skipping
CREATE TABLE part_tbl_varchar(a varchar(15) NOT NULL, b varchar(8) NOT NULL)
PARTITION BY RANGE(b);
CREATE TABLE part_tbl_varchar_p1 PARTITION of part_tbl_varchar for values from ('v1') to ('v5');
CREATE TABLE part_tbl_varchar_p2 PARTITION of part_tbl_varchar for values from ('v5') to ('v9');
CREATE TABLE part_tbl_varchar_deflt PARTITION of part_tbl_varchar default;
insert into part_tbl_varchar values ('v3','v3'), ('v5','v5');
select * from part_tbl_varchar where b between 'v3' and 'v4';
 a  | b  
----+----
 v3 | v3
(1 row)

                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: part_tbl_varchar_p1.a, part_tbl_varchar_p1.b
   ->  Append
         ->  Partial Seq Scan on orca.part_tbl_varchar_p1
               Output: part_tbl_varchar_p1.a, part_tbl_varchar_p1.b
               Filter: (((part_tbl_varchar_p1.b)::text >= 'v3'::text) AND ((part_tbl_varchar_p1.b)::text <= 'v4'::text))
 Optimizer: PolarDB PX Optimizer
(7 rows)

-- test n-ary inner and left joins with outer references
drop table if exists tcorr1, tcorr2;
NOTICE:  table "tcorr1" does not exist, skipping
NOTICE:  table "tcorr2" does not exist, skipping
create table tcorr1(a int, b int);
create table tcorr2(a int, b int);
insert into tcorr1 values (1,99);
insert into tcorr2 values (1,1);
analyze tcorr1;
analyze tcorr2;
set polar_px_optimizer_trace_fallback to on;
explain (costs off) selectn selectcorr1 out
where out.b in (select coalesce(tcorr2.a, 99)
                from tcorr1 left outer join tcorr2 on tcorr1.a=tcorr2.a+out.a);
ERROR:  syntax error at or near "selectn"
LINE 1: explain (costs off) selectn selectcorr1 out
                            ^
-- expect 1 row
select *
from tcorr1 out
where out.b in (select coalesce(tcorr2.a, 99)
                from tcorr1 left outer join tcorr2 on tcorr1.a=tcorr2.a+out.a);
 a | b  
---+----
 1 | 99
(1 row)

                             QUERY PLAN                             
--------------------------------------------------------------------
 Result
   Output: tcorr1.a, tcorr1.b
   Filter: (SubPlan 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: tcorr1.a, tcorr1.b
         ->  Partial Seq Scan on orca.tcorr1
               Output: tcorr1.a, tcorr1.b
   SubPlan 1
     ->  Nested Loop Left Join
           Output: COALESCE(tcorr2.a, 99)
           Join Filter: (tcorr1_1.a = (tcorr2.a + tcorr1.a))
           ->  Materialize
                 Output: tcorr1_1.a
                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                       Output: tcorr1_1.a
                       ->  Partial Seq Scan on orca.tcorr1 tcorr1_1
                             Output: tcorr1_1.a
           ->  Materialize
                 Output: tcorr2.a
                 ->  PX Coordinator 6:1  (slice2; segments: 6)
                       Output: tcorr2.a
                       ->  Partial Seq Scan on orca.tcorr2
                             Output: tcorr2.a
 Optimizer: PolarDB PX Optimizer
(24 rows)

explain (costs off) select *
from tcorr1 out
where out.b in (select max(tcorr2.b + out.b - 1)
                from tcorr2
                where tcorr2.a=out.a);
              QUERY PLAN               
---------------------------------------
 Seq Scan on tcorr1 "out"
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Aggregate
           ->  Seq Scan on tcorr2
                 Filter: (a = "out".a)
(6 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select max(tcorr2.b + out.b - 1)
                from tcorr2
                where tcorr2.a=out.a);
 a | b  
---+----
 1 | 99
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tcorr1.a, tcorr1.b
   ->  Partial Seq Scan on orca.tcorr1
         Output: tcorr1.a, tcorr1.b
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Aggregate
                 Output: max(((tcorr2.b + tcorr1.b) - 1))
                 ->  Result
                       Output: tcorr2.b
                       Filter: (tcorr2.a = tcorr1.a)
                       ->  Materialize
                             Output: tcorr2.a, tcorr2.b
                             ->  PX Broadcast 6:6  (slice2; segments: 6)
                                   Output: tcorr2.a, tcorr2.b
                                   ->  Partial Seq Scan on orca.tcorr2
                                         Output: tcorr2.a, tcorr2.b
 Optimizer: PolarDB PX Optimizer
(18 rows)

explain (costs off) select *
from tcorr1 out
where out.b in (select coalesce(tcorr2_d.c, 99)
                from tcorr1 left outer join (select a, count(*) as c
                                             from tcorr2
                                             where tcorr2.b = out.b
                                             group by a) tcorr2_d on tcorr1.a=tcorr2_d.a);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on tcorr1 "out"
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (tcorr1.a = tcorr2.a)
           ->  Seq Scan on tcorr1
           ->  HashAggregate
                 Group Key: tcorr2.a
                 ->  Seq Scan on tcorr2
                       Filter: (b = "out".b)
(10 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select coalesce(tcorr2_d.c, 99)
                from tcorr1 left outer join (select a, count(*) as c
                                             from tcorr2
                                             where tcorr2.b = out.b
                                             group by a) tcorr2_d on tcorr1.a=tcorr2_d.a);
 a | b  
---+----
 1 | 99
(1 row)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Result
   Output: tcorr1.a, tcorr1.b
   Filter: (SubPlan 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: tcorr1.a, tcorr1.b
         ->  Partial Seq Scan on orca.tcorr1
               Output: tcorr1.a, tcorr1.b
   SubPlan 1
     ->  Nested Loop Left Join
           Output: COALESCE((count()), '99'::bigint)
           Join Filter: (tcorr1_1.a = tcorr2.a)
           ->  Materialize
                 Output: tcorr1_1.a
                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                       Output: tcorr1_1.a
                       ->  Partial Seq Scan on orca.tcorr1 tcorr1_1
                             Output: tcorr1_1.a
           ->  GroupAggregate
                 Output: count(), tcorr2.a
                 Group Key: tcorr2.a
                 ->  Sort
                       Output: tcorr2.a
                       Sort Key: tcorr2.a
                       ->  Result
                             Output: tcorr2.a
                             Filter: (tcorr2.b = tcorr1.b)
                             ->  Materialize
                                   Output: tcorr2.a, tcorr2.b
                                   ->  PX Coordinator 6:1  (slice2; segments: 6)
                                         Output: tcorr2.a, tcorr2.b
                                         ->  Partial Seq Scan on orca.tcorr2
                                               Output: tcorr2.a, tcorr2.b
 Optimizer: PolarDB PX Optimizer
(33 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select coalesce(tcorr2.a, 99)
                from tcorr1 full outer join tcorr2 on tcorr1.a=tcorr2.a+out.a);
 a | b  
---+----
 1 | 99
(1 row)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  No plan has been computed for required properties
set polar_px_optimizer_join_order to exhaustive2;
explain (costs off) select *
from tcorr1 out
where out.b in (select coalesce(tcorr2.a, 99)
                from tcorr1 left outer join tcorr2 on tcorr1.a=tcorr2.a+out.a);
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on tcorr1 "out"
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (tcorr1.a = (tcorr2.a + "out".a))
           ->  Seq Scan on tcorr1
           ->  Seq Scan on tcorr2
(7 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select coalesce(tcorr2.a, 99)
                from tcorr1 left outer join tcorr2 on tcorr1.a=tcorr2.a+out.a);
 a | b  
---+----
 1 | 99
(1 row)

                             QUERY PLAN                             
--------------------------------------------------------------------
 Result
   Output: tcorr1.a, tcorr1.b
   Filter: (SubPlan 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: tcorr1.a, tcorr1.b
         ->  Partial Seq Scan on orca.tcorr1
               Output: tcorr1.a, tcorr1.b
   SubPlan 1
     ->  Nested Loop Left Join
           Output: COALESCE(tcorr2.a, 99)
           Join Filter: (tcorr1_1.a = (tcorr2.a + tcorr1.a))
           ->  Materialize
                 Output: tcorr1_1.a
                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                       Output: tcorr1_1.a
                       ->  Partial Seq Scan on orca.tcorr1 tcorr1_1
                             Output: tcorr1_1.a
           ->  Materialize
                 Output: tcorr2.a
                 ->  PX Coordinator 6:1  (slice2; segments: 6)
                       Output: tcorr2.a
                       ->  Partial Seq Scan on orca.tcorr2
                             Output: tcorr2.a
 Optimizer: PolarDB PX Optimizer
(24 rows)

explain (costs off) select *
from tcorr1 out
where out.b in (select max(tcorr2.b + out.b - 1)
                from tcorr2
                where tcorr2.a=out.a);
              QUERY PLAN               
---------------------------------------
 Seq Scan on tcorr1 "out"
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Aggregate
           ->  Seq Scan on tcorr2
                 Filter: (a = "out".a)
(6 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select max(tcorr2.b + out.b - 1)
                from tcorr2
                where tcorr2.a=out.a);
 a | b  
---+----
 1 | 99
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tcorr1.a, tcorr1.b
   ->  Partial Seq Scan on orca.tcorr1
         Output: tcorr1.a, tcorr1.b
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Aggregate
                 Output: max(((tcorr2.b + tcorr1.b) - 1))
                 ->  Result
                       Output: tcorr2.b
                       Filter: (tcorr2.a = tcorr1.a)
                       ->  Materialize
                             Output: tcorr2.a, tcorr2.b
                             ->  PX Broadcast 6:6  (slice2; segments: 6)
                                   Output: tcorr2.a, tcorr2.b
                                   ->  Partial Seq Scan on orca.tcorr2
                                         Output: tcorr2.a, tcorr2.b
 Optimizer: PolarDB PX Optimizer
(18 rows)

explain (costs off) select *
from tcorr1 out
where out.b in (select coalesce(tcorr2_d.c, 99)
                from tcorr1 left outer join (select a, count(*) as c
                                             from tcorr2
                                             where tcorr2.b = out.b
                                             group by a) tcorr2_d on tcorr1.a=tcorr2_d.a);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on tcorr1 "out"
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (tcorr1.a = tcorr2.a)
           ->  Seq Scan on tcorr1
           ->  HashAggregate
                 Group Key: tcorr2.a
                 ->  Seq Scan on tcorr2
                       Filter: (b = "out".b)
(10 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select coalesce(tcorr2_d.c, 99)
                from tcorr1 left outer join (select a, count(*) as c
                                             from tcorr2
                                             where tcorr2.b = out.b
                                             group by a) tcorr2_d on tcorr1.a=tcorr2_d.a);
 a | b  
---+----
 1 | 99
(1 row)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Result
   Output: tcorr1.a, tcorr1.b
   Filter: (SubPlan 1)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: tcorr1.a, tcorr1.b
         ->  Partial Seq Scan on orca.tcorr1
               Output: tcorr1.a, tcorr1.b
   SubPlan 1
     ->  Nested Loop Left Join
           Output: COALESCE((count()), '99'::bigint)
           Join Filter: (tcorr1_1.a = tcorr2.a)
           ->  Materialize
                 Output: tcorr1_1.a
                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                       Output: tcorr1_1.a
                       ->  Partial Seq Scan on orca.tcorr1 tcorr1_1
                             Output: tcorr1_1.a
           ->  GroupAggregate
                 Output: count(), tcorr2.a
                 Group Key: tcorr2.a
                 ->  Sort
                       Output: tcorr2.a
                       Sort Key: tcorr2.a
                       ->  Result
                             Output: tcorr2.a
                             Filter: (tcorr2.b = tcorr1.b)
                             ->  Materialize
                                   Output: tcorr2.a, tcorr2.b
                                   ->  PX Coordinator 6:1  (slice2; segments: 6)
                                         Output: tcorr2.a, tcorr2.b
                                         ->  Partial Seq Scan on orca.tcorr2
                                               Output: tcorr2.a, tcorr2.b
 Optimizer: PolarDB PX Optimizer
(33 rows)

-- expect 1 row
select *
from tcorr1 out
where out.b in (select coalesce(tcorr2.a, 99)
                from tcorr1 full outer join tcorr2 on tcorr1.a=tcorr2.a+out.a);
 a | b  
---+----
 1 | 99
(1 row)

INFO:  PXOPT failed to produce a plan, falling back to planner
DETAIL:  No plan has been computed for required properties
reset polar_px_optimizer_join_order;
-- test selecting an outer ref from a scalar subquery
-- expect 0 rows
SELECT 1
FROM   tcorr1
WHERE  tcorr1.a IS NULL OR
       tcorr1.a = (SELECT tcorr1.a
                   FROM   (SELECT rtrim(tcorr1.a::text) AS userid,
                                  rtrim(tcorr1.b::text) AS part_pls
                           FROM   tcorr2) al
                   WHERE  3 = tcorr1.a
                  );
 ?column? 
----------
(0 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Result
   Output: 1
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Result
               Filter: ((tcorr1.a IS NULL) OR (tcorr1.a = (SubPlan 1)))
               ->  Partial Seq Scan on orca.tcorr1
                     Output: tcorr1.a, tcorr1.b
               SubPlan 1
                 ->  Result
                       Output: tcorr1.a
                       One-Time Filter: (tcorr1.a = 3)
                       ->  Result
                             Output: rtrim((tcorr1.a)::text), rtrim((tcorr1.b)::text)
                             ->  Materialize
                                   ->  PX Broadcast 6:6  (slice2; segments: 6)
                                         ->  Partial Seq Scan on orca.tcorr2
 Optimizer: PolarDB PX Optimizer
(17 rows)

-- expect 1 row, subquery returns a row
select * from tcorr1 where b = (select tcorr1.b from tcorr2);
 a | b  
---+----
 1 | 99
(1 row)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tcorr1.a, tcorr1.b
   ->  Partial Seq Scan on orca.tcorr1
         Output: tcorr1.a, tcorr1.b
         Filter: (tcorr1.b = (SubPlan 1))
         SubPlan 1
           ->  Result
                 Output: tcorr1.b
                 ->  Materialize
                       ->  PX Broadcast 6:6  (slice2; segments: 6)
                             ->  Partial Seq Scan on orca.tcorr2
 Optimizer: PolarDB PX Optimizer
(12 rows)

-- expect 0 rows, subquery returns no rows
select * from tcorr1 where b = (select tcorr1.b from tcorr2 where b=33);
 a | b 
---+---
(0 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tcorr1.a, tcorr1.b
   ->  Partial Seq Scan on orca.tcorr1
         Output: tcorr1.a, tcorr1.b
         Filter: (tcorr1.b = (SubPlan 1))
         SubPlan 1
           ->  Result
                 Output: tcorr1.b
                 ->  Materialize
                       ->  PX Broadcast 6:6  (slice2; segments: 6)
                             ->  Partial Seq Scan on orca.tcorr2
                                   Filter: (tcorr2.b = 33)
 Optimizer: PolarDB PX Optimizer
(13 rows)

-- expect 1 row, subquery returns nothing, so a < 22 is true
select * from tcorr1 where a < coalesce((select tcorr1.a from tcorr2 where a = 11), 22);
 a | b  
---+----
 1 | 99
(1 row)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tcorr1.a, tcorr1.b
   ->  Partial Seq Scan on orca.tcorr1
         Output: tcorr1.a, tcorr1.b
         Filter: (tcorr1.a < COALESCE((SubPlan 1), 22))
         SubPlan 1
           ->  Result
                 Output: tcorr1.a
                 ->  Materialize
                       ->  PX Broadcast 6:6  (slice2; segments: 6)
                             ->  Partial Seq Scan on orca.tcorr2
                                   Filter: (tcorr2.a = 11)
 Optimizer: PolarDB PX Optimizer
(13 rows)

-- test join to index get apply xform
drop table if exists foo, tbtree, tbitmap;
NOTICE:  table "tbtree" does not exist, skipping
NOTICE:  table "tbitmap" does not exist, skipping
create table foo(a int, b int, c int) ;
create table tbtree(a int, b int, c int) ;
create table tbitmap(a int, b int, c int) ;
insert into foo select i*1000,i*1000,i*1000 from generate_series(1,10) i;
insert into tbtree select i,i,i from generate_series(1,100000) i;
insert into tbitmap select i,i,i from generate_series(1,100000) i;
-- insert a duplicate value for a=2000
insert into tbtree values (2000,-1,-1);
insert into tbitmap values (2000,-1,-1);
create index tbtreexa  on tbtree  using btree(a);
create index tbitmapxa on tbitmap using bitmap(a);
ERROR:  access method "bitmap" does not exist
analyze foo;
analyze tbtree;
analyze tbitmap;
set polar_px_optimizer_join_order = query;
set polar_px_optimizer_enable_hashjoin = off;
set polar_px_optimizer_enable_groupagg = off;
set polar_px_optimizer_trace_fallback = on;
set enable_sort = off;
-- 1 simple btree
explain (costs off)
select * from foo join tbtree on foo.a=tbtree.a;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on foo
   ->  Index Scan using tbtreexa on tbtree
         Index Cond: (a = foo.a)
(4 rows)

select * from foo join tbtree on foo.a=tbtree.a;
   a   |   b   |   c   |   a   |   b   |   c   
-------+-------+-------+-------+-------+-------
  1000 |  1000 |  1000 |  1000 |  1000 |  1000
  2000 |  2000 |  2000 |  2000 |  2000 |  2000
  2000 |  2000 |  2000 |  2000 |    -1 |    -1
  3000 |  3000 |  3000 |  3000 |  3000 |  3000
  4000 |  4000 |  4000 |  4000 |  4000 |  4000
  5000 |  5000 |  5000 |  5000 |  5000 |  5000
  6000 |  6000 |  6000 |  6000 |  6000 |  6000
  7000 |  7000 |  7000 |  7000 |  7000 |  7000
  8000 |  8000 |  8000 |  8000 |  8000 |  8000
  9000 |  9000 |  9000 |  9000 |  9000 |  9000
 10000 | 10000 | 10000 | 10000 | 10000 | 10000
(11 rows)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbtree.a, tbtree.b, tbtree.c
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbtree.a, tbtree.b, tbtree.c
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  Partial Index Scan using tbtreexa on orca.tbtree
               Output: tbtree.a, tbtree.b, tbtree.c
               Index Cond: (tbtree.a = foo.a)
 Optimizer: PolarDB PX Optimizer
(13 rows)

-- 2 simple bitmap
explain (costs off)
select * from foo join tbitmap on foo.a=tbitmap.a;
            QUERY PLAN            
----------------------------------
 Hash Join
   Hash Cond: (tbitmap.a = foo.a)
   ->  Seq Scan on tbitmap
   ->  Hash
         ->  Seq Scan on foo
(5 rows)

select * from foo join tbitmap on foo.a=tbitmap.a;
   a   |   b   |   c   |   a   |   b   |   c   
-------+-------+-------+-------+-------+-------
  1000 |  1000 |  1000 |  1000 |  1000 |  1000
  2000 |  2000 |  2000 |  2000 |  2000 |  2000
  3000 |  3000 |  3000 |  3000 |  3000 |  3000
  4000 |  4000 |  4000 |  4000 |  4000 |  4000
  5000 |  5000 |  5000 |  5000 |  5000 |  5000
  6000 |  6000 |  6000 |  6000 |  6000 |  6000
  7000 |  7000 |  7000 |  7000 |  7000 |  7000
  8000 |  8000 |  8000 |  8000 |  8000 |  8000
  9000 |  9000 |  9000 |  9000 |  9000 |  9000
 10000 | 10000 | 10000 | 10000 | 10000 | 10000
  2000 |  2000 |  2000 |  2000 |    -1 |    -1
(11 rows)

                              QUERY PLAN                              
----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbitmap.a, tbitmap.b, tbitmap.c
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbitmap.a, tbitmap.b, tbitmap.c
         Join Filter: (foo.a = tbitmap.a)
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  Partial Seq Scan on orca.tbitmap
               Output: tbitmap.a, tbitmap.b, tbitmap.c
 Optimizer: PolarDB PX Optimizer
(12 rows)

-- 3 btree with select pred
explain (costs off)
select * from foo join tbtree on foo.a=tbtree.a where tbtree.a < 5000;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop
   ->  Seq Scan on foo
   ->  Index Scan using tbtreexa on tbtree
         Index Cond: ((a = foo.a) AND (a < 5000))
(4 rows)

select * from foo join tbtree on foo.a=tbtree.a where tbtree.a < 5000;
  a   |  b   |  c   |  a   |  b   |  c   
------+------+------+------+------+------
 1000 | 1000 | 1000 | 1000 | 1000 | 1000
 2000 | 2000 | 2000 | 2000 | 2000 | 2000
 2000 | 2000 | 2000 | 2000 |   -1 |   -1
 3000 | 3000 | 3000 | 3000 | 3000 | 3000
 4000 | 4000 | 4000 | 4000 | 4000 | 4000
(5 rows)

                              QUERY PLAN                              
----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbtree.a, tbtree.b, tbtree.c
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbtree.a, tbtree.b, tbtree.c
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
                     Filter: (foo.a < 5000)
         ->  Partial Index Scan using tbtreexa on orca.tbtree
               Output: tbtree.a, tbtree.b, tbtree.c
               Index Cond: ((tbtree.a = foo.a) AND (tbtree.a < 5000))
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- 4 bitmap with select pred
explain (costs off)
select * from foo join tbitmap on foo.a=tbitmap.a where tbitmap.a < 5000;
            QUERY PLAN            
----------------------------------
 Hash Join
   Hash Cond: (tbitmap.a = foo.a)
   ->  Seq Scan on tbitmap
         Filter: (a < 5000)
   ->  Hash
         ->  Seq Scan on foo
(6 rows)

select * from foo join tbitmap on foo.a=tbitmap.a where tbitmap.a < 5000;
  a   |  b   |  c   |  a   |  b   |  c   
------+------+------+------+------+------
 1000 | 1000 | 1000 | 1000 | 1000 | 1000
 2000 | 2000 | 2000 | 2000 | 2000 | 2000
 3000 | 3000 | 3000 | 3000 | 3000 | 3000
 4000 | 4000 | 4000 | 4000 | 4000 | 4000
 2000 | 2000 | 2000 | 2000 |   -1 |   -1
(5 rows)

                              QUERY PLAN                              
----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbitmap.a, tbitmap.b, tbitmap.c
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbitmap.a, tbitmap.b, tbitmap.c
         Join Filter: (foo.a = tbitmap.a)
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
                     Filter: (foo.a < 5000)
         ->  Partial Seq Scan on orca.tbitmap
               Output: tbitmap.a, tbitmap.b, tbitmap.c
               Filter: (tbitmap.a < 5000)
 Optimizer: PolarDB PX Optimizer
(14 rows)

-- 5 btree with project
explain (costs off)
select * from foo join (select a, b+c as bc from tbtree) proj on foo.a=proj.a;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on foo
   ->  Index Scan using tbtreexa on tbtree
         Index Cond: (a = foo.a)
(4 rows)

select * from foo join (select a, b+c as bc from tbtree) proj on foo.a=proj.a;
   a   |   b   |   c   |   a   |  bc   
-------+-------+-------+-------+-------
  1000 |  1000 |  1000 |  1000 |  2000
  2000 |  2000 |  2000 |  2000 |  4000
  2000 |  2000 |  2000 |  2000 |    -2
  3000 |  3000 |  3000 |  3000 |  6000
  4000 |  4000 |  4000 |  4000 |  8000
  5000 |  5000 |  5000 |  5000 | 10000
  6000 |  6000 |  6000 |  6000 | 12000
  7000 |  7000 |  7000 |  7000 | 14000
  8000 |  8000 |  8000 |  8000 | 16000
  9000 |  9000 |  9000 |  9000 | 18000
 10000 | 10000 | 10000 | 10000 | 20000
(11 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbtree.a, ((tbtree.b + tbtree.c))
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbtree.a, ((tbtree.b + tbtree.c))
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  Partial Index Scan using tbtreexa on orca.tbtree
               Output: (tbtree.b + tbtree.c), tbtree.a
               Index Cond: (tbtree.a = foo.a)
 Optimizer: PolarDB PX Optimizer
(13 rows)

-- 6 bitmap with project
explain (costs off)
select * from foo join (select a, b+c as bc from tbitmap) proj on foo.a=proj.a;
            QUERY PLAN            
----------------------------------
 Hash Join
   Hash Cond: (tbitmap.a = foo.a)
   ->  Seq Scan on tbitmap
   ->  Hash
         ->  Seq Scan on foo
(5 rows)

select * from foo join (select a, b+c as bc from tbitmap) proj on foo.a=proj.a;
   a   |   b   |   c   |   a   |  bc   
-------+-------+-------+-------+-------
  1000 |  1000 |  1000 |  1000 |  2000
  2000 |  2000 |  2000 |  2000 |  4000
  3000 |  3000 |  3000 |  3000 |  6000
  4000 |  4000 |  4000 |  4000 |  8000
  5000 |  5000 |  5000 |  5000 | 10000
  6000 |  6000 |  6000 |  6000 | 12000
  7000 |  7000 |  7000 |  7000 | 14000
  8000 |  8000 |  8000 |  8000 | 16000
  9000 |  9000 |  9000 |  9000 | 18000
 10000 | 10000 | 10000 | 10000 | 20000
  2000 |  2000 |  2000 |  2000 |    -2
(11 rows)

                                QUERY PLAN                                 
---------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbitmap.a, ((tbitmap.b + tbitmap.c))
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbitmap.a, ((tbitmap.b + tbitmap.c))
         Join Filter: (foo.a = tbitmap.a)
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  Partial Seq Scan on orca.tbitmap
               Output: (tbitmap.b + tbitmap.c), tbitmap.a
 Optimizer: PolarDB PX Optimizer
(12 rows)

-- 7 btree with grby
explain (costs off)
select * from foo join (select a, count(*) as cnt from tbtree group by a,b) grby on foo.a=grby.a;
                 QUERY PLAN                 
--------------------------------------------
 Hash Join
   Hash Cond: (tbtree.a = foo.a)
   ->  GroupAggregate
         Group Key: tbtree.a, tbtree.b
         ->  Sort
               Sort Key: tbtree.a, tbtree.b
               ->  Seq Scan on tbtree
   ->  Hash
         ->  Seq Scan on foo
(9 rows)

select * from foo join (select a, count(*) as cnt from tbtree group by a,b) grby on foo.a=grby.a;
   a   |   b   |   c   |   a   | cnt 
-------+-------+-------+-------+-----
  1000 |  1000 |  1000 |  1000 |   1
  2000 |  2000 |  2000 |  2000 |   1
  2000 |  2000 |  2000 |  2000 |   1
  3000 |  3000 |  3000 |  3000 |   1
  4000 |  4000 |  4000 |  4000 |   1
  5000 |  5000 |  5000 |  5000 |   1
  6000 |  6000 |  6000 |  6000 |   1
  7000 |  7000 |  7000 |  7000 |   1
  8000 |  8000 |  8000 |  8000 |   1
  9000 |  9000 |  9000 |  9000 |   1
 10000 | 10000 | 10000 | 10000 |   1
(11 rows)

                          QUERY PLAN                           
---------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbtree.a, (count())
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbtree.a, (count())
         Join Filter: (foo.a = tbtree.a)
         ->  PX Broadcast 6:6  (slice3; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  HashAggregate
               Output: count(), tbtree.a, tbtree.b
               Group Key: tbtree.a, tbtree.b
               ->  Materialize
                     Output: tbtree.a, tbtree.b
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: tbtree.a, tbtree.b
                           Hash Key: tbtree.a, tbtree.b
                           ->  Partial Seq Scan on orca.tbtree
                                 Output: tbtree.a, tbtree.b
 Optimizer: PolarDB PX Optimizer
(20 rows)

-- 8 bitmap with grby
explain (costs off)
select * from foo join (select a, count(*) as cnt from tbitmap group by a) grby on foo.a=grby.a;
              QUERY PLAN               
---------------------------------------
 Hash Join
   Hash Cond: (tbitmap.a = foo.a)
   ->  GroupAggregate
         Group Key: tbitmap.a
         ->  Sort
               Sort Key: tbitmap.a
               ->  Seq Scan on tbitmap
   ->  Hash
         ->  Seq Scan on foo
(9 rows)

select * from foo join (select a, count(*) as cnt from tbitmap group by a) grby on foo.a=grby.a;
   a   |   b   |   c   |   a   | cnt 
-------+-------+-------+-------+-----
  1000 |  1000 |  1000 |  1000 |   1
  2000 |  2000 |  2000 |  2000 |   2
  3000 |  3000 |  3000 |  3000 |   1
  4000 |  4000 |  4000 |  4000 |   1
  5000 |  5000 |  5000 |  5000 |   1
  6000 |  6000 |  6000 |  6000 |   1
  7000 |  7000 |  7000 |  7000 |   1
  8000 |  8000 |  8000 |  8000 |   1
  9000 |  9000 |  9000 |  9000 |   1
 10000 | 10000 | 10000 | 10000 |   1
(10 rows)

                           QUERY PLAN                           
----------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbitmap.a, (count())
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbitmap.a, (count())
         Join Filter: (foo.a = tbitmap.a)
         ->  PX Broadcast 6:6  (slice3; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  HashAggregate
               Output: count(), tbitmap.a
               Group Key: tbitmap.a
               ->  Materialize
                     Output: tbitmap.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: tbitmap.a
                           Hash Key: tbitmap.a
                           ->  Partial Seq Scan on orca.tbitmap
                                 Output: tbitmap.a
 Optimizer: PolarDB PX Optimizer
(20 rows)

-- 9 btree with proj select grby select
explain (costs off)
select * from foo join (select a, count(*) + 5 as cnt from tbtree where tbtree.a < 5000 group by a having count(*) < 2) proj_sel_grby_sel on foo.a=proj_sel_grby_sel.a;
                      QUERY PLAN                      
------------------------------------------------------
 Hash Join
   Hash Cond: (tbtree.a = foo.a)
   ->  GroupAggregate
         Group Key: tbtree.a
         Filter: (count(*) < 2)
         ->  Index Only Scan using tbtreexa on tbtree
               Index Cond: (a < 5000)
   ->  Hash
         ->  Seq Scan on foo
(9 rows)

select * from foo join (select a, count(*) + 5 as cnt from tbtree where tbtree.a < 5000 group by a having count(*) < 2) proj_sel_grby_sel on foo.a=proj_sel_grby_sel.a;
  a   |  b   |  c   |  a   | cnt 
------+------+------+------+-----
 1000 | 1000 | 1000 | 1000 |   6
 3000 | 3000 | 3000 | 3000 |   6
 4000 | 4000 | 4000 | 4000 |   6
(3 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbtree.a, (((count()) + 5))
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbtree.a, (((count()) + 5))
         Join Filter: (foo.a = tbtree.a)
         ->  PX Broadcast 6:6  (slice3; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
                     Filter: (foo.a < 5000)
         ->  Result
               Output: ((count()) + 5), tbtree.a
               Filter: ((count()) < 2)
               ->  HashAggregate
                     Output: count(), count(), tbtree.a
                     Group Key: tbtree.a
                     ->  Materialize
                           Output: tbtree.a
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: tbtree.a
                                 Hash Key: tbtree.a
                                 ->  Partial Index Scan using tbtreexa on orca.tbtree
                                       Output: tbtree.a
                                       Index Cond: (tbtree.a < 5000)
 Optimizer: PolarDB PX Optimizer
(25 rows)

-- 10 bitmap with proj select grby select
explain (costs off)
select * from foo join (select a, count(*) + 5 as cnt from tbitmap where tbitmap.a < 5000 group by a having count(*) < 2) proj_sel_grby_sel on foo.a=proj_sel_grby_sel.a;
            QUERY PLAN            
----------------------------------
 Hash Join
   Hash Cond: (tbitmap.a = foo.a)
   ->  HashAggregate
         Group Key: tbitmap.a
         Filter: (count(*) < 2)
         ->  Seq Scan on tbitmap
               Filter: (a < 5000)
   ->  Hash
         ->  Seq Scan on foo
(9 rows)

select * from foo join (select a, count(*) + 5 as cnt from tbitmap where tbitmap.a < 5000 group by a having count(*) < 2) proj_sel_grby_sel on foo.a=proj_sel_grby_sel.a;
  a   |  b   |  c   |  a   | cnt 
------+------+------+------+-----
 4000 | 4000 | 4000 | 4000 |   6
 3000 | 3000 | 3000 | 3000 |   6
 1000 | 1000 | 1000 | 1000 |   6
(3 rows)

                              QUERY PLAN                              
----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbitmap.a, (((count()) + 5))
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbitmap.a, (((count()) + 5))
         Join Filter: (foo.a = tbitmap.a)
         ->  PX Broadcast 6:6  (slice3; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
                     Filter: (foo.a < 5000)
         ->  Result
               Output: ((count()) + 5), tbitmap.a
               Filter: ((count()) < 2)
               ->  HashAggregate
                     Output: count(), count(), tbitmap.a
                     Group Key: tbitmap.a
                     ->  Materialize
                           Output: tbitmap.a
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: tbitmap.a
                                 Hash Key: tbitmap.a
                                 ->  Partial Seq Scan on orca.tbitmap
                                       Output: tbitmap.a
                                       Filter: (tbitmap.a < 5000)
 Optimizer: PolarDB PX Optimizer
(25 rows)

-- 11 bitmap with two groupbys
explain (costs off)
select * from foo join (select a, count(*) as cnt from (select distinct a, b from tbitmap) grby1 group by a) grby2 on foo.a=grby2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Hash Cond: (tbitmap.a = foo.a)
   ->  GroupAggregate
         Group Key: tbitmap.a
         ->  Unique
               ->  Sort
                     Sort Key: tbitmap.a, tbitmap.b
                     ->  Seq Scan on tbitmap
   ->  Hash
         ->  Seq Scan on foo
(10 rows)

select * from foo join (select a, count(*) as cnt from (select distinct a, b from tbitmap) grby1 group by a) grby2 on foo.a=grby2.a;
   a   |   b   |   c   |   a   | cnt 
-------+-------+-------+-------+-----
  1000 |  1000 |  1000 |  1000 |   1
  2000 |  2000 |  2000 |  2000 |   2
  3000 |  3000 |  3000 |  3000 |   1
  4000 |  4000 |  4000 |  4000 |   1
  5000 |  5000 |  5000 |  5000 |   1
  6000 |  6000 |  6000 |  6000 |   1
  7000 |  7000 |  7000 |  7000 |   1
  8000 |  8000 |  8000 |  8000 |   1
  9000 |  9000 |  9000 |  9000 |   1
 10000 | 10000 | 10000 | 10000 |   1
(10 rows)

                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbitmap.a, (count())
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbitmap.a, (count())
         Join Filter: (foo.a = tbitmap.a)
         ->  PX Broadcast 6:6  (slice4; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
         ->  HashAggregate
               Output: count(), tbitmap.a
               Group Key: tbitmap.a
               ->  Materialize
                     Output: tbitmap.a
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: tbitmap.a
                           Hash Key: tbitmap.a
                           ->  HashAggregate
                                 Output: tbitmap.a
                                 Group Key: tbitmap.a, tbitmap.b
                                 ->  PX Hash 6:6  (slice3; segments: 6)
                                       Output: tbitmap.a, tbitmap.b
                                       Hash Key: tbitmap.a, tbitmap.b
                                       ->  Partial Seq Scan on orca.tbitmap
                                             Output: tbitmap.a, tbitmap.b
 Optimizer: PolarDB PX Optimizer
(26 rows)

-- 12 btree with proj select 2*grby select
explain (costs off)
select * from foo join (select a, count(*) + cnt1 as cnt2 from (select a, count(*) as cnt1 from tbtree group by a) grby1
                                                                where grby1.a < 5000 group by a, cnt1 having count(*) < 2) proj_sel_grby_sel
                    on foo.a=proj_sel_grby_sel.a;
                         QUERY PLAN                         
------------------------------------------------------------
 Hash Join
   Hash Cond: (tbtree.a = foo.a)
   ->  HashAggregate
         Group Key: tbtree.a, count(*)
         Filter: (count(*) < 2)
         ->  GroupAggregate
               Group Key: tbtree.a
               ->  Index Only Scan using tbtreexa on tbtree
                     Index Cond: (a < 5000)
   ->  Hash
         ->  Seq Scan on foo
(11 rows)

select * from foo join (select a, count(*) + cnt1 as cnt2 from (select a, count(*) as cnt1 from tbtree group by a) grby1
                                                                where grby1.a < 5000 group by a, cnt1 having count(*) < 2) proj_sel_grby_sel
                    on foo.a=proj_sel_grby_sel.a;
  a   |  b   |  c   |  a   | cnt2 
------+------+------+------+------
 2000 | 2000 | 2000 | 2000 |    3
 1000 | 1000 | 1000 | 1000 |    2
 4000 | 4000 | 4000 | 4000 |    2
 3000 | 3000 | 3000 | 3000 |    2
(4 rows)

                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: foo.a, foo.b, foo.c, tbtree.a, (((count()) + (count())))
   ->  Nested Loop
         Output: foo.a, foo.b, foo.c, tbtree.a, (((count()) + (count())))
         Join Filter: (foo.a = tbtree.a)
         ->  PX Broadcast 6:6  (slice3; segments: 6)
               Output: foo.a, foo.b, foo.c
               ->  Partial Seq Scan on orca.foo
                     Output: foo.a, foo.b, foo.c
                     Filter: (foo.a < 5000)
         ->  Result
               Output: ((count()) + (count())), tbtree.a
               Filter: ((count()) < 2)
               ->  HashAggregate
                     Output: count(), count(), tbtree.a, (count())
                     Group Key: tbtree.a, count()
                     ->  HashAggregate
                           Output: count(), tbtree.a
                           Group Key: tbtree.a
                           ->  Materialize
                                 Output: tbtree.a
                                 ->  PX Hash 6:6  (slice2; segments: 6)
                                       Output: tbtree.a
                                       Hash Key: tbtree.a
                                       ->  Partial Index Scan using tbtreexa on orca.tbtree
                                             Output: tbtree.a
                                             Index Cond: (tbtree.a < 5000)
 Optimizer: PolarDB PX Optimizer
(28 rows)

-- 13 join pred accesses a projected column - no index scan
explain (costs off)
select * from foo join (select a, a::bigint*a::bigint as aa from tbtree) proj on foo.a=proj.a and foo.b=proj.aa;
                      QUERY PLAN                       
-------------------------------------------------------
 Nested Loop
   ->  Seq Scan on foo
   ->  Index Only Scan using tbtreexa on tbtree
         Index Cond: (a = foo.a)
         Filter: (foo.b = ((a)::bigint * (a)::bigint))
(5 rows)

-- 14 join pred accesses a projected column - no index scan
explain (costs off)
select * from foo join (select a, count(*) as cnt from tbitmap group by a) grby on foo.a=grby.a and foo.b=grby.cnt;
                         QUERY PLAN                          
-------------------------------------------------------------
 Hash Join
   Hash Cond: ((tbitmap.a = foo.a) AND ((count(*)) = foo.b))
   ->  GroupAggregate
         Group Key: tbitmap.a
         ->  Sort
               Sort Key: tbitmap.a
               ->  Seq Scan on tbitmap
   ->  Hash
         ->  Seq Scan on foo
(9 rows)

-- 15 the potential index join itself contains outer refs - no index scan
explain (costs off)
select *
from foo l1 where b in (select ab
                        from foo l2 join (select *, l1.a+tbtree.b as ab from tbtree) tbtree_derived
                                    on l2.a=tbtree_derived.a and l2.b=tbtree_derived.b
                        where l2.c = 1
                       );
                    QUERY PLAN                     
---------------------------------------------------
 Seq Scan on foo l1
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on foo l2
                 Filter: (c = 1)
           ->  Index Scan using tbtreexa on tbtree
                 Index Cond: (a = l2.a)
                 Filter: (l2.b = b)
(9 rows)

-- 16 group by columns are not a superset of the distribution columns - no index scan
explain (costs off)
select * from foo join (select b, count(*) as cnt from tbtree group by b) grby on foo.a=grby.cnt;
              QUERY PLAN              
--------------------------------------
 Hash Join
   Hash Cond: ((count(*)) = foo.a)
   ->  GroupAggregate
         Group Key: tbtree.b
         ->  Sort
               Sort Key: tbtree.b
               ->  Seq Scan on tbtree
   ->  Hash
         ->  Seq Scan on foo
(9 rows)

-- 17 group by columns don't intersect - no index scan
explain (costs off)
select * from foo join (select min_a, count(*) as cnt from (select min(a) as min_a, b from tbitmap group by b) grby1 group by min_a) grby2 on foo.a=grby2.min_a;
                 QUERY PLAN                  
---------------------------------------------
 Hash Join
   Hash Cond: ((min(tbitmap.a)) = foo.a)
   ->  HashAggregate
         Group Key: min(tbitmap.a)
         ->  GroupAggregate
               Group Key: tbitmap.b
               ->  Sort
                     Sort Key: tbitmap.b
                     ->  Seq Scan on tbitmap
   ->  Hash
         ->  Seq Scan on foo
(11 rows)

reset polar_px_optimizer_join_order;
reset polar_px_optimizer_enable_hashjoin;
reset polar_px_optimizer_enable_groupagg;
-- ROJ must use the hash side for deriving the distribution spec. Force a non-redistribute plan to ensure we get some motion (gather)
create table roj1 (a int, b int) ;
create table roj2 (c int, d int) ;
insert into roj1 values (1, 1);
insert into roj1 values (2, 2);
insert into roj2 select null,null from generate_series(1,10) ;
analyze roj1;
analyze roj2;
set polar_px_optimizer_enable_motion_redistribute=off;
select count(*), t2.c from roj1 t1 left join roj2 t2 on t1.a = t2.c group by t2.c;
 count | c 
-------+---
     2 |  
(1 row)

                            QUERY PLAN                             
-------------------------------------------------------------------
 GroupAggregate
   Output: count(), roj2.c
   Group Key: roj2.c
   ->  Sort
         Output: roj2.c
         Sort Key: roj2.c
         ->  Hash Right Join
               Output: roj2.c
               Hash Cond: (roj2.c = roj1.a)
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: roj2.c
                     ->  Partial Seq Scan on orca.roj2
                           Output: roj2.c
               ->  Hash
                     Output: roj1.a
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: roj1.a
                           ->  Partial Seq Scan on orca.roj1
                                 Output: roj1.a
 Optimizer: PolarDB PX Optimizer
(20 rows)

explain (costs off) select count(*), t2.c from roj1 t1 left join roj2 t2 on t1.a = t2.c group by t2.c;
              QUERY PLAN               
---------------------------------------
 HashAggregate
   Group Key: t2.c
   ->  Hash Right Join
         Hash Cond: (t2.c = t1.a)
         ->  Seq Scan on roj2 t2
         ->  Hash
               ->  Seq Scan on roj1 t1
(7 rows)

reset polar_px_optimizer_enable_motion_redistribute;
reset polar_px_optimizer_trace_fallback;
reset enable_sort;
-- negative test, make sure we don't use a btree scan on an AO table
-- start_ignore
select disable_xform('CXformSelect2BitmapBoolOp');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformSelect2BitmapBoolOp');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select disable_xform('CXformSelect2DynamicBitmapBoolOp');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformSelect2DynamicBitmapBoolOp');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select disable_xform('CXformJoin2BitmapIndexGetApply');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformJoin2BitmapIndexGetApply');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select disable_xform('CXformInnerJoin2NLJoin');
ERROR:  function disable_xform(unknown) does not exist
LINE 1: select disable_xform('CXformInnerJoin2NLJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
-- Make sure we don't allow a regular (btree) index scan or index join for an AO table
-- We disabled hash join, and bitmap index joins, NLJs, so this should leave ORCA no other choices
-- expect a sequential scan, not an index scan, from these two queries
explain (costs off) select * from t_ao_btree where a = 3 and b = 3;
ERROR:  relation "t_ao_btree" does not exist
LINE 1: explain (costs off) select * from t_ao_btree where a = 3 and...
                                          ^
explain (costs off) select * from tpart_ao_btree where a = 3 and b = 3;
ERROR:  relation "tpart_ao_btree" does not exist
LINE 1: explain (costs off) select * from tpart_ao_btree where a = 3...
                                          ^
-- expect a fallback for all four of these queries
select * from tpart_dim d join t_ao_btree f on d.a=f.a where d.b=1;
ERROR:  relation "tpart_dim" does not exist
LINE 1: select * from tpart_dim d join t_ao_btree f on d.a=f.a where...
                      ^
select * from tpart_dim d join tpart_ao_btree f on d.a=f.a where d.b=1;
ERROR:  relation "tpart_dim" does not exist
LINE 1: select * from tpart_dim d join tpart_ao_btree f on d.a=f.a w...
                      ^
-- start_ignore
select enable_xform('CXformSelect2BitmapBoolOp');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformSelect2BitmapBoolOp');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select enable_xform('CXformSelect2DynamicBitmapBoolOp');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformSelect2DynamicBitmapBoolOp');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select enable_xform('CXformJoin2BitmapIndexGetApply');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformJoin2BitmapIndexGetApply');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select enable_xform('CXformInnerJoin2NLJoin');
ERROR:  function enable_xform(unknown) does not exist
LINE 1: select enable_xform('CXformInnerJoin2NLJoin');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- end_ignore
reset polar_px_optimizer_enable_hashjoin;
reset polar_px_optimizer_trace_fallback;
-- Tests converted from MDPs that use tables partitioned on text columns and similar types,
-- which can't be handled in ORCA MDPs, since they would require calling the GPDB executor
set polar_px_optimizer_trace_fallback = on;
-- GroupingOnSameTblCol-2.mdp
-- from dxl
create table asset_records(
  uid varchar,
  hostname varchar,
  active boolean,
  os varchar,
  vendor varchar,
  asset_type varchar,
  create_ts timestamp
)
partition by range(create_ts);
CREATE TABLE asset_records_p1 PARTITION of asset_records for values from ('2000-01-01') to ('2001-01-01');
CREATE TABLE asset_records_p2 PARTITION of asset_records for values from ('2001-01-01') to ('2002-01-01');
CREATE TABLE asset_records_p3 PARTITION of asset_records for values from ('2002-01-01') to ('2003-01-01');
CREATE TABLE asset_records_p4 PARTITION of asset_records for values from ('2003-01-01') to ('2004-01-01');
CREATE TABLE asset_records_p5 PARTITION of asset_records for values from ('2004-01-01') to ('2005-01-01');
create table coverage(
  date timestamp,
  hostname varchar,
  vendor_sla int
)
;
insert into asset_records
select 'u', 'h'||i::text, false, 'o', 'v', 'a', timestamp '2000-03-01 00:00:00' + i * interval '1' minute
from generate_series(1,100000) i;
analyze asset_records;
explain (costs off)
select asset_records.uid, asset_records.hostname, asset_records.asset_type, asset_records.os, asset_records.create_ts, 1
from asset_records left join coverage
     on upper(asset_records.hostname::text) = upper(coverage.hostname::text)
        and asset_records.create_ts = coverage.date
        and (asset_type::text = 'xx' or asset_type::text = 'yy')
        and asset_records.active
where  upper(coalesce(vendor, 'none')::text) <> 'some_vendor' and vendor_sla is not null
group by asset_records.uid, asset_records.hostname, asset_records.asset_type, asset_records.os, asset_records.create_ts;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Group
   Group Key: asset_records_p1.uid, asset_records_p1.hostname, asset_records_p1.asset_type, asset_records_p1.os, asset_records_p1.create_ts
   ->  Sort
         Sort Key: asset_records_p1.uid, asset_records_p1.hostname, asset_records_p1.asset_type, asset_records_p1.os, asset_records_p1.create_ts
         ->  Hash Join
               Hash Cond: ((upper((asset_records_p1.hostname)::text) = upper((coverage.hostname)::text)) AND (asset_records_p1.create_ts = coverage.date))
               ->  Append
                     ->  Seq Scan on asset_records_p1
                           Filter: (active AND (((asset_type)::text = 'xx'::text) OR ((asset_type)::text = 'yy'::text)) AND (upper((COALESCE(vendor, 'none'::character varying))::text) <> 'some_vendor'::text))
                     ->  Seq Scan on asset_records_p2
                           Filter: (active AND (((asset_type)::text = 'xx'::text) OR ((asset_type)::text = 'yy'::text)) AND (upper((COALESCE(vendor, 'none'::character varying))::text) <> 'some_vendor'::text))
                     ->  Seq Scan on asset_records_p3
                           Filter: (active AND (((asset_type)::text = 'xx'::text) OR ((asset_type)::text = 'yy'::text)) AND (upper((COALESCE(vendor, 'none'::character varying))::text) <> 'some_vendor'::text))
                     ->  Seq Scan on asset_records_p4
                           Filter: (active AND (((asset_type)::text = 'xx'::text) OR ((asset_type)::text = 'yy'::text)) AND (upper((COALESCE(vendor, 'none'::character varying))::text) <> 'some_vendor'::text))
                     ->  Seq Scan on asset_records_p5
                           Filter: (active AND (((asset_type)::text = 'xx'::text) OR ((asset_type)::text = 'yy'::text)) AND (upper((COALESCE(vendor, 'none'::character varying))::text) <> 'some_vendor'::text))
               ->  Hash
                     ->  Seq Scan on coverage
                           Filter: (vendor_sla IS NOT NULL)
(20 rows)

-- IndexApply-PartResolverExpand.mdp
-- from comment
create table x ( i text, j text, k text, m text)  ;
create table y ( i text, j text, k text, m text)
PARTITION BY RANGE(i);
CREATE TABLE y_p1 PARTITION of y for values from ('a') to ('a');
ERROR:  empty range bound specified for partition "y_p1"
DETAIL:  Specified lower bound ('a') is greater than or equal to upper bound ('a').
CREATE TABLE y_p2 PARTITION of y for values from ('a') to ('i');
CREATE TABLE y_p3 PARTITION of y for values from ('i') to ('q');
CREATE TABLE y_p4 PARTITION of y for values from ('q') to ('x');
CREATE TABLE y_deflt PARTITION of y default;
create INDEX y_idx on y (j);
set polar_px_optimizer_enable_indexjoin=on;
explain (costs off) select count(*) from x, y where (x.i > y.j AND x.j <= y.i);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Seq Scan on x
         ->  Append
               ->  Index Scan using y_p2_j_idx on y_p2
                     Index Cond: (x.i > j)
                     Filter: (x.j <= i)
               ->  Index Scan using y_p3_j_idx on y_p3
                     Index Cond: (x.i > j)
                     Filter: (x.j <= i)
               ->  Index Scan using y_p4_j_idx on y_p4
                     Index Cond: (x.i > j)
                     Filter: (x.j <= i)
               ->  Index Scan using y_deflt_j_idx on y_deflt
                     Index Cond: (x.i > j)
                     Filter: (x.j <= i)
(16 rows)

reset polar_px_optimizer_enable_indexjoin;
-- InferPredicatesBCC-vcpart-txt.mdp
-- from comment
create table infer_txt (a text);
insert into infer_txt select * from generate_series(1,1000);
analyze infer_txt;
CREATE TABLE infer_part_vc (id int, gender varchar(1))
  PARTITION BY LIST (gender);
CREATE TABLE girls PARTITION OF infer_part_vc FOR VALUES IN ('F');
CREATE TABLE boys PARTITION OF infer_part_vc FOR VALUES IN ('M');
CREATE TABLE other PARTITION OF infer_part_vc default;
insert into infer_part_vc select i, substring(i::varchar, 1, 1) from generate_series(1, 1000) i;
analyze infer_part_vc;
explain (costs off) select * from infer_part_vc inner join infer_txt on (infer_part_vc.gender = infer_txt.a) and infer_txt.a = 'M';
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   ->  Seq Scan on infer_txt
         Filter: (a = 'M'::text)
   ->  Append
         ->  Seq Scan on boys
               Filter: ((gender)::text = 'M'::text)
(6 rows)

-- NewBtreeIndexScanCost.mdp
-- from comment
CREATE TABLE oip (
    id bigint NOT NULL,
    oid bigint,
    cidr inet NOT NULL,
    state smallint,
    asn text,
    cc text,
    expire timestamp without time zone NOT NULL,
    ts timestamp without time zone NOT NULL,
    metadata json
) ;
CREATE TABLE ria (
    id bigint NOT NULL,
    ip inet,
    file_id bigint DEFAULT (-1),
    auth_filter_id bigint,
    oid bigint,
    event_id bigint,
    ip_source inet,
    arecord inet,
    subdomain text,
    asn character varying,
    cc character varying,
    ts timestamp without time zone,
    filter_match smallint,
    filter_match_id bigint
) ;
explain (costs off) select *  from oip oip  join ria a on ip=cidr and oip.oid=194073;
              QUERY PLAN              
--------------------------------------
 Hash Join
   Hash Cond: (a.ip = oip.cidr)
   ->  Seq Scan on ria a
   ->  Hash
         ->  Seq Scan on oip
               Filter: (oid = 194073)
(6 rows)

-- PartTbl-ArrayCoerce.mdp
-- from comment
CREATE TABLE pt (id int, gender varchar(2))
PARTITION BY LIST (gender);
CREATE TABLE girls PARTITION OF infer_part_vc FOR VALUES IN ('F');
ERROR:  relation "girls" already exists
CREATE TABLE boys PARTITION OF infer_part_vc FOR VALUES IN ('M');
ERROR:  relation "boys" already exists
CREATE TABLE other PARTITION OF infer_part_vc default;
ERROR:  relation "other" already exists
explain (costs off) select * from pt where gender in ( 'F', 'FM');
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- PartTbl-List-DPE-Varchar-Predicates.mdp
-- from comment
-- reuse DDL from previous test case
explain (costs off)
select * from pt where gender = 'F' union all
select * from pt where gender <= 'M' union all
select * from pt where gender in ('F', 'FM') union all
select * from pt where gender is null;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- PartTbl-RangeJoinPred.mdp
-- from comment (query) and dxl (ddl)
create table stg_xdr_crce_cdr(
  id bigint,
  sessioncreationtimestamp timestamptz,
  subscriberaddress varchar
)
partition by range(sessioncreationtimestamp);
CREATE TABLE stg_xdr_crce_cdr_p1 PARTITION of stg_xdr_crce_cdr for values from ('2010-01-01 00:00:00') to ('2011-01-01 00:00:00');
CREATE TABLE stg_xdr_crce_cdr_p2 PARTITION of stg_xdr_crce_cdr for values from ('2011-01-01 00:00:00') to ('2012-01-01 00:00:00');
create table dim_customer_device(
  imei varchar,
  msisdn varchar,
  start_dtm timestamptz,
  end_dtm timestamptz,
  mkt_model varchar
)
;
explain (costs off)
select *
from  (select subscriberaddress,sessioncreationtimestamp from stg_xdr_crce_cdr) f,
       dim_customer_device d
where d.msisdn=f.subscriberaddress and
      f.sessioncreationtimestamp >= d.start_dtm and
      f.sessioncreationtimestamp <d.end_dtm and
      (mkt_model like '%IPHONE%');
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((stg_xdr_crce_cdr_p1.subscriberaddress)::text = (d.msisdn)::text)
   Join Filter: ((stg_xdr_crce_cdr_p1.sessioncreationtimestamp >= d.start_dtm) AND (stg_xdr_crce_cdr_p1.sessioncreationtimestamp < d.end_dtm))
   ->  Append
         ->  Seq Scan on stg_xdr_crce_cdr_p1
         ->  Seq Scan on stg_xdr_crce_cdr_p2
   ->  Hash
         ->  Seq Scan on dim_customer_device d
               Filter: ((mkt_model)::text ~~ '%IPHONE%'::text)
(9 rows)

-- PartTbl-Relabel-Equality.mdp
-- from dxl
create table ds_4(
  month_id varchar,
  cust_group_acc numeric(5,2),
  mobile_no varchar
)
partition by list(month_id) (values('Jan', 'Feb', 'Mar'), values('Apr', 'May', 'Jun'));
ERROR:  syntax error at or near "("
LINE 6: partition by list(month_id) (values('Jan', 'Feb', 'Mar'), va...
                                    ^
CREATE TABLE ds_4_p1 PARTITION OF ds_4 FOR VALUES IN ('Jan', 'Feb', 'Mar');
ERROR:  relation "ds_4" does not exist
CREATE TABLE ds_4_p2 PARTITION OF ds_4 FOR VALUES IN ('Apr', 'May', 'Jun');
ERROR:  relation "ds_4" does not exist
explain (costs off)
select month_id, cust_group_acc, mobile_no
from ds_4
where month_id::text = 'Apr';
ERROR:  relation "ds_4" does not exist
LINE 3: from ds_4
             ^
-- PartTbl-Relabel-Range.mdp
-- from dxl
-- reuse DDL from previous example
-- currently falls back, "non-trivial part filter not supported"
explain (costs off)
select month_id, cust_group_acc, mobile_no
from ds_4
where month_id::text >= 'Feb' and month_id::text < 'Mar';
ERROR:  relation "ds_4" does not exist
LINE 3: from ds_4
             ^
-- retail_28.mdp
-- from comment (query) and dxl (ddl)
create table order_lineitems(
  order_id varchar,
  item_shipment_status_code varchar,
  order_datetime timestamp
)
partition by range(order_datetime);
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-01-01'::timestamp) to ('2010-02-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-01-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-02-01'::timestamp) to ('2010-03-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-02-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-03-01'::timestamp) to ('2010-04-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-03-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-04-01'::timestamp) to ('2010-05-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-04-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-05-01'::timestamp) to ('2010-06-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-05-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-06-01'::timestamp) to ('2010-07-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-06-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-07-01'::timestamp) to ('2010-08-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-07-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-08-01'::timestamp) to ('2010-09-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-08-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-10-01'::timestamp) to ('2010-10-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-10-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-11-01'::timestamp) to ('2010-11-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-11-01'::timestam...
                                                             ^
CREATE TABLE order_lineitems_p1 PARTITION of order_lineitems for values from ('2010-12-01'::timestamp) to ('2011-01-01'::timestamp);
ERROR:  syntax error at or near "::"
LINE 1: ...N of order_lineitems for values from ('2010-12-01'::timestam...
                                                             ^
-- currently falls back, "non-trivial part filter not supported"
explain (costs off)
SELECT to_char(order_datetime,'YYYY-Q') as ship_month
,      item_shipment_status_code
,      COUNT(DISTINCT order_id) AS num_orders
FROM   order_lineitems
WHERE  order_datetime BETWEEN timestamp '2010-04-01' AND date '2010-06-30'
GROUP BY to_char(order_datetime,'YYYY-Q')
,      item_shipment_status_code
ORDER BY to_char(order_datetime,'YYYY-Q')
,      item_shipment_status_code
;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 GroupAggregate
   Group Key: (to_char(order_datetime, 'YYYY-Q'::text)), item_shipment_status_code
   ->  Sort
         Sort Key: (to_char(order_datetime, 'YYYY-Q'::text)), item_shipment_status_code
         ->  Result
               One-Time Filter: false
(6 rows)

-- test partioned table with no partitions
create table no_part (a int, b int) partition by list (a) ;
select * from no_part;
 a | b 
---+---
(0 rows)

-- test casting with setops
with v(year) as (
    select 2019::float8 + dx from (VALUES (-1), (0), (0), (1), (1)) t(dx)
  except
    select 2019::int)
select * from v where year > 1;
 year 
------
 2020
 2018
(2 rows)

with v(year) as (
    select 2019::float8 + dx from (VALUES (-1), (0), (0), (1), (1)) t(dx)
  except all
    select 2019::int)
select * from v where year > 1;
 year 
------
 2020
 2020
 2018
 2019
(4 rows)

with v(year) as (
    select 2019::float8 + dx from (VALUES (-1), (0), (0), (1), (1)) t(dx)
  intersect
    select 2019::int)
select * from v where year > 1;
 year 
------
 2019
(1 row)

with v(year) as (
    select 2019::float8 + dx from (VALUES (-1), (0), (0), (1), (1)) t(dx)
  intersect all
    select 2019::int)
select * from v where year > 1;
 year 
------
 2019
(1 row)

reset polar_px_optimizer_trace_fallback;
create table tt_varchar(
	data character varying
);
insert into tt_varchar values('test');
create table tt_int(
	id integer
);
insert into tt_int values(1);
set polar_px_optimizer_enforce_subplans = 1;
-- test collation in subplan testexpr
select data from tt_varchar where data > any(select id::text from tt_int);
 data 
------
 test
(1 row)

                            QUERY PLAN                             
-------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tt_varchar.data
   ->  Partial Seq Scan on orca.tt_varchar
         Output: tt_varchar.data
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 Output: (tt_int.id)::text
                 ->  Materialize
                       Output: tt_int.id
                       ->  PX Broadcast 6:6  (slice2; segments: 6)
                             Output: tt_int.id
                             ->  Partial Seq Scan on orca.tt_int
                                   Output: tt_int.id
 Optimizer: PolarDB PX Optimizer
(15 rows)

-- test implicit coerce via io
CREATE CAST (integer AS text) WITH INOUT AS IMPLICIT;
select data from tt_varchar where data > any(select id from tt_int);
 data 
------
 test
(1 row)

                         QUERY PLAN                          
-------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: tt_varchar.data
   ->  Partial Seq Scan on orca.tt_varchar
         Output: tt_varchar.data
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Materialize
                 Output: tt_int.id
                 ->  PX Broadcast 6:6  (slice2; segments: 6)
                       Output: tt_int.id
                       ->  Partial Seq Scan on orca.tt_int
                             Output: tt_int.id
 Optimizer: PolarDB PX Optimizer
(13 rows)

DROP CAST (integer AS text);
reset polar_px_optimizer_enforce_subplans;
-- start_ignore
set client_min_messages='warning';
DROP SCHEMA orca CASCADE;
-- end_ignore
