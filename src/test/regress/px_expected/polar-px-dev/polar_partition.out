/*--EXPLAIN_QUERY_BEGIN*/
create schema polar_partition;
SET search_path to polar_partition;
------------------------------------------------------------------------
--hash partition
--Partition constraint: satisfies_hash_partition('16384'::oid, 3, 1, id)
drop table t0_hash cascade;
ERROR:  table "t0_hash" does not exist
CREATE TABLE t0_hash (id int, value int) PARTITION BY HASH(id);
CREATE TABLE t0_hash_p1 PARTITION OF t0_hash FOR VALUES WITH (modulus 3, remainder 0);
CREATE TABLE t0_hash_p2 PARTITION OF t0_hash FOR VALUES WITH (modulus 3, remainder 1);
CREATE TABLE t0_hash_p3 PARTITION OF t0_hash FOR VALUES WITH (modulus 3, remainder 2);
insert into t0_hash select generate_series(1,1000),generate_series(1,1000);
------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
drop table t1_range cascade;
ERROR:  table "t1_range" does not exist
CREATE TABLE t1_range(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE t1_range_p1 PARTITION OF t1_range FOR VALUES FROM (1) TO (10);
CREATE TABLE t1_range_p2 PARTITION OF t1_range FOR VALUES FROM (10) TO (100);
CREATE TABLE t1_range_p3 PARTITION OF t1_range DEFAULT;
insert into t1_range select generate_series(1,200, 2);
------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
drop table t2_list cascade;
ERROR:  table "t2_list" does not exist
create table t2_list(id int, value int) partition by list (id);
CREATE TABLE t2_list_p1 PARTITION OF t2_list FOR VALUES IN (1, 2, 3, 4, 5, 6, 7, 8, 9);
CREATE TABLE t2_list_p2 PARTITION OF t2_list FOR VALUES IN (11, 12, 13, 14, 15, 16, 17, 18, 19);
CREATE TABLE t2_list_p3 PARTITION OF t2_list DEFAULT;
insert into t2_list select generate_series(1,50, 2);
------------------------------------------------------------------------
--join normal
--hash join normal
--normal table
drop table t0 cascade;
ERROR:  table "t0" does not exist
CREATE TABLE t0 (id int, value int);
insert into t0 select generate_series(1,100, 2);
analyze;
set polar_px_dop_per_node =1;
set polar_px_optimizer_enable_hashjoin=0;
\i sql/polar-px-dev/polar_partition_query.sql
------------------------------------------------------------------------
--hash partition
--Partition constraint: satisfies_hash_partition('16384'::oid, 3, 1, id)
--one table
select * from  t0_hash where id =1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   Output: t0_hash_p3.id, t0_hash_p3.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p3.id, t0_hash_p3.value
         Merge Key: t0_hash_p3.id, t0_hash_p3.value
         ->  Sort
               Output: t0_hash_p3.id, t0_hash_p3.value
               Sort Key: t0_hash_p3.id, t0_hash_p3.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Filter: (t0_hash_p3.id = 1)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t0_hash where id =2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Filter: (t0_hash_p1.id = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t0_hash where id !=1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (t0_hash_p1.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (t0_hash_p2.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (t0_hash_p3.id <> 1)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id in (1, 2) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
(2 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Filter: (t0_hash_p1.id = ANY ('{1,2}'::integer[]))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Filter: (t0_hash_p3.id = ANY ('{1,2}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t0_hash where id not in (1, 3) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
 22 |    22
(20 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (t0_hash_p1.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (t0_hash_p2.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (t0_hash_p3.id <> ALL ('{1,3}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id =1 or id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
(2 rows)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Filter: ((t0_hash_p1.id = 1) OR (t0_hash_p1.id = 2))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Filter: ((t0_hash_p3.id = 1) OR (t0_hash_p3.id = 2))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t0_hash where id !=1 or id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
(20 rows)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: ((t0_hash_p1.id <> 1) OR (t0_hash_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: ((t0_hash_p2.id <> 1) OR (t0_hash_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: ((t0_hash_p3.id <> 1) OR (t0_hash_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id =1 and id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t0_hash where id !=1 and id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
 22 |    22
(20 rows)

                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: ((t0_hash_p1.id <> 1) AND (t0_hash_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: ((t0_hash_p2.id <> 1) AND (t0_hash_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: ((t0_hash_p3.id <> 1) AND (t0_hash_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id is null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t0_hash where id is not null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (NOT (t0_hash_p1.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (NOT (t0_hash_p2.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (NOT (t0_hash_p3.id IS NULL))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id > 1 and id < 3 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
(1 row)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Filter: ((t0_hash_p1.id > 1) AND (t0_hash_p1.id < 3))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p2
                           Output: t0_hash_p2.id, t0_hash_p2.value
                           Filter: ((t0_hash_p2.id > 1) AND (t0_hash_p2.id < 3))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Filter: ((t0_hash_p3.id > 1) AND (t0_hash_p3.id < 3))
 Optimizer: PolarDB PX Optimizer
(19 rows)

select * from  t0_hash where id > 1 and id < 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
  3 |     3
  4 |     4
(3 rows)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Filter: ((t0_hash_p1.id > 1) AND (t0_hash_p1.id < 5))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p2
                           Output: t0_hash_p2.id, t0_hash_p2.value
                           Filter: ((t0_hash_p2.id > 1) AND (t0_hash_p2.id < 5))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Filter: ((t0_hash_p3.id > 1) AND (t0_hash_p3.id < 5))
 Optimizer: PolarDB PX Optimizer
(19 rows)

select * from  t0_hash where id > 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
 22 |    22
 23 |    23
 24 |    24
 25 |    25
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (t0_hash_p1.id > 5)
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (t0_hash_p2.id > 5)
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (t0_hash_p3.id > 5)
 Optimizer: PolarDB PX Optimizer
(21 rows)

------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
--one table
select * from  t1_range where id =1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: (t1_range_p1.id = 1)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id =2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: (t1_range_p1.id = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id !=1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (t1_range_p1.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (t1_range_p2.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (t1_range_p3.id <> 1)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id in (1, 2) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: (t1_range_p1.id = ANY ('{1,2}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id not in (1, 3) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (t1_range_p1.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (t1_range_p2.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (t1_range_p3.id <> ALL ('{1,3}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id =1 or id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: ((t1_range_p1.id = 1) OR (t1_range_p1.id = 2))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id !=1 or id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: ((t1_range_p1.id <> 1) OR (t1_range_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: ((t1_range_p2.id <> 1) OR (t1_range_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: ((t1_range_p3.id <> 1) OR (t1_range_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id =1 and id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t1_range where id !=1 and id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: ((t1_range_p1.id <> 1) AND (t1_range_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: ((t1_range_p2.id <> 1) AND (t1_range_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: ((t1_range_p3.id <> 1) AND (t1_range_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id is null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 Limit
   Output: t1_range_p3.id, t1_range_p3.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p3.id, t1_range_p3.value
         Merge Key: t1_range_p3.id, t1_range_p3.value
         ->  Sort
               Output: t1_range_p3.id, t1_range_p3.value
               Sort Key: t1_range_p3.id, t1_range_p3.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p3
                           Output: t1_range_p3.id, t1_range_p3.value
                           Filter: (t1_range_p3.id IS NULL)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id is not null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (NOT (t1_range_p1.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (NOT (t1_range_p2.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (NOT (t1_range_p3.id IS NULL))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id > 1 and id < 3 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: ((t1_range_p1.id > 1) AND (t1_range_p1.id < 3))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id > 1 and id < 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
(1 row)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: ((t1_range_p1.id > 1) AND (t1_range_p1.id < 5))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id > 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
 45 |      
(20 rows)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (t1_range_p1.id > 5)
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (t1_range_p2.id > 5)
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (t1_range_p3.id > 5)
 Optimizer: PolarDB PX Optimizer
(21 rows)

------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
--one table
select * from  t2_list where id =1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: (t2_list_p1.id = 1)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id =2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: (t2_list_p1.id = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id !=1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (t2_list_p1.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (t2_list_p2.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (t2_list_p3.id <> 1)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id in (1, 2) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: (t2_list_p1.id = ANY ('{1,2}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id not in (1, 3) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
(20 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (t2_list_p1.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (t2_list_p2.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (t2_list_p3.id <> ALL ('{1,3}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id =1 or id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: ((t2_list_p1.id = 1) OR (t2_list_p1.id = 2))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id !=1 or id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: ((t2_list_p1.id <> 1) OR (t2_list_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: ((t2_list_p2.id <> 1) OR (t2_list_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: ((t2_list_p3.id <> 1) OR (t2_list_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id =1 and id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t2_list where id !=1 and id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: ((t2_list_p1.id <> 1) AND (t2_list_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: ((t2_list_p2.id <> 1) AND (t2_list_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: ((t2_list_p3.id <> 1) AND (t2_list_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id is null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   Output: t2_list_p3.id, t2_list_p3.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p3.id, t2_list_p3.value
         Merge Key: t2_list_p3.id, t2_list_p3.value
         ->  Sort
               Output: t2_list_p3.id, t2_list_p3.value
               Sort Key: t2_list_p3.id, t2_list_p3.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p3
                           Output: t2_list_p3.id, t2_list_p3.value
                           Filter: (t2_list_p3.id IS NULL)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id is not null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (NOT (t2_list_p1.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (NOT (t2_list_p2.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (NOT (t2_list_p3.id IS NULL))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id > 1 and id < 3 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: ((t2_list_p1.id > 1) AND (t2_list_p1.id < 3))
                     ->  Partial Seq Scan on polar_partition.t2_list_p3
                           Output: t2_list_p3.id, t2_list_p3.value
                           Filter: ((t2_list_p3.id > 1) AND (t2_list_p3.id < 3))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t2_list where id > 1 and id < 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
(1 row)

                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: ((t2_list_p1.id > 1) AND (t2_list_p1.id < 5))
                     ->  Partial Seq Scan on polar_partition.t2_list_p3
                           Output: t2_list_p3.id, t2_list_p3.value
                           Filter: ((t2_list_p3.id > 1) AND (t2_list_p3.id < 5))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t2_list where id > 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
 45 |      
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (t2_list_p1.id > 5)
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (t2_list_p2.id > 5)
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (t2_list_p3.id > 5)
 Optimizer: PolarDB PX Optimizer
(21 rows)

\i sql/polar-px-dev/polar_partition_join.sql
--hash join hash
/*--EXPLAIN_QUERY_BEGIN*/
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                                 Join Filter: (t0_hash_p1_1.id = t0_hash_p1.id)
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p2_1.id, t0_hash_p2_1.value, t0_hash_p2.id, t0_hash_p2.value
                                 Join Filter: (t0_hash_p2_1.id = t0_hash_p2.id)
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p3_1.id, t0_hash_p3_1.value, t0_hash_p3.id, t0_hash_p3.value
                                 Join Filter: (t0_hash_p3_1.id = t0_hash_p3.id)
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                                 Join Filter: (t0_hash_p1_1.id = t0_hash_p1.id)
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                           ->  Nested Loop
                                 Output: t0_hash_p2_1.id, t0_hash_p2_1.value, t0_hash_p2.id, t0_hash_p2.value
                                 Join Filter: (t0_hash_p2_1.id = t0_hash_p2.id)
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                           ->  Nested Loop
                                 Output: t0_hash_p3_1.id, t0_hash_p3_1.value, t0_hash_p3.id, t0_hash_p3.value
                                 Join Filter: (t0_hash_p3_1.id = t0_hash_p3.id)
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Result
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     ->  Sort
                           Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                           Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                                       Join Filter: (t0_hash_p1.id = t0_hash_p1_1.id)
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                             Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       ->  Full Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value, t0_hash_p2.id, t0_hash_p2.value
                                       Join Filter: (t0_hash_p2.id = t0_hash_p2_1.id)
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                             Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       ->  Full Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value, t0_hash_p3.id, t0_hash_p3.value
                                       Join Filter: (t0_hash_p3.id = t0_hash_p3_1.id)
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                             Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       ->  Full Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                           Merge Cond: (t0_hash_p1.id = t0_hash_p1_1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Sort Key: t0_hash_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Hash Key: t0_hash_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                                   Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                                   Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                                   Output: t0_hash_p3_1.id, t0_hash_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join range
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                                 Join Filter: (t1_range_p1_1.id = t1_range_p1.id)
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                           ->  Nested Loop Left Join
                                 Output: t1_range_p2_1.id, t1_range_p2_1.value, t1_range_p2.id, t1_range_p2.value
                                 Join Filter: (t1_range_p2_1.id = t1_range_p2.id)
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                           ->  Nested Loop Left Join
                                 Output: t1_range_p3_1.id, t1_range_p3_1.value, t1_range_p3.id, t1_range_p3.value
                                 Join Filter: (t1_range_p3_1.id = t1_range_p3.id)
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                                 Join Filter: (t1_range_p1_1.id = t1_range_p1.id)
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                           ->  Nested Loop
                                 Output: t1_range_p2_1.id, t1_range_p2_1.value, t1_range_p2.id, t1_range_p2.value
                                 Join Filter: (t1_range_p2_1.id = t1_range_p2.id)
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                           ->  Nested Loop
                                 Output: t1_range_p3_1.id, t1_range_p3_1.value, t1_range_p3.id, t1_range_p3.value
                                 Join Filter: (t1_range_p3_1.id = t1_range_p3.id)
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Result
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     ->  Sort
                           Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                           Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                                       Join Filter: (t1_range_p1.id = t1_range_p1_1.id)
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                             Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       ->  Full Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value, t1_range_p2.id, t1_range_p2.value
                                       Join Filter: (t1_range_p2.id = t1_range_p2_1.id)
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                             Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       ->  Full Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value, t1_range_p3.id, t1_range_p3.value
                                       Join Filter: (t1_range_p3.id = t1_range_p3_1.id)
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                             Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       ->  Full Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                           Merge Cond: (t1_range_p1.id = t1_range_p1_1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 Sort Key: t1_range_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Hash Key: t1_range_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                                   Output: t1_range_p1_1.id, t1_range_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                                   Output: t1_range_p2_1.id, t1_range_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                                   Output: t1_range_p3_1.id, t1_range_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--list join list
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: (t2_list_p1_1.id = t2_list_p1.id)
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                           ->  Nested Loop Left Join
                                 Output: t2_list_p2_1.id, t2_list_p2_1.value, t2_list_p2.id, t2_list_p2.value
                                 Join Filter: (t2_list_p2_1.id = t2_list_p2.id)
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                           ->  Nested Loop Left Join
                                 Output: t2_list_p3_1.id, t2_list_p3_1.value, t2_list_p3.id, t2_list_p3.value
                                 Join Filter: (t2_list_p3_1.id = t2_list_p3.id)
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: (t2_list_p1_1.id = t2_list_p1.id)
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                           ->  Nested Loop
                                 Output: t2_list_p2_1.id, t2_list_p2_1.value, t2_list_p2.id, t2_list_p2.value
                                 Join Filter: (t2_list_p2_1.id = t2_list_p2.id)
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                           ->  Nested Loop
                                 Output: t2_list_p3_1.id, t2_list_p3_1.value, t2_list_p3.id, t2_list_p3.value
                                 Join Filter: (t2_list_p3_1.id = t2_list_p3.id)
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Result
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     ->  Sort
                           Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                           Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                                       Join Filter: (t2_list_p1.id = t2_list_p1_1.id)
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                             Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       ->  Full Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value, t2_list_p2.id, t2_list_p2.value
                                       Join Filter: (t2_list_p2.id = t2_list_p2_1.id)
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                             Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       ->  Full Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value, t2_list_p3.id, t2_list_p3.value
                                       Join Filter: (t2_list_p3.id = t2_list_p3_1.id)
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                             Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       ->  Full Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                           Merge Cond: (t2_list_p1.id = t2_list_p1_1.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 Sort Key: t2_list_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Hash Key: t2_list_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                                   Output: t2_list_p1_1.id, t2_list_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                                   Output: t2_list_p2_1.id, t2_list_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                                   Output: t2_list_p3_1.id, t2_list_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join range
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t1_range_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(30 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Merge Cond: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join list
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(30 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join list
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(30 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t1_range_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join normal
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: (t1_range_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: (t1_range_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: (t1_range_p1.id = t0.id)
                           ->  Partial Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(27 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Merge Cond: (t1_range_p1.id = t0.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0.id, t0.value
                                       Hash Key: t0.id
                                       ->  Partial Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--list join normal
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: (t2_list_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: (t2_list_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: (t2_list_p1.id = t0.id)
                           ->  Partial Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(27 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Merge Cond: (t2_list_p1.id = t0.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0.id, t0.value
                                       Hash Key: t0.id
                                       ->  Partial Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash join normal
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: (t0_hash_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: (t0_hash_p1.id = t0.id)
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: (t0_hash_p1.id = t0.id)
                           ->  Partial Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(27 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Merge Cond: (t0_hash_p1.id = t0.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0.id, t0.value
                                       Hash Key: t0.id
                                       ->  Partial Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash, range join list
select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
left join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  2 |     2 |    |       |    |      
  3 |     3 |  3 |       |  3 |      
  4 |     4 |    |       |    |      
  5 |     5 |  5 |       |  5 |      
  6 |     6 |    |       |    |      
  7 |     7 |  7 |       |  7 |      
  8 |     8 |    |       |    |      
  9 |     9 |  9 |       |  9 |      
 10 |    10 |    |       |    |      
 11 |    11 | 11 |       | 11 |      
 12 |    12 |    |       |    |      
 13 |    13 | 13 |       | 13 |      
 14 |    14 |    |       |    |      
 15 |    15 | 15 |       | 15 |      
 16 |    16 |    |       |    |      
 17 |    17 | 17 |       | 17 |      
 18 |    18 |    |       |    |      
 19 |    19 | 19 |       | 19 |      
 20 |    20 |    |       |    |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Materialize
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  PX Broadcast 2:2  (slice3; segments: 2)
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(46 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
 join t2_list t2
on t1.id=t2.id
 join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                                 ->  Nested Loop
                                       Output: t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                                       Join Filter: (t1_range_p1.id = t2_list_p1.id)
                                       ->  PX Broadcast 2:2  (slice3; segments: 2)
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(42 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                       ->  Nested Loop Left Join
                                             Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                             Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                             ->  Materialize
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                                   ->  PX Broadcast 2:2  (slice3; segments: 2)
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                                     Output: t0_hash_p1.id, t0_hash_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                                     Output: t0_hash_p2.id, t0_hash_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                                     Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(46 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                       ->  Merge Full Join
                                             Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                             Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                                             ->  Sort
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                                   Sort Key: t0_hash_p1.id
                                                   ->  PX Hash 2:2  (slice3; segments: 2)
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         Hash Key: t0_hash_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                                     Output: t0_hash_p1.id, t0_hash_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                                     Output: t0_hash_p2.id, t0_hash_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                                     Output: t0_hash_p3.id, t0_hash_p3.value
                                             ->  Sort
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                                   Sort Key: t2_list_p1.id
                                                   ->  PX Hash 2:2  (slice4; segments: 2)
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                         Hash Key: t2_list_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                                     Output: t2_list_p1.id, t2_list_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                                     Output: t2_list_p2.id, t2_list_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                                     Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(54 rows)

--
explain (costs off)
select * from t1_range, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t1_range_p1
         ->  Seq Scan on t1_range_p2
         ->  Seq Scan on t1_range_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
(10 rows)

explain (costs off)
select * from t0_hash, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range, t2_list;
                   QUERY PLAN                   
------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
         ->  Materialize
               ->  Append
                     ->  Seq Scan on t2_list_p1
                     ->  Seq Scan on t2_list_p2
                     ->  Seq Scan on t2_list_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t0_hash_p1
               ->  Seq Scan on t0_hash_p2
               ->  Seq Scan on t0_hash_p3
(16 rows)

CREATE INDEX idx_t0_hash ON t0_hash USING btree (id);
CREATE INDEX idx_t1_range ON t1_range USING btree (id);
CREATE INDEX idx_t2_list ON t2_list USING btree (id);
CREATE INDEX idx_t0 ON t0 USING btree (id);
analyze;
\i sql/polar-px-dev/polar_partition_query.sql
------------------------------------------------------------------------
--hash partition
--Partition constraint: satisfies_hash_partition('16384'::oid, 3, 1, id)
--one table
select * from  t0_hash where id =1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
(1 row)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t0_hash_p3.id, t0_hash_p3.value
               ->  Append
                     ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                           Output: id, value
                           Index Cond: (t0_hash_p3.id = 1)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t0_hash where id =2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
(1 row)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                           Output: id, value
                           Index Cond: (t0_hash_p1.id = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t0_hash where id !=1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (t0_hash_p1.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (t0_hash_p2.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (t0_hash_p3.id <> 1)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id in (1, 2) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
(2 rows)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Bitmap Heap Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Recheck Cond: (t0_hash_p1.id = ANY ('{1,2}'::integer[]))
                           ->  Partial Bitmap Index Scan on t0_hash_p1_id_idx
                                 Index Cond: (t0_hash_p1.id = ANY ('{1,2}'::integer[]))
                     ->  Partial Bitmap Heap Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Recheck Cond: (t0_hash_p3.id = ANY ('{1,2}'::integer[]))
                           ->  Partial Bitmap Index Scan on t0_hash_p3_id_idx
                                 Index Cond: (t0_hash_p3.id = ANY ('{1,2}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(20 rows)

select * from  t0_hash where id not in (1, 3) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
 22 |    22
(20 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (t0_hash_p1.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (t0_hash_p2.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (t0_hash_p3.id <> ALL ('{1,3}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id =1 or id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
(2 rows)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Filter: ((t0_hash_p1.id = 1) OR (t0_hash_p1.id = 2))
                     ->  Partial Seq Scan on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Filter: ((t0_hash_p3.id = 1) OR (t0_hash_p3.id = 2))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t0_hash where id !=1 or id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
(20 rows)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: ((t0_hash_p1.id <> 1) OR (t0_hash_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: ((t0_hash_p2.id <> 1) OR (t0_hash_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: ((t0_hash_p3.id <> 1) OR (t0_hash_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id =1 and id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t0_hash where id !=1 and id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
 22 |    22
(20 rows)

                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: ((t0_hash_p1.id <> 1) AND (t0_hash_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: ((t0_hash_p2.id <> 1) AND (t0_hash_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: ((t0_hash_p3.id <> 1) AND (t0_hash_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id is null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t0_hash where id is not null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |     1
  2 |     2
  3 |     3
  4 |     4
  5 |     5
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Filter: (NOT (t0_hash_p1.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Filter: (NOT (t0_hash_p2.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Filter: (NOT (t0_hash_p3.id IS NULL))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t0_hash where id > 1 and id < 3 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
(1 row)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Index Cond: ((t0_hash_p1.id > 1) AND (t0_hash_p1.id < 3))
                     ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                           Output: t0_hash_p2.id, t0_hash_p2.value
                           Index Cond: ((t0_hash_p2.id > 1) AND (t0_hash_p2.id < 3))
                     ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Index Cond: ((t0_hash_p3.id > 1) AND (t0_hash_p3.id < 3))
 Optimizer: PolarDB PX Optimizer
(19 rows)

select * from  t0_hash where id > 1 and id < 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  2 |     2
  3 |     3
  4 |     4
(3 rows)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Sort
               Output: t0_hash_p1.id, t0_hash_p1.value
               Sort Key: t0_hash_p1.id, t0_hash_p1.value
               ->  Append
                     ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                           Output: t0_hash_p1.id, t0_hash_p1.value
                           Index Cond: ((t0_hash_p1.id > 1) AND (t0_hash_p1.id < 5))
                     ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                           Output: t0_hash_p2.id, t0_hash_p2.value
                           Index Cond: ((t0_hash_p2.id > 1) AND (t0_hash_p2.id < 5))
                     ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                           Output: t0_hash_p3.id, t0_hash_p3.value
                           Index Cond: ((t0_hash_p3.id > 1) AND (t0_hash_p3.id < 5))
 Optimizer: PolarDB PX Optimizer
(19 rows)

select * from  t0_hash where id > 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  6 |     6
  7 |     7
  8 |     8
  9 |     9
 10 |    10
 11 |    11
 12 |    12
 13 |    13
 14 |    14
 15 |    15
 16 |    16
 17 |    17
 18 |    18
 19 |    19
 20 |    20
 21 |    21
 22 |    22
 23 |    23
 24 |    24
 25 |    25
(20 rows)

                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1.value
                     ->  Append
                           ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Index Cond: (t0_hash_p1.id > 5)
                           ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                 Output: t0_hash_p2.id, t0_hash_p2.value
                                 Index Cond: (t0_hash_p2.id > 5)
                           ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                 Output: t0_hash_p3.id, t0_hash_p3.value
                                 Index Cond: (t0_hash_p3.id > 5)
 Optimizer: PolarDB PX Optimizer
(21 rows)

------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
--one table
select * from  t1_range where id =1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                           Output: id, value
                           Index Cond: (t1_range_p1.id = 1)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id =2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                           Output: id, value
                           Index Cond: (t1_range_p1.id = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id !=1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (t1_range_p1.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (t1_range_p2.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (t1_range_p3.id <> 1)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id in (1, 2) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Bitmap Heap Scan on polar_partition.t1_range_p1
                           Output: id, value
                           Recheck Cond: (t1_range_p1.id = ANY ('{1,2}'::integer[]))
                           ->  Partial Bitmap Index Scan on t1_range_p1_id_idx
                                 Index Cond: (t1_range_p1.id = ANY ('{1,2}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(15 rows)

select * from  t1_range where id not in (1, 3) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (t1_range_p1.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (t1_range_p2.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (t1_range_p3.id <> ALL ('{1,3}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id =1 or id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Sort
               Output: t1_range_p1.id, t1_range_p1.value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p1
                           Output: t1_range_p1.id, t1_range_p1.value
                           Filter: ((t1_range_p1.id = 1) OR (t1_range_p1.id = 2))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id !=1 or id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: ((t1_range_p1.id <> 1) OR (t1_range_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: ((t1_range_p2.id <> 1) OR (t1_range_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: ((t1_range_p3.id <> 1) OR (t1_range_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id =1 and id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t1_range where id !=1 and id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: ((t1_range_p1.id <> 1) AND (t1_range_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: ((t1_range_p2.id <> 1) AND (t1_range_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: ((t1_range_p3.id <> 1) AND (t1_range_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id is null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                               QUERY PLAN                                
-------------------------------------------------------------------------
 Limit
   Output: t1_range_p3.id, t1_range_p3.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p3.id, t1_range_p3.value
         Merge Key: t1_range_p3.id, t1_range_p3.value
         ->  Sort
               Output: t1_range_p3.id, t1_range_p3.value
               Sort Key: t1_range_p3.id, t1_range_p3.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t1_range_p3
                           Output: t1_range_p3.id, t1_range_p3.value
                           Filter: (t1_range_p3.id IS NULL)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id is not null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Filter: (NOT (t1_range_p1.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Filter: (NOT (t1_range_p2.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Filter: (NOT (t1_range_p3.id IS NULL))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t1_range where id > 1 and id < 3 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                           Output: id, value
                           Index Cond: ((t1_range_p1.id > 1) AND (t1_range_p1.id < 3))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id > 1 and id < 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
(1 row)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t1_range_p1.id, t1_range_p1.value
               ->  Append
                     ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                           Output: id, value
                           Index Cond: ((t1_range_p1.id > 1) AND (t1_range_p1.id < 5))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t1_range where id > 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
 45 |      
(20 rows)

                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1.id, t1_range_p1.value
                     ->  Append
                           ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Index Cond: (t1_range_p1.id > 5)
                           ->  Partial Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                 Output: t1_range_p2.id, t1_range_p2.value
                                 Index Cond: (t1_range_p2.id > 5)
                           ->  Partial Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                 Output: t1_range_p3.id, t1_range_p3.value
                                 Index Cond: (t1_range_p3.id > 5)
 Optimizer: PolarDB PX Optimizer
(21 rows)

------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
--one table
select * from  t2_list where id =1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                           Output: id, value
                           Index Cond: (t2_list_p1.id = 1)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id =2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                           Output: id, value
                           Index Cond: (t2_list_p1.id = 2)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id !=1 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (t2_list_p1.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (t2_list_p2.id <> 1)
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (t2_list_p3.id <> 1)
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id in (1, 2) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: id, value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: id, value
         Merge Key: id, value
         ->  Sort
               Output: id, value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Bitmap Heap Scan on polar_partition.t2_list_p1
                           Output: id, value
                           Recheck Cond: (t2_list_p1.id = ANY ('{1,2}'::integer[]))
                           ->  Partial Bitmap Index Scan on t2_list_p1_id_idx
                                 Index Cond: (t2_list_p1.id = ANY ('{1,2}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(15 rows)

select * from  t2_list where id not in (1, 3) ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
(20 rows)

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (t2_list_p1.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (t2_list_p2.id <> ALL ('{1,3}'::integer[]))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (t2_list_p3.id <> ALL ('{1,3}'::integer[]))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id =1 or id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Filter: ((t2_list_p1.id = 1) OR (t2_list_p1.id = 2))
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id !=1 or id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: ((t2_list_p1.id <> 1) OR (t2_list_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: ((t2_list_p2.id <> 1) OR (t2_list_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: ((t2_list_p3.id <> 1) OR (t2_list_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id =1 and id = 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

select * from  t2_list where id !=1 and id != 2 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
(20 rows)

                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: ((t2_list_p1.id <> 1) AND (t2_list_p1.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: ((t2_list_p2.id <> 1) AND (t2_list_p2.id <> 2))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: ((t2_list_p3.id <> 1) AND (t2_list_p3.id <> 2))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id is null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   Output: t2_list_p3.id, t2_list_p3.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p3.id, t2_list_p3.value
         Merge Key: t2_list_p3.id, t2_list_p3.value
         ->  Sort
               Output: t2_list_p3.id, t2_list_p3.value
               Sort Key: t2_list_p3.id, t2_list_p3.value
               ->  Append
                     ->  Partial Seq Scan on polar_partition.t2_list_p3
                           Output: t2_list_p3.id, t2_list_p3.value
                           Filter: (t2_list_p3.id IS NULL)
 Optimizer: PolarDB PX Optimizer
(13 rows)

select * from  t2_list where id is not null ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  1 |      
  3 |      
  5 |      
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
(20 rows)

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Seq Scan on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Filter: (NOT (t2_list_p1.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Filter: (NOT (t2_list_p2.id IS NULL))
                           ->  Partial Seq Scan on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Filter: (NOT (t2_list_p3.id IS NULL))
 Optimizer: PolarDB PX Optimizer
(21 rows)

select * from  t2_list where id > 1 and id < 3 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
(0 rows)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Index Cond: ((t2_list_p1.id > 1) AND (t2_list_p1.id < 3))
                     ->  Partial Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                           Output: t2_list_p3.id, t2_list_p3.value
                           Index Cond: ((t2_list_p3.id > 1) AND (t2_list_p3.id < 3))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t2_list where id > 1 and id < 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  3 |      
(1 row)

                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Sort
               Output: t2_list_p1.id, t2_list_p1.value
               Sort Key: t2_list_p1.id, t2_list_p1.value
               ->  Append
                     ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                           Output: t2_list_p1.id, t2_list_p1.value
                           Index Cond: ((t2_list_p1.id > 1) AND (t2_list_p1.id < 5))
                     ->  Partial Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                           Output: t2_list_p3.id, t2_list_p3.value
                           Index Cond: ((t2_list_p3.id > 1) AND (t2_list_p3.id < 5))
 Optimizer: PolarDB PX Optimizer
(16 rows)

select * from  t2_list where id > 5 ORDER BY 1, 2 limit 20;
 id | value 
----+-------
  7 |      
  9 |      
 11 |      
 13 |      
 15 |      
 17 |      
 19 |      
 21 |      
 23 |      
 25 |      
 27 |      
 29 |      
 31 |      
 33 |      
 35 |      
 37 |      
 39 |      
 41 |      
 43 |      
 45 |      
(20 rows)

                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1.id, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1.id, t2_list_p1.value
                     ->  Append
                           ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Index Cond: (t2_list_p1.id > 5)
                           ->  Partial Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                 Output: t2_list_p2.id, t2_list_p2.value
                                 Index Cond: (t2_list_p2.id > 5)
                           ->  Partial Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                 Output: t2_list_p3.id, t2_list_p3.value
                                 Index Cond: (t2_list_p3.id > 5)
 Optimizer: PolarDB PX Optimizer
(21 rows)

\i sql/polar-px-dev/polar_partition_join.sql
--hash join hash
/*--EXPLAIN_QUERY_BEGIN*/
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                           ->  Nested Loop
                                 Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                           ->  Nested Loop
                                 Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
               ->  Result
                     Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                     ->  Sort
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                           Sort Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                             Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                             Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                             Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                             Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                       ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                             Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                             Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(38 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                           Merge Cond: (t0_hash_p1.id = t0_hash_p1_1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Sort Key: t0_hash_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Hash Key: t0_hash_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                                   Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                                   Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                                   Output: t0_hash_p3_1.id, t0_hash_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join range
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                           ->  Nested Loop Left Join
                                 Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                           ->  Nested Loop
                                 Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                           ->  Nested Loop
                                 Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                 ->  Partial Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
               ->  Result
                     Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Sort
                           Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                           Sort Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                             Output: t1_range_p1_1.id, t1_range_p1_1.value
                                             Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                             Output: t1_range_p2_1.id, t1_range_p2_1.value
                                             Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                                       ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                             Output: t1_range_p3_1.id, t1_range_p3_1.value
                                             Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(38 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                           Merge Cond: (t1_range_p1.id = t1_range_p1_1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 Sort Key: t1_range_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Hash Key: t1_range_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                                   Output: t1_range_p1_1.id, t1_range_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                                   Output: t1_range_p2_1.id, t1_range_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                                   Output: t1_range_p3_1.id, t1_range_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--list join list
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                           ->  Nested Loop Left Join
                                 Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                 Join Filter: true
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                           ->  Nested Loop
                                 Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                           ->  Nested Loop
                                 Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                 ->  Partial Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
               ->  Result
                     Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                     ->  Sort
                           Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                           Sort Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                             Output: t2_list_p1_1.id, t2_list_p1_1.value
                                             Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                             Output: t2_list_p2_1.id, t2_list_p2_1.value
                                             Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                       Join Filter: true
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                                       ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                             Output: t2_list_p3_1.id, t2_list_p3_1.value
                                             Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(38 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                           Merge Cond: (t2_list_p1.id = t2_list_p1_1.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 Sort Key: t2_list_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Hash Key: t2_list_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                                   Output: t2_list_p1_1.id, t2_list_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                                   Output: t2_list_p2_1.id, t2_list_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                                   Output: t2_list_p3_1.id, t2_list_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join range
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t1_range_p1.id)
                                 ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t1_range_p1.id)
                                 ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t1_range_p1.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t1_range_p1.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Merge Cond: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join list
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Append
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Index Cond: (t2_list_p1.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                       Index Cond: (t2_list_p2.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                       Index Cond: (t2_list_p3.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                 ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join list
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Index Cond: (t2_list_p1.id = t1_range_p1.id)
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                       Index Cond: (t2_list_p2.id = t1_range_p1.id)
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                       Index Cond: (t2_list_p3.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Partial Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Partial Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t1_range_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join normal
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t0.id)
                                 ->  Partial Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t0.id)
                                 ->  Partial Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Partial Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t0.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t0.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Merge Cond: (t1_range_p1.id = t0.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0.id, t0.value
                                       Hash Key: t0.id
                                       ->  Partial Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--list join normal
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Partial Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Partial Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Index Cond: (t2_list_p1.id = t0.id)
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                       Index Cond: (t2_list_p2.id = t0.id)
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                       Index Cond: (t2_list_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Merge Cond: (t2_list_p1.id = t0.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0.id, t0.value
                                       Hash Key: t0.id
                                       ->  Partial Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash join normal
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t0.id)
                                 ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t0.id)
                                 ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Partial Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t0.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t0.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Merge Cond: (t0_hash_p1.id = t0.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0.id, t0.value
                                       Hash Key: t0.id
                                       ->  Partial Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash, range join list
select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
left join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  2 |     2 |    |       |    |      
  3 |     3 |  3 |       |  3 |      
  4 |     4 |    |       |    |      
  5 |     5 |  5 |       |  5 |      
  6 |     6 |    |       |    |      
  7 |     7 |  7 |       |  7 |      
  8 |     8 |    |       |    |      
  9 |     9 |  9 |       |  9 |      
 10 |    10 |    |       |    |      
 11 |    11 | 11 |       | 11 |      
 12 |    12 |    |       |    |      
 13 |    13 | 13 |       | 13 |      
 14 |    14 |    |       |    |      
 15 |    15 | 15 |       | 15 |      
 16 |    16 |    |       |    |      
 17 |    17 | 17 |       | 17 |      
 18 |    18 |    |       |    |      
 19 |    19 | 19 |       | 19 |      
 20 |    20 |    |       |    |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: true
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Append
                                       ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             Index Cond: (t2_list_p1.id = t0_hash_p1.id)
                                       ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                             Index Cond: (t2_list_p2.id = t0_hash_p1.id)
                                       ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                                             Index Cond: (t2_list_p3.id = t0_hash_p1.id)
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(44 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
 join t2_list t2
on t1.id=t2.id
 join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                                 ->  Nested Loop
                                       Output: t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                                       Join Filter: true
                                       ->  PX Broadcast 2:2  (slice3; segments: 2)
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                       ->  Append
                                             ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                                   Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                             ->  Partial Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                                   Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                             ->  Partial Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                                                   Index Cond: (t1_range_p3.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                 ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(48 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                       ->  Nested Loop Left Join
                                             Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                             Join Filter: true
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                             ->  Append
                                                   ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                                   ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                                         Output: t0_hash_p2.id, t0_hash_p2.value
                                                         Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                                   ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                                         Output: t0_hash_p3.id, t0_hash_p3.value
                                                         Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(45 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                       ->  Merge Full Join
                                             Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                             Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                                             ->  Sort
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                                   Sort Key: t0_hash_p1.id
                                                   ->  PX Hash 2:2  (slice3; segments: 2)
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         Hash Key: t0_hash_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                                     Output: t0_hash_p1.id, t0_hash_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                                     Output: t0_hash_p2.id, t0_hash_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                                     Output: t0_hash_p3.id, t0_hash_p3.value
                                             ->  Sort
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                                   Sort Key: t2_list_p1.id
                                                   ->  PX Hash 2:2  (slice4; segments: 2)
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                         Hash Key: t2_list_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                                     Output: t2_list_p1.id, t2_list_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                                     Output: t2_list_p2.id, t2_list_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                                     Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(54 rows)

--
explain (costs off)
select * from t1_range, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t1_range_p1
         ->  Seq Scan on t1_range_p2
         ->  Seq Scan on t1_range_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
(10 rows)

explain (costs off)
select * from t0_hash, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range, t2_list;
                   QUERY PLAN                   
------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
         ->  Materialize
               ->  Append
                     ->  Seq Scan on t2_list_p1
                     ->  Seq Scan on t2_list_p2
                     ->  Seq Scan on t2_list_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t0_hash_p1
               ->  Seq Scan on t0_hash_p2
               ->  Seq Scan on t0_hash_p3
(16 rows)

set polar_px_optimizer_share_tablescan_factor=0.9;
set polar_px_optimizer_share_indexscan_factor=0.9;
\i sql/polar-px-dev/polar_partition_join.sql
--hash join hash
/*--EXPLAIN_QUERY_BEGIN*/
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                           ->  Nested Loop
                                 Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                           ->  Nested Loop
                                 Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
               ->  Result
                     Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                     ->  Sort
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                           Sort Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                             Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                             Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                             Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                             Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                       ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                             Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                             Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(38 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                           Merge Cond: (t0_hash_p1.id = t0_hash_p1_1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Sort Key: t0_hash_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Hash Key: t0_hash_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                                   Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                                   Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                                   Output: t0_hash_p3_1.id, t0_hash_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join range
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                           ->  Nested Loop Left Join
                                 Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                           ->  Nested Loop
                                 Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                           ->  Nested Loop
                                 Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
               ->  Result
                     Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Sort
                           Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                           Sort Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                             Output: t1_range_p1_1.id, t1_range_p1_1.value
                                             Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                             Output: t1_range_p2_1.id, t1_range_p2_1.value
                                             Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                                       ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                             Output: t1_range_p3_1.id, t1_range_p3_1.value
                                             Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(38 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                           Merge Cond: (t1_range_p1.id = t1_range_p1_1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 Sort Key: t1_range_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Hash Key: t1_range_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                                   Output: t1_range_p1_1.id, t1_range_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                                   Output: t1_range_p2_1.id, t1_range_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                                   Output: t1_range_p3_1.id, t1_range_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--list join list
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                           ->  Nested Loop Left Join
                                 Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                           ->  Nested Loop
                                 Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                           ->  Nested Loop
                                 Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
               ->  Result
                     Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                     ->  Sort
                           Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                           Sort Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                             Output: t2_list_p1_1.id, t2_list_p1_1.value
                                             Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                             Output: t2_list_p2_1.id, t2_list_p2_1.value
                                             Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                       Join Filter: true
                                       ->  Full Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                                       ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                             Output: t2_list_p3_1.id, t2_list_p3_1.value
                                             Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(38 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                           Merge Cond: (t2_list_p1.id = t2_list_p1_1.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 Sort Key: t2_list_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Hash Key: t2_list_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                                   Output: t2_list_p1_1.id, t2_list_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                                   Output: t2_list_p2_1.id, t2_list_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                                   Output: t2_list_p3_1.id, t2_list_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join range
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:1  (slice2; segments: 2)
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t1_range_p1.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t1_range_p1.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t1_range_p1.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t1_range_p1.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Merge Cond: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join list
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Append
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Index Cond: (t2_list_p1.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                       Index Cond: (t2_list_p2.id = t0_hash_p1.id)
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                       Index Cond: (t2_list_p3.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:1  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join list
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Index Cond: (t2_list_p1.id = t1_range_p1.id)
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                       Index Cond: (t2_list_p2.id = t1_range_p1.id)
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                       Index Cond: (t2_list_p3.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  PX Broadcast 2:1  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(31 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t1_range_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join normal
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t0.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t0.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t0.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t0.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Merge Cond: (t1_range_p1.id = t0.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  Result
                                       Output: t0.id, t0.value
                                       HashFilter: workers=2, nattrs=1
                                       ->  Full Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--list join normal
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  PX Broadcast 2:1  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Index Cond: (t2_list_p1.id = t0.id)
                                 ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                       Index Cond: (t2_list_p2.id = t0.id)
                                 ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                       Index Cond: (t2_list_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Merge Cond: (t2_list_p1.id = t0.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  Result
                                       Output: t0.id, t0.value
                                       HashFilter: workers=2, nattrs=1
                                       ->  Full Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash join normal
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Full Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(24 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t0.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t0.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Append
                                 ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Index Cond: (t0_hash_p1.id = t0.id)
                                 ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                       Index Cond: (t0_hash_p2.id = t0.id)
                                 ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                       Index Cond: (t0_hash_p3.id = t0.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Merge Cond: (t0_hash_p1.id = t0.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  Result
                                       Output: t0.id, t0.value
                                       HashFilter: workers=2, nattrs=1
                                       ->  Full Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash, range join list
select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
left join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  2 |     2 |    |       |    |      
  3 |     3 |  3 |       |  3 |      
  4 |     4 |    |       |    |      
  5 |     5 |  5 |       |  5 |      
  6 |     6 |    |       |    |      
  7 |     7 |  7 |       |  7 |      
  8 |     8 |    |       |    |      
  9 |     9 |  9 |       |  9 |      
 10 |    10 |    |       |    |      
 11 |    11 | 11 |       | 11 |      
 12 |    12 |    |       |    |      
 13 |    13 | 13 |       | 13 |      
 14 |    14 |    |       |    |      
 15 |    15 | 15 |       | 15 |      
 16 |    16 |    |       |    |      
 17 |    17 | 17 |       | 17 |      
 18 |    18 |    |       |    |      
 19 |    19 | 19 |       | 19 |      
 20 |    20 |    |       |    |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: true
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Append
                                       ->  Full Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             Index Cond: (t2_list_p1.id = t0_hash_p1.id)
                                       ->  Full Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                             Index Cond: (t2_list_p2.id = t0_hash_p1.id)
                                       ->  Full Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                                             Index Cond: (t2_list_p3.id = t0_hash_p1.id)
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(44 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
 join t2_list t2
on t1.id=t2.id
 join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: true
                           ->  Nested Loop
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: true
                                 ->  PX Broadcast 2:1  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                                 ->  Append
                                       ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                             Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                       ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                             Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                       ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                             Index Cond: (t0_hash_p3.id = t2_list_p1.id)
                           ->  Append
                                 ->  Full Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Index Cond: (t1_range_p1.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                       Index Cond: (t1_range_p2.id = t2_list_p1.id)
                                 ->  Full Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                       Index Cond: (t1_range_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(46 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                       ->  Nested Loop Left Join
                                             Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                             Join Filter: true
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                             ->  Append
                                                   ->  Full Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         Index Cond: (t0_hash_p1.id = t2_list_p1.id)
                                                   ->  Full Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2
                                                         Output: t0_hash_p2.id, t0_hash_p2.value
                                                         Index Cond: (t0_hash_p2.id = t2_list_p1.id)
                                                   ->  Full Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3
                                                         Output: t0_hash_p3.id, t0_hash_p3.value
                                                         Index Cond: (t0_hash_p3.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(45 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                       ->  Merge Full Join
                                             Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                             Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                                             ->  Sort
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                                   Sort Key: t0_hash_p1.id
                                                   ->  PX Hash 2:2  (slice3; segments: 2)
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         Hash Key: t0_hash_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                                     Output: t0_hash_p1.id, t0_hash_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                                     Output: t0_hash_p2.id, t0_hash_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                                     Output: t0_hash_p3.id, t0_hash_p3.value
                                             ->  Sort
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                                   Sort Key: t2_list_p1.id
                                                   ->  PX Hash 2:2  (slice4; segments: 2)
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                         Hash Key: t2_list_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                                     Output: t2_list_p1.id, t2_list_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                                     Output: t2_list_p2.id, t2_list_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                                     Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(54 rows)

--
explain (costs off)
select * from t1_range, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t1_range_p1
         ->  Seq Scan on t1_range_p2
         ->  Seq Scan on t1_range_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
(10 rows)

explain (costs off)
select * from t0_hash, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range, t2_list;
                   QUERY PLAN                   
------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
         ->  Materialize
               ->  Append
                     ->  Seq Scan on t2_list_p1
                     ->  Seq Scan on t2_list_p2
                     ->  Seq Scan on t2_list_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t0_hash_p1
               ->  Seq Scan on t0_hash_p2
               ->  Seq Scan on t0_hash_p3
(16 rows)

set polar_px_optimizer_enable_dynamicindexscan=0;
set polar_px_optimizer_enable_shareindexscan=0;
set polar_px_optimizer_enable_dynamicshareindexscan=0;
\i sql/polar-px-dev/polar_partition_join.sql
--hash join hash
/*--EXPLAIN_QUERY_BEGIN*/
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
         Merge Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
         ->  Limit
               Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
               ->  Sort
                     Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                     Sort Key: t0_hash_p1_1.id, t0_hash_p1.id, t0_hash_p1_1.value, t0_hash_p1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                                 Join Filter: (t0_hash_p1_1.id = t0_hash_p1.id)
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p2_1.id, t0_hash_p2_1.value, t0_hash_p2.id, t0_hash_p2.value
                                 Join Filter: (t0_hash_p2_1.id = t0_hash_p2.id)
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p3_1.id, t0_hash_p3_1.value, t0_hash_p3.id, t0_hash_p3.value
                                 Join Filter: (t0_hash_p3_1.id = t0_hash_p3.id)
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Index Scan using t0_hash_p1_id_idx on polar_partition.t0_hash_p1 t0_hash_p1_1
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Index Cond: (t0_hash_p1_1.id = t0_hash_p1.id)
                           ->  Nested Loop
                                 Output: t0_hash_p2.id, t0_hash_p2.value, t0_hash_p2_1.id, t0_hash_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Index Scan using t0_hash_p2_id_idx on polar_partition.t0_hash_p2 t0_hash_p2_1
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       Index Cond: (t0_hash_p2_1.id = t0_hash_p2.id)
                           ->  Nested Loop
                                 Output: t0_hash_p3.id, t0_hash_p3.value, t0_hash_p3_1.id, t0_hash_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Partial Index Scan using t0_hash_p3_id_idx on polar_partition.t0_hash_p3 t0_hash_p3_1
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       Index Cond: (t0_hash_p3_1.id = t0_hash_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Result
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     ->  Sort
                           Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                           Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value, t0_hash_p1.id, t0_hash_p1.value
                                       Join Filter: (t0_hash_p1.id = t0_hash_p1_1.id)
                                       ->  Full Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                             Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       ->  Full Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p2_1.id, t0_hash_p2_1.value, t0_hash_p2.id, t0_hash_p2.value
                                       Join Filter: (t0_hash_p2.id = t0_hash_p2_1.id)
                                       ->  Full Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                             Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                       ->  Full Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Nested Loop Left Join
                                       Output: t0_hash_p3_1.id, t0_hash_p3_1.value, t0_hash_p3.id, t0_hash_p3.value
                                       Join Filter: (t0_hash_p3.id = t0_hash_p3_1.id)
                                       ->  Full Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                             Output: t0_hash_p3_1.id, t0_hash_p3_1.value
                                       ->  Full Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0_hash t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |     1
  2 |     2 |  2 |     2
  3 |     3 |  3 |     3
  4 |     4 |  4 |     4
  5 |     5 |  5 |     5
  6 |     6 |  6 |     6
  7 |     7 |  7 |     7
  8 |     8 |  8 |     8
  9 |     9 |  9 |     9
 10 |    10 | 10 |    10
 11 |    11 | 11 |    11
 12 |    12 | 12 |    12
 13 |    13 | 13 |    13
 14 |    14 | 14 |    14
 15 |    15 | 15 |    15
 16 |    16 | 16 |    16
 17 |    17 | 17 |    17
 18 |    18 | 18 |    18
 19 |    19 | 19 |    19
 20 |    20 | 20 |    20
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
         Merge Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                     Sort Key: t0_hash_p1.id, t0_hash_p1_1.id, t0_hash_p1.value, t0_hash_p1_1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0_hash_p1_1.id, t0_hash_p1_1.value
                           Merge Cond: (t0_hash_p1.id = t0_hash_p1_1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                 Sort Key: t0_hash_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                       Hash Key: t0_hash_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1 t0_hash_p1_1
                                                   Output: t0_hash_p1_1.id, t0_hash_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2 t0_hash_p2_1
                                                   Output: t0_hash_p2_1.id, t0_hash_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3 t0_hash_p3_1
                                                   Output: t0_hash_p3_1.id, t0_hash_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join range
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
         ->  Limit
               Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t1_range_p1_1.id, t1_range_p1.id, t1_range_p1_1.value, t1_range_p1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                                 Join Filter: (t1_range_p1_1.id = t1_range_p1.id)
                                 ->  Full Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                           ->  Nested Loop Left Join
                                 Output: t1_range_p2_1.id, t1_range_p2_1.value, t1_range_p2.id, t1_range_p2.value
                                 Join Filter: (t1_range_p2_1.id = t1_range_p2.id)
                                 ->  Full Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                           ->  Nested Loop Left Join
                                 Output: t1_range_p3_1.id, t1_range_p3_1.value, t1_range_p3.id, t1_range_p3.value
                                 Join Filter: (t1_range_p3_1.id = t1_range_p3.id)
                                 ->  Full Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Index Scan using t1_range_p1_id_idx on polar_partition.t1_range_p1 t1_range_p1_1
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Index Cond: (t1_range_p1_1.id = t1_range_p1.id)
                           ->  Nested Loop
                                 Output: t1_range_p2.id, t1_range_p2.value, t1_range_p2_1.id, t1_range_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Index Scan using t1_range_p2_id_idx on polar_partition.t1_range_p2 t1_range_p2_1
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       Index Cond: (t1_range_p2_1.id = t1_range_p2.id)
                           ->  Nested Loop
                                 Output: t1_range_p3.id, t1_range_p3.value, t1_range_p3_1.id, t1_range_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                                 ->  Partial Index Scan using t1_range_p3_id_idx on polar_partition.t1_range_p3 t1_range_p3_1
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       Index Cond: (t1_range_p3_1.id = t1_range_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Result
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     ->  Sort
                           Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                           Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value, t1_range_p1.id, t1_range_p1.value
                                       Join Filter: (t1_range_p1.id = t1_range_p1_1.id)
                                       ->  Full Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                             Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       ->  Full Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p2_1.id, t1_range_p2_1.value, t1_range_p2.id, t1_range_p2.value
                                       Join Filter: (t1_range_p2.id = t1_range_p2_1.id)
                                       ->  Full Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                             Output: t1_range_p2_1.id, t1_range_p2_1.value
                                       ->  Full Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Nested Loop Left Join
                                       Output: t1_range_p3_1.id, t1_range_p3_1.value, t1_range_p3.id, t1_range_p3.value
                                       Join Filter: (t1_range_p3.id = t1_range_p3_1.id)
                                       ->  Full Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                             Output: t1_range_p3_1.id, t1_range_p3_1.value
                                       ->  Full Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
         Merge Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                     Sort Key: t1_range_p1.id, t1_range_p1_1.id, t1_range_p1.value, t1_range_p1_1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t1_range_p1_1.id, t1_range_p1_1.value
                           Merge Cond: (t1_range_p1.id = t1_range_p1_1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t1_range_p1_1.id, t1_range_p1_1.value
                                 Sort Key: t1_range_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1_1.id, t1_range_p1_1.value
                                       Hash Key: t1_range_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1 t1_range_p1_1
                                                   Output: t1_range_p1_1.id, t1_range_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2 t1_range_p2_1
                                                   Output: t1_range_p2_1.id, t1_range_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3 t1_range_p3_1
                                                   Output: t1_range_p3_1.id, t1_range_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--list join list
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
         ->  Limit
               Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t2_list_p1_1.id, t2_list_p1.id, t2_list_p1_1.value, t2_list_p1.value
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: (t2_list_p1_1.id = t2_list_p1.id)
                                 ->  Full Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                           ->  Nested Loop Left Join
                                 Output: t2_list_p2_1.id, t2_list_p2_1.value, t2_list_p2.id, t2_list_p2.value
                                 Join Filter: (t2_list_p2_1.id = t2_list_p2.id)
                                 ->  Full Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                           ->  Nested Loop Left Join
                                 Output: t2_list_p3_1.id, t2_list_p3_1.value, t2_list_p3.id, t2_list_p3.value
                                 Join Filter: (t2_list_p3_1.id = t2_list_p3.id)
                                 ->  Full Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(33 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Append
                           ->  Nested Loop
                                 Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Index Scan using t2_list_p1_id_idx on polar_partition.t2_list_p1 t2_list_p1_1
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Index Cond: (t2_list_p1_1.id = t2_list_p1.id)
                           ->  Nested Loop
                                 Output: t2_list_p2.id, t2_list_p2.value, t2_list_p2_1.id, t2_list_p2_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Index Scan using t2_list_p2_id_idx on polar_partition.t2_list_p2 t2_list_p2_1
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       Index Cond: (t2_list_p2_1.id = t2_list_p2.id)
                           ->  Nested Loop
                                 Output: t2_list_p3.id, t2_list_p3.value, t2_list_p3_1.id, t2_list_p3_1.value
                                 Join Filter: true
                                 ->  Full Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                                 ->  Partial Index Scan using t2_list_p3_id_idx on polar_partition.t2_list_p3 t2_list_p3_1
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       Index Cond: (t2_list_p3_1.id = t2_list_p3.id)
 Optimizer: PolarDB PX Optimizer
(36 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Result
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     ->  Sort
                           Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                           Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value, t2_list_p1.id, t2_list_p1.value
                                       Join Filter: (t2_list_p1.id = t2_list_p1_1.id)
                                       ->  Full Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                             Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       ->  Full Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p2_1.id, t2_list_p2_1.value, t2_list_p2.id, t2_list_p2.value
                                       Join Filter: (t2_list_p2.id = t2_list_p2_1.id)
                                       ->  Full Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                             Output: t2_list_p2_1.id, t2_list_p2_1.value
                                       ->  Full Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Nested Loop Left Join
                                       Output: t2_list_p3_1.id, t2_list_p3_1.value, t2_list_p3.id, t2_list_p3.value
                                       Join Filter: (t2_list_p3.id = t2_list_p3_1.id)
                                       ->  Full Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                             Output: t2_list_p3_1.id, t2_list_p3_1.value
                                       ->  Full Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
         Merge Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                     Sort Key: t2_list_p1.id, t2_list_p1_1.id, t2_list_p1.value, t2_list_p1_1.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t2_list_p1_1.id, t2_list_p1_1.value
                           Merge Cond: (t2_list_p1.id = t2_list_p1_1.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t2_list_p1_1.id, t2_list_p1_1.value
                                 Sort Key: t2_list_p1_1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1_1.id, t2_list_p1_1.value
                                       Hash Key: t2_list_p1_1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1 t2_list_p1_1
                                                   Output: t2_list_p1_1.id, t2_list_p1_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2 t2_list_p2_1
                                                   Output: t2_list_p2_1.id, t2_list_p2_1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3 t2_list_p3_1
                                                   Output: t2_list_p3_1.id, t2_list_p3_1.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join range
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t1_range_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(30 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t1_range t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t1_range_p1.id, t0_hash_p1.value, t1_range_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t1_range_p1.id, t1_range_p1.value
                           Merge Cond: (t0_hash_p1.id = t1_range_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--hash join list
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(30 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join list
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(30 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(32 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t2_list t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
         Merge Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                     Sort Key: t1_range_p1.id, t2_list_p1.id, t1_range_p1.value, t2_list_p1.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t2_list_p1.id, t2_list_p1.value
                           Merge Cond: (t1_range_p1.id = t2_list_p1.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice3; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(40 rows)

--range join normal
select t1.id, t1.value, t2.id, t2.value
from t1_range t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: (t1_range_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t1_range_p1
                                             Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p2
                                             Output: t1_range_p2.id, t1_range_p2.value
                                       ->  Partial Seq Scan on polar_partition.t1_range_p3
                                             Output: t1_range_p3.id, t1_range_p3.value
                           ->  Partial Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t1_range_p1.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Join Filter: (t1_range_p1.id = t0.id)
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:1  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(27 rows)

select t1.id, t1.value, t2.id, t2.value
from t1_range t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit
   Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
         Merge Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
         ->  Limit
               Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                     Sort Key: t1_range_p1.id, t0.id, t1_range_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t1_range_p1.id, t1_range_p1.value, t0.id, t0.value
                           Merge Cond: (t1_range_p1.id = t0.id)
                           ->  Sort
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 Sort Key: t1_range_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       Hash Key: t1_range_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  Result
                                       Output: t0.id, t0.value
                                       HashFilter: workers=2, nattrs=1
                                       ->  Full Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--list join normal
select t1.id, t1.value, t2.id, t2.value
from t2_list t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: (t2_list_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t2_list_p1
                                       Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p2
                                       Output: t2_list_p2.id, t2_list_p2.value
                                 ->  Partial Seq Scan on polar_partition.t2_list_p3
                                       Output: t2_list_p3.id, t2_list_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t2_list_p1
                                             Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p2
                                             Output: t2_list_p2.id, t2_list_p2.value
                                       ->  Partial Seq Scan on polar_partition.t2_list_p3
                                             Output: t2_list_p3.id, t2_list_p3.value
                           ->  Partial Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t2_list_p1.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Join Filter: (t2_list_p1.id = t0.id)
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:1  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(27 rows)

select t1.id, t1.value, t2.id, t2.value
from t2_list t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |       |  1 |      
  3 |       |  3 |      
  5 |       |  5 |      
  7 |       |  7 |      
  9 |       |  9 |      
 11 |       | 11 |      
 13 |       | 13 |      
 15 |       | 15 |      
 17 |       | 17 |      
 19 |       | 19 |      
 21 |       | 21 |      
 23 |       | 23 |      
 25 |       | 25 |      
 27 |       | 27 |      
 29 |       | 29 |      
 31 |       | 31 |      
 33 |       | 33 |      
 35 |       | 35 |      
 37 |       | 37 |      
 39 |       | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
         Merge Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
         ->  Limit
               Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                     Sort Key: t2_list_p1.id, t0.id, t2_list_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t2_list_p1.id, t2_list_p1.value, t0.id, t0.value
                           Merge Cond: (t2_list_p1.id = t0.id)
                           ->  Sort
                                 Output: t2_list_p1.id, t2_list_p1.value
                                 Sort Key: t2_list_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       Hash Key: t2_list_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                   Output: t2_list_p2.id, t2_list_p2.value
                                             ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                   Output: t2_list_p3.id, t2_list_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  Result
                                       Output: t0.id, t0.value
                                       HashFilter: workers=2, nattrs=1
                                       ->  Full Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash join normal
select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
left join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: (t0_hash_p1.id = t0.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(23 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: true
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Partial Index Scan using idx_t0 on polar_partition.t0
                                 Output: t0.id, t0.value
                                 Index Cond: (t0.id = t0_hash_p1.id)
 Optimizer: PolarDB PX Optimizer
(26 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
right join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  3 |     3 |  3 |      
  5 |     5 |  5 |      
  7 |     7 |  7 |      
  9 |     9 |  9 |      
 11 |    11 | 11 |      
 13 |    13 | 13 |      
 15 |    15 | 15 |      
 17 |    17 | 17 |      
 19 |    19 | 19 |      
 21 |    21 | 21 |      
 23 |    23 | 23 |      
 25 |    25 | 25 |      
 27 |    27 | 27 |      
 29 |    29 | 29 |      
 31 |    31 | 31 |      
 33 |    33 | 33 |      
 35 |    35 | 35 |      
 37 |    37 | 37 |      
 39 |    39 | 39 |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 1:1  (slice1; segments: 1)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Join Filter: (t0_hash_p1.id = t0.id)
                           ->  Full Seq Scan on polar_partition.t0
                                 Output: t0.id, t0.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:1  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(27 rows)

select t1.id, t1.value, t2.id, t2.value
from t0_hash t1
full outer join t0 t2
on t1.id=t2.id
order by t1.id, t2.id, t1.value, t2.value
limit 20;
 id | value | id | value 
----+-------+----+-------
  1 |     1 |  1 |      
  2 |     2 |    |      
  3 |     3 |  3 |      
  4 |     4 |    |      
  5 |     5 |  5 |      
  6 |     6 |    |      
  7 |     7 |  7 |      
  8 |     8 |    |      
  9 |     9 |  9 |      
 10 |    10 |    |      
 11 |    11 | 11 |      
 12 |    12 |    |      
 13 |    13 | 13 |      
 14 |    14 |    |      
 15 |    15 | 15 |      
 16 |    16 |    |      
 17 |    17 | 17 |      
 18 |    18 |    |      
 19 |    19 | 19 |      
 20 |    20 |    |      
(20 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
         Merge Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                     Sort Key: t0_hash_p1.id, t0.id, t0_hash_p1.value, t0.value
                     ->  Merge Full Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t0.id, t0.value
                           Merge Cond: (t0_hash_p1.id = t0.id)
                           ->  Sort
                                 Output: t0_hash_p1.id, t0_hash_p1.value
                                 Sort Key: t0_hash_p1.id
                                 ->  PX Hash 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                       Hash Key: t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                   Output: t0_hash_p2.id, t0_hash_p2.value
                                             ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                   Output: t0_hash_p3.id, t0_hash_p3.value
                           ->  Sort
                                 Output: t0.id, t0.value
                                 Sort Key: t0.id
                                 ->  Result
                                       Output: t0.id, t0.value
                                       HashFilter: workers=2, nattrs=1
                                       ->  Full Seq Scan on polar_partition.t0
                                             Output: t0.id, t0.value
 Optimizer: PolarDB PX Optimizer
(35 rows)

--hash, range join list
select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
left join t2_list t2
on t1.id=t2.id
left join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  2 |     2 |    |       |    |      
  3 |     3 |  3 |       |  3 |      
  4 |     4 |    |       |    |      
  5 |     5 |  5 |       |  5 |      
  6 |     6 |    |       |    |      
  7 |     7 |  7 |       |  7 |      
  8 |     8 |    |       |    |      
  9 |     9 |  9 |       |  9 |      
 10 |    10 |    |       |    |      
 11 |    11 | 11 |       | 11 |      
 12 |    12 |    |       |    |      
 13 |    13 | 13 |       | 13 |      
 14 |    14 |    |       |    |      
 15 |    15 | 15 |       | 15 |      
 16 |    16 |    |       |    |      
 17 |    17 | 17 |       | 17 |      
 18 |    18 |    |       |    |      
 19 |    19 | 19 |       | 19 |      
 20 |    20 |    |       |    |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Nested Loop Left Join
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                                 ->  Append
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                             Output: t0_hash_p1.id, t0_hash_p1.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                             Output: t0_hash_p2.id, t0_hash_p2.value
                                       ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                             Output: t0_hash_p3.id, t0_hash_p3.value
                                 ->  Materialize
                                       Output: t2_list_p1.id, t2_list_p1.value
                                       ->  PX Broadcast 2:2  (slice3; segments: 2)
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                           ->  Materialize
                                 Output: t1_range_p1.id, t1_range_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t1_range_p1.id, t1_range_p1.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
 Optimizer: PolarDB PX Optimizer
(46 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
 join t2_list t2
on t1.id=t2.id
 join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                           ->  PX Broadcast 2:2  (slice2; segments: 2)
                                 Output: t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                                 ->  Nested Loop
                                       Output: t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                                       Join Filter: (t1_range_p1.id = t2_list_p1.id)
                                       ->  PX Broadcast 2:2  (slice3; segments: 2)
                                             Output: t2_list_p1.id, t2_list_p1.value
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                       ->  Append
                                             ->  Partial Seq Scan on polar_partition.t1_range_p1
                                                   Output: t1_range_p1.id, t1_range_p1.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p2
                                                   Output: t1_range_p2.id, t1_range_p2.value
                                             ->  Partial Seq Scan on polar_partition.t1_range_p3
                                                   Output: t1_range_p3.id, t1_range_p3.value
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                       Output: t0_hash_p1.id, t0_hash_p1.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                       Output: t0_hash_p2.id, t0_hash_p2.value
                                 ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                       Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(42 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
right join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                       ->  Nested Loop Left Join
                                             Output: t2_list_p1.id, t2_list_p1.value, t0_hash_p1.id, t0_hash_p1.value
                                             Join Filter: (t0_hash_p1.id = t2_list_p1.id)
                                             ->  Append
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                         Output: t2_list_p2.id, t2_list_p2.value
                                                   ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                         Output: t2_list_p3.id, t2_list_p3.value
                                             ->  Materialize
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                                   ->  PX Broadcast 2:2  (slice3; segments: 2)
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                                     Output: t0_hash_p1.id, t0_hash_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                                     Output: t0_hash_p2.id, t0_hash_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                                     Output: t0_hash_p3.id, t0_hash_p3.value
 Optimizer: PolarDB PX Optimizer
(46 rows)

select t1.id, t1.value, t2.id, t2.value, t3.id, t3.value
from t0_hash t1
full outer join t2_list t2
on t1.id=t2.id
right join t1_range t3
on t3.id=t2.id
order by t1.id, t2.id, t1.value, t2.value, t3.id, t3.value
limit 20;
 id | value | id | value | id | value 
----+-------+----+-------+----+-------
  1 |     1 |  1 |       |  1 |      
  3 |     3 |  3 |       |  3 |      
  5 |     5 |  5 |       |  5 |      
  7 |     7 |  7 |       |  7 |      
  9 |     9 |  9 |       |  9 |      
 11 |    11 | 11 |       | 11 |      
 13 |    13 | 13 |       | 13 |      
 15 |    15 | 15 |       | 15 |      
 17 |    17 | 17 |       | 17 |      
 19 |    19 | 19 |       | 19 |      
 21 |    21 | 21 |       | 21 |      
 23 |    23 | 23 |       | 23 |      
 25 |    25 | 25 |       | 25 |      
 27 |    27 | 27 |       | 27 |      
 29 |    29 | 29 |       | 29 |      
 31 |    31 | 31 |       | 31 |      
 33 |    33 | 33 |       | 33 |      
 35 |    35 | 35 |       | 35 |      
 37 |    37 | 37 |       | 37 |      
 39 |    39 | 39 |       | 39 |      
(20 rows)

                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
   ->  PX Coordinator 2:1  (slice1; segments: 2)
         Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         Merge Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
         ->  Limit
               Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
               ->  Sort
                     Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     Sort Key: t0_hash_p1.id, t2_list_p1.id, t0_hash_p1.value, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                     ->  Nested Loop Left Join
                           Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value, t1_range_p1.id, t1_range_p1.value
                           Join Filter: (t1_range_p1.id = t2_list_p1.id)
                           ->  Append
                                 ->  Partial Seq Scan on polar_partition.t1_range_p1
                                       Output: t1_range_p1.id, t1_range_p1.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p2
                                       Output: t1_range_p2.id, t1_range_p2.value
                                 ->  Partial Seq Scan on polar_partition.t1_range_p3
                                       Output: t1_range_p3.id, t1_range_p3.value
                           ->  Materialize
                                 Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                 ->  PX Broadcast 2:2  (slice2; segments: 2)
                                       Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                       ->  Merge Full Join
                                             Output: t0_hash_p1.id, t0_hash_p1.value, t2_list_p1.id, t2_list_p1.value
                                             Merge Cond: (t0_hash_p1.id = t2_list_p1.id)
                                             ->  Sort
                                                   Output: t0_hash_p1.id, t0_hash_p1.value
                                                   Sort Key: t0_hash_p1.id
                                                   ->  PX Hash 2:2  (slice3; segments: 2)
                                                         Output: t0_hash_p1.id, t0_hash_p1.value
                                                         Hash Key: t0_hash_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p1
                                                                     Output: t0_hash_p1.id, t0_hash_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p2
                                                                     Output: t0_hash_p2.id, t0_hash_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t0_hash_p3
                                                                     Output: t0_hash_p3.id, t0_hash_p3.value
                                             ->  Sort
                                                   Output: t2_list_p1.id, t2_list_p1.value
                                                   Sort Key: t2_list_p1.id
                                                   ->  PX Hash 2:2  (slice4; segments: 2)
                                                         Output: t2_list_p1.id, t2_list_p1.value
                                                         Hash Key: t2_list_p1.id
                                                         ->  Append
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p1
                                                                     Output: t2_list_p1.id, t2_list_p1.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p2
                                                                     Output: t2_list_p2.id, t2_list_p2.value
                                                               ->  Partial Seq Scan on polar_partition.t2_list_p3
                                                                     Output: t2_list_p3.id, t2_list_p3.value
 Optimizer: PolarDB PX Optimizer
(54 rows)

--
explain (costs off)
select * from t1_range, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t1_range_p1
         ->  Seq Scan on t1_range_p2
         ->  Seq Scan on t1_range_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
(10 rows)

explain (costs off)
select * from t0_hash, t2_list;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on t0_hash_p1
         ->  Seq Scan on t0_hash_p2
         ->  Seq Scan on t0_hash_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t2_list_p1
               ->  Seq Scan on t2_list_p2
               ->  Seq Scan on t2_list_p3
(10 rows)

explain (costs off)
select * from t0_hash, t1_range, t2_list;
                   QUERY PLAN                   
------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Append
               ->  Seq Scan on t1_range_p1
               ->  Seq Scan on t1_range_p2
               ->  Seq Scan on t1_range_p3
         ->  Materialize
               ->  Append
                     ->  Seq Scan on t2_list_p1
                     ->  Seq Scan on t2_list_p2
                     ->  Seq Scan on t2_list_p3
   ->  Materialize
         ->  Append
               ->  Seq Scan on t0_hash_p1
               ->  Seq Scan on t0_hash_p2
               ->  Seq Scan on t0_hash_p3
(16 rows)

set client_min_messages='warning';
drop schema polar_partition cascade;
