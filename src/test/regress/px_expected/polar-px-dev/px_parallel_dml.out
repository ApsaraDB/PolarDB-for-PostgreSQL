-- config
/*--POLAR_ENABLE_PX*/
set client_min_messages to error;
set polar_enable_px = 1;
set polar_px_enable_insert_select = 1;
set polar_px_optimizer_enable_dml_constraints = 1;
set polar_px_enable_insert_order_sensitive = 0;
create function dml_explain_filter(text) returns setof text
language plpgsql as
$$
declare
    ln text;
begin
    for ln in execute $1
    loop
        -- Replace any actual rows with just 'N'
        ln := regexp_replace(ln, 'actual rows=\d+\M', 'actual rows=N', 'g');
        -- In sort output, the above won't match units-suffixed numbers
        ln := regexp_replace(ln, '\m\d+kB', 'NkB', 'g');
        return next ln;
    end loop;
end;
$$;
-- create table
\i sql/polar-px-dev/px_parallel_dml_init.sql
-- create normal table
drop table if exists px_parallel_dml_t1 cascade;
CREATE TABLE px_parallel_dml_t1 (c1 int, c2 int) ;
insert into px_parallel_dml_t1 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t2 cascade;
CREATE TABLE px_parallel_dml_t2 (c1 int, c2 int) ;
insert into px_parallel_dml_t2 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t3 cascade;
CREATE TABLE px_parallel_dml_t3 (c1 int, c2 int) ;
insert into px_parallel_dml_t3 select generate_series(1,1000),generate_series(1,1000);
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

-- create partition table
drop table if exists px_parallel_dml_t0_hash_insert cascade;
CREATE TABLE px_parallel_dml_t0_hash_insert (id int, value int) PARTITION BY HASH(id);
drop table if exists px_parallel_dml_t0_insert cascade;
CREATE TABLE px_parallel_dml_t0_insert (id int, value int);
drop table if exists px_parallel_dml_t0_select_table cascade;
CREATE TABLE px_parallel_dml_t0_select_table (id int, value int);
insert into px_parallel_dml_t0_select_table select generate_series(1,12000),generate_series(1,12000);
drop table if exists px_parallel_dml_t0_select_list_table cascade;
CREATE TABLE px_parallel_dml_t0_select_list_table (status character varying(30), value int);
-- PX Insert... Select from Partition Table
------------------------------------------------------------------------
-- Create partition table
drop table if exists px_parallel_dml_t0_hash cascade;
CREATE TABLE px_parallel_dml_t0_hash (id int, value int) PARTITION BY HASH(id);
CREATE TABLE px_parallel_dml_t0_hash_p1 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 0);
CREATE TABLE px_parallel_dml_t0_hash_p2 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 1);
CREATE TABLE px_parallel_dml_t0_hash_p3 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 2);
insert into px_parallel_dml_t0_hash select generate_series(1,30000),generate_series(1,30000);
------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
drop table if exists px_parallel_dml_t1_range cascade;
CREATE TABLE px_parallel_dml_t1_range(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3 PARTITION OF px_parallel_dml_t1_range DEFAULT;
insert into px_parallel_dml_t1_range select generate_series(1,30000, 2);
--range partition with INDEX
drop table if exists px_parallel_dml_t1_range_index cascade;
CREATE TABLE px_parallel_dml_t1_range_index(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3_index PARTITION OF px_parallel_dml_t1_range_index DEFAULT;
insert into px_parallel_dml_t1_range_index select generate_series(1,30000, 2);
CREATE INDEX px_parallel_dml_t1_partition_index on px_parallel_dml_t1_range_index(id);
------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
drop table if exists px_parallel_dml_t2_list cascade;
create table px_parallel_dml_t2_list(job character varying(30), pvalue int) partition by list (job);
CREATE TABLE px_parallel_dml_t2_list_p1 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('student');
CREATE TABLE px_parallel_dml_t2_list_p2 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('teacher');
CREATE TABLE px_parallel_dml_t2_list_p3 PARTITION OF px_parallel_dml_t2_list DEFAULT;
insert into px_parallel_dml_t2_list select 'student',generate_series(1,10000);
insert into px_parallel_dml_t2_list select 'teacher',generate_series(10000,20000);
insert into px_parallel_dml_t2_list select 'other',generate_series(20000,30000);
-- Index Test Init
drop table if exists px_parallel_dml_t4 cascade;
CREATE TABLE px_parallel_dml_t4 (c1 int, c2 int) ;
insert into px_parallel_dml_t4 select generate_series(1,1000),generate_series(1,1000);
CREATE INDEX t_index_plan on px_parallel_dml_t4(c1);
-- Constrain Test Init
drop table if exists px_parallel_dml_t5 cascade;
CREATE TABLE px_parallel_dml_t5 (c1 int, c2 int not NULL) ;
drop table if exists px_parallel_dml_t6 cascade;
CREATE TABLE px_parallel_dml_t6 (c1 int, c2 int) ;
---- Insert into table with default num
drop table if exists px_parallel_dml_t8 cascade;
CREATE TABLE px_parallel_dml_t8(
c1 int,
c2 int DEFAULT 99999,
c3 varchar DEFAULT NULL,
c4 timestamp default '2016-06-22 19:10:25-07'
);
drop table if exists px_parallel_dml_t9 cascade;
CREATE TABLE px_parallel_dml_t9 (c1 int, c2 int) ;
insert into px_parallel_dml_t9 select generate_series(1,20),generate_series(1,20);
/*--EXPLAIN_QUERY_BEGIN*/
-- Slow SQL, Only once
-- Delete
EXPLAIN (VERBOSE, COSTS OFF) delete from px_parallel_dml_t2 as px_parallel_dml_t0 where px_parallel_dml_t0.c1 < (select c2 from px_parallel_dml_t1 order by c2 LIMIT 1);
                           QUERY PLAN                           
----------------------------------------------------------------
 Delete on public.px_parallel_dml_t2 px_parallel_dml_t0
   InitPlan 1 (returns $0)
     ->  Limit
           Output: px_parallel_dml_t1.c2
           ->  Sort
                 Output: px_parallel_dml_t1.c2
                 Sort Key: px_parallel_dml_t1.c2
                 ->  Seq Scan on public.px_parallel_dml_t1
                       Output: px_parallel_dml_t1.c2
   ->  Seq Scan on public.px_parallel_dml_t2 px_parallel_dml_t0
         Output: px_parallel_dml_t0.ctid
         Filter: (px_parallel_dml_t0.c1 < $0)
(12 rows)

delete from px_parallel_dml_t2 as px_parallel_dml_t0 where px_parallel_dml_t0.c1 < (select c2 from px_parallel_dml_t1 order by c2 LIMIT 1);
EXPLAIN (VERBOSE, COSTS OFF) delete from px_parallel_dml_t1 as px_parallel_dml_t0 where px_parallel_dml_t0.c1 < (select c2 from px_parallel_dml_t2 order by c2 LIMIT 1);
                           QUERY PLAN                           
----------------------------------------------------------------
 Delete on public.px_parallel_dml_t1 px_parallel_dml_t0
   InitPlan 1 (returns $0)
     ->  Limit
           Output: px_parallel_dml_t2.c2
           ->  Sort
                 Output: px_parallel_dml_t2.c2
                 Sort Key: px_parallel_dml_t2.c2
                 ->  Seq Scan on public.px_parallel_dml_t2
                       Output: px_parallel_dml_t2.c2
   ->  Seq Scan on public.px_parallel_dml_t1 px_parallel_dml_t0
         Output: px_parallel_dml_t0.ctid
         Filter: (px_parallel_dml_t0.c1 < $0)
(12 rows)

delete from px_parallel_dml_t1 as px_parallel_dml_t0 where px_parallel_dml_t0.c1 < (select c2 from px_parallel_dml_t2 order by c2 LIMIT 1);
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Update
EXPLAIN (VERBOSE, COSTS OFF) update px_parallel_dml_t2 set c1 = px_parallel_dml_t1.c2 from px_parallel_dml_t1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Update on public.px_parallel_dml_t2
   ->  Nested Loop
         Output: px_parallel_dml_t1.c2, px_parallel_dml_t2.c2, px_parallel_dml_t2.ctid, px_parallel_dml_t1.ctid
         ->  Seq Scan on public.px_parallel_dml_t2
               Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.ctid
         ->  Materialize
               Output: px_parallel_dml_t1.c2, px_parallel_dml_t1.ctid
               ->  Seq Scan on public.px_parallel_dml_t1
                     Output: px_parallel_dml_t1.c2, px_parallel_dml_t1.ctid
(9 rows)

update px_parallel_dml_t2 set c1 = px_parallel_dml_t1.c2 from px_parallel_dml_t1;
EXPLAIN (VERBOSE, COSTS OFF) update px_parallel_dml_t1 set c1 = px_parallel_dml_t2.c2 from px_parallel_dml_t2;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Update on public.px_parallel_dml_t1
   ->  Nested Loop
         Output: px_parallel_dml_t2.c2, px_parallel_dml_t1.c2, px_parallel_dml_t1.ctid, px_parallel_dml_t2.ctid
         ->  Seq Scan on public.px_parallel_dml_t1
               Output: px_parallel_dml_t1.c2, px_parallel_dml_t1.ctid
         ->  Materialize
               Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.ctid
               ->  Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.ctid
(9 rows)

update px_parallel_dml_t1 set c1 = px_parallel_dml_t2.c2 from px_parallel_dml_t2;
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) update px_parallel_dml_t2 set c2 = px_parallel_dml_t1.c2 from px_parallel_dml_t1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Update on public.px_parallel_dml_t2
   ->  Nested Loop
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t1.c2, px_parallel_dml_t2.ctid, px_parallel_dml_t1.ctid
         ->  Seq Scan on public.px_parallel_dml_t2
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.ctid
         ->  Materialize
               Output: px_parallel_dml_t1.c2, px_parallel_dml_t1.ctid
               ->  Seq Scan on public.px_parallel_dml_t1
                     Output: px_parallel_dml_t1.c2, px_parallel_dml_t1.ctid
(9 rows)

update px_parallel_dml_t2 set c2 = px_parallel_dml_t1.c2 from px_parallel_dml_t1;
EXPLAIN (VERBOSE, COSTS OFF) update px_parallel_dml_t1 set c2 = px_parallel_dml_t2.c2 from px_parallel_dml_t2;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Update on public.px_parallel_dml_t1
   ->  Nested Loop
         Output: px_parallel_dml_t1.c1, px_parallel_dml_t2.c2, px_parallel_dml_t1.ctid, px_parallel_dml_t2.ctid
         ->  Seq Scan on public.px_parallel_dml_t2
               Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.ctid
         ->  Materialize
               Output: px_parallel_dml_t1.c1, px_parallel_dml_t1.ctid
               ->  Seq Scan on public.px_parallel_dml_t1
                     Output: px_parallel_dml_t1.c1, px_parallel_dml_t1.ctid
(9 rows)

update px_parallel_dml_t1 set c2 = px_parallel_dml_t2.c2 from px_parallel_dml_t2;
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- One Writer worker
set polar_px_insert_dop_num = 1;
\i sql/polar-px-dev/px_parallel_dml_init.sql
-- create normal table
drop table if exists px_parallel_dml_t1 cascade;
CREATE TABLE px_parallel_dml_t1 (c1 int, c2 int) ;
insert into px_parallel_dml_t1 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t2 cascade;
CREATE TABLE px_parallel_dml_t2 (c1 int, c2 int) ;
insert into px_parallel_dml_t2 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t3 cascade;
CREATE TABLE px_parallel_dml_t3 (c1 int, c2 int) ;
insert into px_parallel_dml_t3 select generate_series(1,1000),generate_series(1,1000);
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- create partition table
drop table if exists px_parallel_dml_t0_hash_insert cascade;
CREATE TABLE px_parallel_dml_t0_hash_insert (id int, value int) PARTITION BY HASH(id);
drop table if exists px_parallel_dml_t0_insert cascade;
CREATE TABLE px_parallel_dml_t0_insert (id int, value int);
drop table if exists px_parallel_dml_t0_select_table cascade;
CREATE TABLE px_parallel_dml_t0_select_table (id int, value int);
insert into px_parallel_dml_t0_select_table select generate_series(1,12000),generate_series(1,12000);
drop table if exists px_parallel_dml_t0_select_list_table cascade;
CREATE TABLE px_parallel_dml_t0_select_list_table (status character varying(30), value int);
-- PX Insert... Select from Partition Table
------------------------------------------------------------------------
-- Create partition table
drop table if exists px_parallel_dml_t0_hash cascade;
CREATE TABLE px_parallel_dml_t0_hash (id int, value int) PARTITION BY HASH(id);
CREATE TABLE px_parallel_dml_t0_hash_p1 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 0);
CREATE TABLE px_parallel_dml_t0_hash_p2 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 1);
CREATE TABLE px_parallel_dml_t0_hash_p3 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 2);
insert into px_parallel_dml_t0_hash select generate_series(1,30000),generate_series(1,30000);
------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
drop table if exists px_parallel_dml_t1_range cascade;
CREATE TABLE px_parallel_dml_t1_range(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3 PARTITION OF px_parallel_dml_t1_range DEFAULT;
insert into px_parallel_dml_t1_range select generate_series(1,30000, 2);
--range partition with INDEX
drop table if exists px_parallel_dml_t1_range_index cascade;
CREATE TABLE px_parallel_dml_t1_range_index(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3_index PARTITION OF px_parallel_dml_t1_range_index DEFAULT;
insert into px_parallel_dml_t1_range_index select generate_series(1,30000, 2);
CREATE INDEX px_parallel_dml_t1_partition_index on px_parallel_dml_t1_range_index(id);
------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
drop table if exists px_parallel_dml_t2_list cascade;
create table px_parallel_dml_t2_list(job character varying(30), pvalue int) partition by list (job);
CREATE TABLE px_parallel_dml_t2_list_p1 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('student');
CREATE TABLE px_parallel_dml_t2_list_p2 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('teacher');
CREATE TABLE px_parallel_dml_t2_list_p3 PARTITION OF px_parallel_dml_t2_list DEFAULT;
insert into px_parallel_dml_t2_list select 'student',generate_series(1,10000);
insert into px_parallel_dml_t2_list select 'teacher',generate_series(10000,20000);
insert into px_parallel_dml_t2_list select 'other',generate_series(20000,30000);
-- Index Test Init
drop table if exists px_parallel_dml_t4 cascade;
CREATE TABLE px_parallel_dml_t4 (c1 int, c2 int) ;
insert into px_parallel_dml_t4 select generate_series(1,1000),generate_series(1,1000);
CREATE INDEX t_index_plan on px_parallel_dml_t4(c1);
-- Constrain Test Init
drop table if exists px_parallel_dml_t5 cascade;
CREATE TABLE px_parallel_dml_t5 (c1 int, c2 int not NULL) ;
drop table if exists px_parallel_dml_t6 cascade;
CREATE TABLE px_parallel_dml_t6 (c1 int, c2 int) ;
---- Insert into table with default num
drop table if exists px_parallel_dml_t8 cascade;
CREATE TABLE px_parallel_dml_t8(
c1 int,
c2 int DEFAULT 99999,
c3 varchar DEFAULT NULL,
c4 timestamp default '2016-06-22 19:10:25-07'
);
drop table if exists px_parallel_dml_t9 cascade;
CREATE TABLE px_parallel_dml_t9 (c1 int, c2 int) ;
insert into px_parallel_dml_t9 select generate_series(1,20),generate_series(1,20);
\i sql/polar-px-dev/px_parallel_dml_base.sql
-- Insert
insert into px_parallel_dml_t1 select generate_series(1,60),generate_series(1,60);
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
                           QUERY PLAN                           
----------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(1, 60), generate_series(1, 60)
         ->  Result
(4 rows)

insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
select count(*) from px_parallel_dml_t1;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t1');
                                              dml_explain_filter                                              
--------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (actual rows=N loops=1)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1
         ->  PX Coordinator 6:1  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t1_1.c1, px_parallel_dml_t1_1.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t1 px_parallel_dml_t1_1 (actual rows=N loops=1)
                     Output: px_parallel_dml_t1_1.c1, px_parallel_dml_t1_1.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1;
select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2');
                                   dml_explain_filter                                    
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (actual rows=N loops=1)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1
         ->  PX Coordinator 6:1  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2 (actual rows=N loops=1)
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1280
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   480
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2 where c1 = '1';
insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1 where c1 = '1';
select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   502
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

set polar_px_enable_insert_from_tableless=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 VALUES(100,100);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 100, 100
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 VALUES(200,200);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 200, 200
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select 1,2;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 1, 2
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select 3,4;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 3, 4
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(201,250), c2 from px_parallel_dml_t2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (generate_series(201, 250)), px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2, (generate_series(201, 250))
               ->  Result
                     Output: px_parallel_dml_t2.c2, (generate_series(201, 250))
                     ->  ProjectSet
                           Output: generate_series(201, 250), px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(12 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(301,350),generate_series(301,350) union select * from px_parallel_dml_t3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  HashAggregate
         Output: (generate_series(301, 350)), (generate_series(301, 350))
         Group Key: (generate_series(301, 350)), (generate_series(301, 350))
         ->  Append
               ->  ProjectSet
                     Output: generate_series(301, 350), generate_series(301, 350)
                     ->  Result
               ->  Seq Scan on public.px_parallel_dml_t3
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
(10 rows)

-- Use PX Insert
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Assert Op DML
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Hash Join
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         Hash Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c2)
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  Hash
               Output: px_parallel_dml_t3.c2
               ->  Assert
                     Output: px_parallel_dml_t3.c2
                     Assert Cond: ((row_number() OVER (?)) = 1)
                     ->  WindowAgg
                           Output: row_number() OVER (?), px_parallel_dml_t3.c2
                           ->  PX Coordinator 6:1  (slice2; segments: 6)
                                 Output: px_parallel_dml_t3.c2
                                 ->  Partial Seq Scan on public.px_parallel_dml_t3
                                       Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(20 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
psql:sql/polar-px-dev/px_parallel_dml_base.sql:32: ERROR:  one or more assertions failed
DETAIL:  Expected no more than one row to be returned by expression

-- Test Ordered Sensitive
set polar_px_enable_insert_order_sensitive=1;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

set polar_px_enable_insert_order_sensitive=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

--Insert into normal table select * from partition table
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:55: ERROR:  INSERT has more expressions than target columns
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t2_list where job='student';
psql:sql/polar-px-dev/px_parallel_dml_base.sql:58: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
HINT:  You will need to rewrite or cast the expression.
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: 100000, px_parallel_dml_t2_list_p1.pvalue
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2_list_p1.pvalue
               ->  Result
                     Output: px_parallel_dml_t2_list_p1.pvalue
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                 Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                 Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t2_list_p1.pvalue
         ->  Limit
               Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                     ->  Limit
                           Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                           ->  Nested Loop
                                 Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                 Join Filter: true
                                 ->  PX Broadcast 6:6  (slice2; segments: 6)
                                       Output: px_parallel_dml_t0_hash_p1.id
                                       ->  Append
                                             ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                                   Output: px_parallel_dml_t0_hash_p1.id
                                                   Filter: (px_parallel_dml_t0_hash_p1.id < 5000)
                                             ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                                   Output: px_parallel_dml_t0_hash_p2.id
                                                   Filter: (px_parallel_dml_t0_hash_p2.id < 5000)
                                             ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                                   Output: px_parallel_dml_t0_hash_p3.id
                                                   Filter: (px_parallel_dml_t0_hash_p3.id < 5000)
                                 ->  Append
                                       ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                             Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                             Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(29 rows)

insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
select count(*)from px_parallel_dml_t0_insert;
 count 
-------
 23998
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t0_insert
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Open the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='on';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Limit
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  Limit
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Limit
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  Limit
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Limit
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  Limit
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: 'student'::character varying(30), px_parallel_dml_t0_select_table.id
         ->  Limit
               Output: px_parallel_dml_t0_select_table.id
               ->  PX Coordinator 6:1  (slice1; segments: 6)
                     Output: px_parallel_dml_t0_select_table.id
                     ->  Limit
                           Output: px_parallel_dml_t0_select_table.id
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                 Output: px_parallel_dml_t0_select_table.id
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 31000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 16000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 31002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                           Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                           Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                           Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                           Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(13 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:87: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                           Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
                           Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                           Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
                           Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                           Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
                           Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(16 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:92: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_hash.id from px_parallel_dml_t0_hash where id > 28000;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: 'student'::character varying(30), px_parallel_dml_t0_hash_p1.id
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t0_hash_p1.id
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                           Output: px_parallel_dml_t0_hash_p1.id
                           Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                           Output: px_parallel_dml_t0_hash_p2.id
                           Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                           Output: px_parallel_dml_t0_hash_p3.id
                           Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(16 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: "varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false), px_parallel_dml_t1_range_p1.value
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                           Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                           Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                           Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                           Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(13 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 33000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 18000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 35002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

-- Close the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='off';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Subquery Scan on "*SELECT*"
         Output: 'student'::character varying(30), "*SELECT*".id
         ->  Limit
               Output: NULL::unknown, px_parallel_dml_t0_select_table.id
               ->  Seq Scan on public.px_parallel_dml_t0_select_table
                     Output: NULL::unknown, px_parallel_dml_t0_select_table.id
(7 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 34000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 19000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 36002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:125: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p1
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
               Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p2
               Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
               Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p3
               Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
               Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
(11 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:130: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from 'student',px_parallel_dml_t0_hash.id where id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:133: ERROR:  syntax error at or near "'student'"
LINE 1: ...insert into px_parallel_dml_t2_list select * from 'student',...
                                                             ^
insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 37000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 21000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 41002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

------------------------------------------------------------------------
--Insert into ... select from index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
               ->  Partial Index Scan using t_index_plan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
                     Index Cond: (px_parallel_dml_t4.c1 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
                     Filter: (px_parallel_dml_t4.c2 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
select count(*) from px_parallel_dml_t3;
 count 
-------
  1998
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t3
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Select Join
-- Innser join
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 LEFT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Right Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 RIGHT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
               ->  Hash Left Join
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 FULL OUTER JOIN px_parallel_dml_t3 using(c1);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)), px_parallel_dml_t3.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c2, (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1))
               ->  Merge Full Join
                     Output: px_parallel_dml_t3.c2, COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)
                     Merge Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c1)
                     ->  Sort
                           Output: px_parallel_dml_t2.c1
                           Sort Key: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
                     ->  Sort
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Sort Key: px_parallel_dml_t3.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                                 Hash Key: px_parallel_dml_t3.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t3
                                       Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(25 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select px_parallel_dml_t2.c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 CROSS JOIN px_parallel_dml_t3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Nested Loop
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Join Filter: true
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1
                     ->  Partial Seq Scan on public.px_parallel_dml_t3
                           Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(15 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 NATURAL JOIN px_parallel_dml_t3;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: ((px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1) AND (px_parallel_dml_t3.c2 = px_parallel_dml_t2.c2))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(21 rows)

select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Group BY
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1386
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

--------------------------------------------------------------------------
-- Insert not NULL Constrains Table
set polar_px_optimizer_enable_dml_constraints='off';
insert into px_parallel_dml_t6 select generate_series(1,1000),NULL;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
                          QUERY PLAN                          
--------------------------------------------------------------
 Insert on public.px_parallel_dml_t5
   ->  Seq Scan on public.px_parallel_dml_t6
         Output: px_parallel_dml_t6.c1, px_parallel_dml_t6.c2
(3 rows)

insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:176: ERROR:  null value in column "c2" violates not-null constraint
DETAIL:  Failing row contains (1, null).
set polar_px_optimizer_enable_dml_constraints='on';
select count(*) from px_parallel_dml_t5;
 count 
-------
     0
(1 row)

                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on public.px_parallel_dml_t5
 Optimizer: PolarDB PX Optimizer
(5 rows)

----------------------------------------------------------------------------
---- Insert into table with default num
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t8
   ->  Result
         Output: px_parallel_dml_t9.c1, 99999, NULL::character varying, 'Wed Jun 22 19:10:25 2016'::timestamp without time zone
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t9.c1
               ->  Partial Seq Scan on public.px_parallel_dml_t9
                     Output: px_parallel_dml_t9.c1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
select * from px_parallel_dml_t8 ORDER BY c1 ASC;
 c1 |  c2   | c3 |            c4            
----+-------+----+--------------------------
  1 | 99999 |    | Wed Jun 22 19:10:25 2016
  2 | 99999 |    | Wed Jun 22 19:10:25 2016
  3 | 99999 |    | Wed Jun 22 19:10:25 2016
  4 | 99999 |    | Wed Jun 22 19:10:25 2016
  5 | 99999 |    | Wed Jun 22 19:10:25 2016
  6 | 99999 |    | Wed Jun 22 19:10:25 2016
  7 | 99999 |    | Wed Jun 22 19:10:25 2016
  8 | 99999 |    | Wed Jun 22 19:10:25 2016
  9 | 99999 |    | Wed Jun 22 19:10:25 2016
 10 | 99999 |    | Wed Jun 22 19:10:25 2016
 11 | 99999 |    | Wed Jun 22 19:10:25 2016
 12 | 99999 |    | Wed Jun 22 19:10:25 2016
 13 | 99999 |    | Wed Jun 22 19:10:25 2016
 14 | 99999 |    | Wed Jun 22 19:10:25 2016
 15 | 99999 |    | Wed Jun 22 19:10:25 2016
 16 | 99999 |    | Wed Jun 22 19:10:25 2016
 17 | 99999 |    | Wed Jun 22 19:10:25 2016
 18 | 99999 |    | Wed Jun 22 19:10:25 2016
 19 | 99999 |    | Wed Jun 22 19:10:25 2016
 20 | 99999 |    | Wed Jun 22 19:10:25 2016
(20 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c1, c2, c3, c4
   Merge Key: c1
   ->  Sort
         Output: c1, c2, c3, c4
         Sort Key: px_parallel_dml_t8.c1
         ->  Partial Seq Scan on public.px_parallel_dml_t8
               Output: c1, c2, c3, c4
 Optimizer: PolarDB PX Optimizer
(9 rows)

-- Writer workers < Reader workers
set polar_px_insert_dop_num = 3;
\i sql/polar-px-dev/px_parallel_dml_init.sql
-- create normal table
drop table if exists px_parallel_dml_t1 cascade;
CREATE TABLE px_parallel_dml_t1 (c1 int, c2 int) ;
insert into px_parallel_dml_t1 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t2 cascade;
CREATE TABLE px_parallel_dml_t2 (c1 int, c2 int) ;
insert into px_parallel_dml_t2 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t3 cascade;
CREATE TABLE px_parallel_dml_t3 (c1 int, c2 int) ;
insert into px_parallel_dml_t3 select generate_series(1,1000),generate_series(1,1000);
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- create partition table
drop table if exists px_parallel_dml_t0_hash_insert cascade;
CREATE TABLE px_parallel_dml_t0_hash_insert (id int, value int) PARTITION BY HASH(id);
drop table if exists px_parallel_dml_t0_insert cascade;
CREATE TABLE px_parallel_dml_t0_insert (id int, value int);
drop table if exists px_parallel_dml_t0_select_table cascade;
CREATE TABLE px_parallel_dml_t0_select_table (id int, value int);
insert into px_parallel_dml_t0_select_table select generate_series(1,12000),generate_series(1,12000);
drop table if exists px_parallel_dml_t0_select_list_table cascade;
CREATE TABLE px_parallel_dml_t0_select_list_table (status character varying(30), value int);
-- PX Insert... Select from Partition Table
------------------------------------------------------------------------
-- Create partition table
drop table if exists px_parallel_dml_t0_hash cascade;
CREATE TABLE px_parallel_dml_t0_hash (id int, value int) PARTITION BY HASH(id);
CREATE TABLE px_parallel_dml_t0_hash_p1 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 0);
CREATE TABLE px_parallel_dml_t0_hash_p2 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 1);
CREATE TABLE px_parallel_dml_t0_hash_p3 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 2);
insert into px_parallel_dml_t0_hash select generate_series(1,30000),generate_series(1,30000);
------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
drop table if exists px_parallel_dml_t1_range cascade;
CREATE TABLE px_parallel_dml_t1_range(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3 PARTITION OF px_parallel_dml_t1_range DEFAULT;
insert into px_parallel_dml_t1_range select generate_series(1,30000, 2);
--range partition with INDEX
drop table if exists px_parallel_dml_t1_range_index cascade;
CREATE TABLE px_parallel_dml_t1_range_index(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3_index PARTITION OF px_parallel_dml_t1_range_index DEFAULT;
insert into px_parallel_dml_t1_range_index select generate_series(1,30000, 2);
CREATE INDEX px_parallel_dml_t1_partition_index on px_parallel_dml_t1_range_index(id);
------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
drop table if exists px_parallel_dml_t2_list cascade;
create table px_parallel_dml_t2_list(job character varying(30), pvalue int) partition by list (job);
CREATE TABLE px_parallel_dml_t2_list_p1 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('student');
CREATE TABLE px_parallel_dml_t2_list_p2 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('teacher');
CREATE TABLE px_parallel_dml_t2_list_p3 PARTITION OF px_parallel_dml_t2_list DEFAULT;
insert into px_parallel_dml_t2_list select 'student',generate_series(1,10000);
insert into px_parallel_dml_t2_list select 'teacher',generate_series(10000,20000);
insert into px_parallel_dml_t2_list select 'other',generate_series(20000,30000);
-- Index Test Init
drop table if exists px_parallel_dml_t4 cascade;
CREATE TABLE px_parallel_dml_t4 (c1 int, c2 int) ;
insert into px_parallel_dml_t4 select generate_series(1,1000),generate_series(1,1000);
CREATE INDEX t_index_plan on px_parallel_dml_t4(c1);
-- Constrain Test Init
drop table if exists px_parallel_dml_t5 cascade;
CREATE TABLE px_parallel_dml_t5 (c1 int, c2 int not NULL) ;
drop table if exists px_parallel_dml_t6 cascade;
CREATE TABLE px_parallel_dml_t6 (c1 int, c2 int) ;
---- Insert into table with default num
drop table if exists px_parallel_dml_t8 cascade;
CREATE TABLE px_parallel_dml_t8(
c1 int,
c2 int DEFAULT 99999,
c3 varchar DEFAULT NULL,
c4 timestamp default '2016-06-22 19:10:25-07'
);
drop table if exists px_parallel_dml_t9 cascade;
CREATE TABLE px_parallel_dml_t9 (c1 int, c2 int) ;
insert into px_parallel_dml_t9 select generate_series(1,20),generate_series(1,20);
\i sql/polar-px-dev/px_parallel_dml_base.sql
-- Insert
insert into px_parallel_dml_t1 select generate_series(1,60),generate_series(1,60);
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
                           QUERY PLAN                           
----------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(1, 60), generate_series(1, 60)
         ->  Result
(4 rows)

insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
select count(*) from px_parallel_dml_t1;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t1');
                                              dml_explain_filter                                              
--------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (never executed)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1
         ->  PX Hash 6:3  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t1 px_parallel_dml_t1_1 (actual rows=N loops=1)
                     Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1;
select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2');
                                   dml_explain_filter                                    
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (never executed)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1
         ->  PX Hash 6:3  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2 (actual rows=N loops=1)
                     Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1280
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   480
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2 where c1 = '1';
insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1 where c1 = '1';
select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   502
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

set polar_px_enable_insert_from_tableless=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 VALUES(100,100);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 100, 100
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 VALUES(200,200);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 200, 200
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select 1,2;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 1, 2
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select 3,4;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 3, 4
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(201,250), c2 from px_parallel_dml_t2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (generate_series(201, 250)), px_parallel_dml_t2.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: (generate_series(201, 250)), px_parallel_dml_t2.c2, (1)
               ->  ProjectSet
                     Output: generate_series(201, 250), px_parallel_dml_t2.c2, 1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2
                           Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(10 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(301,350),generate_series(301,350) union select * from px_parallel_dml_t3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  HashAggregate
         Output: (generate_series(301, 350)), (generate_series(301, 350))
         Group Key: (generate_series(301, 350)), (generate_series(301, 350))
         ->  Append
               ->  ProjectSet
                     Output: generate_series(301, 350), generate_series(301, 350)
                     ->  Result
               ->  Seq Scan on public.px_parallel_dml_t3
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
(10 rows)

-- Use PX Insert
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Assert Op DML
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 1:3  (slice1)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Hash Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c2)
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  Hash
                           Output: px_parallel_dml_t3.c2
                           ->  Assert
                                 Output: px_parallel_dml_t3.c2
                                 Assert Cond: ((row_number() OVER (?)) = 1)
                                 ->  WindowAgg
                                       Output: row_number() OVER (?), px_parallel_dml_t3.c2
                                       ->  PX Coordinator 6:1  (slice3; segments: 6)
                                             Output: px_parallel_dml_t3.c2
                                             ->  Partial Seq Scan on public.px_parallel_dml_t3
                                                   Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(24 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
psql:sql/polar-px-dev/px_parallel_dml_base.sql:32: ERROR:  one or more assertions failed
DETAIL:  Expected no more than one row to be returned by expression

-- Test Ordered Sensitive
set polar_px_enable_insert_order_sensitive=1;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

set polar_px_enable_insert_order_sensitive=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

--Insert into normal table select * from partition table
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:55: ERROR:  INSERT has more expressions than target columns
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t2_list where job='student';
psql:sql/polar-px-dev/px_parallel_dml_base.sql:58: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
HINT:  You will need to rewrite or cast the expression.
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: (100000), px_parallel_dml_t2_list_p1.pvalue
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: (100000), px_parallel_dml_t2_list_p1.pvalue, (1)
               ->  Result
                     Output: 100000, px_parallel_dml_t2_list_p1.pvalue, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                 Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                 Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t2_list_p1.pvalue
         ->  PX Hash 1:3  (slice1)
               Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
               ->  Limit
                     Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                           ->  Limit
                                 Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                 ->  Nested Loop
                                       Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                       Join Filter: true
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             Output: px_parallel_dml_t0_hash_p1.id
                                             ->  Append
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                                         Output: px_parallel_dml_t0_hash_p1.id
                                                         Filter: (px_parallel_dml_t0_hash_p1.id < 5000)
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                                         Output: px_parallel_dml_t0_hash_p2.id
                                                         Filter: (px_parallel_dml_t0_hash_p2.id < 5000)
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                                         Output: px_parallel_dml_t0_hash_p3.id
                                                         Filter: (px_parallel_dml_t0_hash_p3.id < 5000)
                                       ->  Append
                                             ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                                   Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                                   Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(31 rows)

insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
select count(*)from px_parallel_dml_t0_insert;
 count 
-------
 23998
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t0_insert
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Open the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='on';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:3  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:3  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:3  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: 'student'::character varying(30), px_parallel_dml_t0_select_table.id
         ->  PX Hash 1:3  (slice1)
               Output: px_parallel_dml_t0_select_table.id
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 31000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 16000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 31002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value, (1)
               ->  Result
                     Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                                 Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                                 Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                                 Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                                 Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(15 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:87: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value, (1)
               ->  Result
                     Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                 Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
                                 Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                 Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
                                 Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                 Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
                                 Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(18 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:92: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_hash.id from px_parallel_dml_t0_hash where id > 28000;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: ('student'::character varying(30)), px_parallel_dml_t0_hash_p1.id
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: ('student'::character varying(30)), px_parallel_dml_t0_hash_p1.id, (1)
               ->  Result
                     Output: 'student'::character varying(30), px_parallel_dml_t0_hash_p1.id, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                 Output: px_parallel_dml_t0_hash_p1.id
                                 Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                 Output: px_parallel_dml_t0_hash_p2.id
                                 Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                 Output: px_parallel_dml_t0_hash_p3.id
                                 Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(18 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: ("varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false)), px_parallel_dml_t1_range_p1.value
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: ("varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false)), px_parallel_dml_t1_range_p1.value, (1)
               ->  Result
                     Output: "varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false), px_parallel_dml_t1_range_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                                 Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                                 Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                                 Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                                 Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(15 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 33000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 18000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 35002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

-- Close the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='off';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Subquery Scan on "*SELECT*"
         Output: 'student'::character varying(30), "*SELECT*".id
         ->  Limit
               Output: NULL::unknown, px_parallel_dml_t0_select_table.id
               ->  Seq Scan on public.px_parallel_dml_t0_select_table
                     Output: NULL::unknown, px_parallel_dml_t0_select_table.id
(7 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 34000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 19000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 36002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:125: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p1
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
               Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p2
               Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
               Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p3
               Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
               Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
(11 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:130: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from 'student',px_parallel_dml_t0_hash.id where id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:133: ERROR:  syntax error at or near "'student'"
LINE 1: ...insert into px_parallel_dml_t2_list select * from 'student',...
                                                             ^
insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 37000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 21000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 41002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

------------------------------------------------------------------------
--Insert into ... select from index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, (1)
               ->  Partial Index Scan using t_index_plan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, 1
                     Index Cond: (px_parallel_dml_t4.c1 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, 1
                     Filter: (px_parallel_dml_t4.c2 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
select count(*) from px_parallel_dml_t3;
 count 
-------
  1998
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t3
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Select Join
-- Innser join
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 LEFT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Right Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 RIGHT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
               ->  Hash Left Join
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 FULL OUTER JOIN px_parallel_dml_t3 using(c1);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)), px_parallel_dml_t3.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c2, (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1))
               ->  Merge Full Join
                     Output: px_parallel_dml_t3.c2, COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)
                     Merge Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c1)
                     ->  Sort
                           Output: px_parallel_dml_t2.c1
                           Sort Key: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
                     ->  Sort
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Sort Key: px_parallel_dml_t3.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                                 Hash Key: px_parallel_dml_t3.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t3
                                       Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(25 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select px_parallel_dml_t2.c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 CROSS JOIN px_parallel_dml_t3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2, (1)
               ->  Nested Loop
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2, 1
                     Join Filter: true
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1
                     ->  Partial Seq Scan on public.px_parallel_dml_t3
                           Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(15 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 NATURAL JOIN px_parallel_dml_t3;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: ((px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1) AND (px_parallel_dml_t3.c2 = px_parallel_dml_t2.c2))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(21 rows)

select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Group BY
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1386
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

--------------------------------------------------------------------------
-- Insert not NULL Constrains Table
set polar_px_optimizer_enable_dml_constraints='off';
insert into px_parallel_dml_t6 select generate_series(1,1000),NULL;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
                          QUERY PLAN                          
--------------------------------------------------------------
 Insert on public.px_parallel_dml_t5
   ->  Seq Scan on public.px_parallel_dml_t6
         Output: px_parallel_dml_t6.c1, px_parallel_dml_t6.c2
(3 rows)

insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:176: ERROR:  null value in column "c2" violates not-null constraint
DETAIL:  Failing row contains (1, null).
set polar_px_optimizer_enable_dml_constraints='on';
select count(*) from px_parallel_dml_t5;
 count 
-------
     0
(1 row)

                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on public.px_parallel_dml_t5
 Optimizer: PolarDB PX Optimizer
(5 rows)

----------------------------------------------------------------------------
---- Insert into table with default num
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t8
   ->  Result
         Output: px_parallel_dml_t9.c1, (99999), (NULL::character varying), ('Wed Jun 22 19:10:25 2016'::timestamp without time zone)
         ->  PX Hash 6:3  (slice1; segments: 6)
               Output: px_parallel_dml_t9.c1, (99999), (NULL::character varying), ('Wed Jun 22 19:10:25 2016'::timestamp without time zone), (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t9
                     Output: px_parallel_dml_t9.c1, 99999, NULL::character varying, 'Wed Jun 22 19:10:25 2016'::timestamp without time zone, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
select * from px_parallel_dml_t8 ORDER BY c1 ASC;
 c1 |  c2   | c3 |            c4            
----+-------+----+--------------------------
  1 | 99999 |    | Wed Jun 22 19:10:25 2016
  2 | 99999 |    | Wed Jun 22 19:10:25 2016
  3 | 99999 |    | Wed Jun 22 19:10:25 2016
  4 | 99999 |    | Wed Jun 22 19:10:25 2016
  5 | 99999 |    | Wed Jun 22 19:10:25 2016
  6 | 99999 |    | Wed Jun 22 19:10:25 2016
  7 | 99999 |    | Wed Jun 22 19:10:25 2016
  8 | 99999 |    | Wed Jun 22 19:10:25 2016
  9 | 99999 |    | Wed Jun 22 19:10:25 2016
 10 | 99999 |    | Wed Jun 22 19:10:25 2016
 11 | 99999 |    | Wed Jun 22 19:10:25 2016
 12 | 99999 |    | Wed Jun 22 19:10:25 2016
 13 | 99999 |    | Wed Jun 22 19:10:25 2016
 14 | 99999 |    | Wed Jun 22 19:10:25 2016
 15 | 99999 |    | Wed Jun 22 19:10:25 2016
 16 | 99999 |    | Wed Jun 22 19:10:25 2016
 17 | 99999 |    | Wed Jun 22 19:10:25 2016
 18 | 99999 |    | Wed Jun 22 19:10:25 2016
 19 | 99999 |    | Wed Jun 22 19:10:25 2016
 20 | 99999 |    | Wed Jun 22 19:10:25 2016
(20 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c1, c2, c3, c4
   Merge Key: c1
   ->  Sort
         Output: c1, c2, c3, c4
         Sort Key: px_parallel_dml_t8.c1
         ->  Partial Seq Scan on public.px_parallel_dml_t8
               Output: c1, c2, c3, c4
 Optimizer: PolarDB PX Optimizer
(9 rows)

-- Writer workers == Read workers
set polar_px_insert_dop_num = 6;
\i sql/polar-px-dev/px_parallel_dml_init.sql
-- create normal table
drop table if exists px_parallel_dml_t1 cascade;
CREATE TABLE px_parallel_dml_t1 (c1 int, c2 int) ;
insert into px_parallel_dml_t1 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t2 cascade;
CREATE TABLE px_parallel_dml_t2 (c1 int, c2 int) ;
insert into px_parallel_dml_t2 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t3 cascade;
CREATE TABLE px_parallel_dml_t3 (c1 int, c2 int) ;
insert into px_parallel_dml_t3 select generate_series(1,1000),generate_series(1,1000);
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- create partition table
drop table if exists px_parallel_dml_t0_hash_insert cascade;
CREATE TABLE px_parallel_dml_t0_hash_insert (id int, value int) PARTITION BY HASH(id);
drop table if exists px_parallel_dml_t0_insert cascade;
CREATE TABLE px_parallel_dml_t0_insert (id int, value int);
drop table if exists px_parallel_dml_t0_select_table cascade;
CREATE TABLE px_parallel_dml_t0_select_table (id int, value int);
insert into px_parallel_dml_t0_select_table select generate_series(1,12000),generate_series(1,12000);
drop table if exists px_parallel_dml_t0_select_list_table cascade;
CREATE TABLE px_parallel_dml_t0_select_list_table (status character varying(30), value int);
-- PX Insert... Select from Partition Table
------------------------------------------------------------------------
-- Create partition table
drop table if exists px_parallel_dml_t0_hash cascade;
CREATE TABLE px_parallel_dml_t0_hash (id int, value int) PARTITION BY HASH(id);
CREATE TABLE px_parallel_dml_t0_hash_p1 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 0);
CREATE TABLE px_parallel_dml_t0_hash_p2 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 1);
CREATE TABLE px_parallel_dml_t0_hash_p3 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 2);
insert into px_parallel_dml_t0_hash select generate_series(1,30000),generate_series(1,30000);
------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
drop table if exists px_parallel_dml_t1_range cascade;
CREATE TABLE px_parallel_dml_t1_range(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3 PARTITION OF px_parallel_dml_t1_range DEFAULT;
insert into px_parallel_dml_t1_range select generate_series(1,30000, 2);
--range partition with INDEX
drop table if exists px_parallel_dml_t1_range_index cascade;
CREATE TABLE px_parallel_dml_t1_range_index(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3_index PARTITION OF px_parallel_dml_t1_range_index DEFAULT;
insert into px_parallel_dml_t1_range_index select generate_series(1,30000, 2);
CREATE INDEX px_parallel_dml_t1_partition_index on px_parallel_dml_t1_range_index(id);
------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
drop table if exists px_parallel_dml_t2_list cascade;
create table px_parallel_dml_t2_list(job character varying(30), pvalue int) partition by list (job);
CREATE TABLE px_parallel_dml_t2_list_p1 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('student');
CREATE TABLE px_parallel_dml_t2_list_p2 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('teacher');
CREATE TABLE px_parallel_dml_t2_list_p3 PARTITION OF px_parallel_dml_t2_list DEFAULT;
insert into px_parallel_dml_t2_list select 'student',generate_series(1,10000);
insert into px_parallel_dml_t2_list select 'teacher',generate_series(10000,20000);
insert into px_parallel_dml_t2_list select 'other',generate_series(20000,30000);
-- Index Test Init
drop table if exists px_parallel_dml_t4 cascade;
CREATE TABLE px_parallel_dml_t4 (c1 int, c2 int) ;
insert into px_parallel_dml_t4 select generate_series(1,1000),generate_series(1,1000);
CREATE INDEX t_index_plan on px_parallel_dml_t4(c1);
-- Constrain Test Init
drop table if exists px_parallel_dml_t5 cascade;
CREATE TABLE px_parallel_dml_t5 (c1 int, c2 int not NULL) ;
drop table if exists px_parallel_dml_t6 cascade;
CREATE TABLE px_parallel_dml_t6 (c1 int, c2 int) ;
---- Insert into table with default num
drop table if exists px_parallel_dml_t8 cascade;
CREATE TABLE px_parallel_dml_t8(
c1 int,
c2 int DEFAULT 99999,
c3 varchar DEFAULT NULL,
c4 timestamp default '2016-06-22 19:10:25-07'
);
drop table if exists px_parallel_dml_t9 cascade;
CREATE TABLE px_parallel_dml_t9 (c1 int, c2 int) ;
insert into px_parallel_dml_t9 select generate_series(1,20),generate_series(1,20);
\i sql/polar-px-dev/px_parallel_dml_base.sql
-- Insert
insert into px_parallel_dml_t1 select generate_series(1,60),generate_series(1,60);
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
                           QUERY PLAN                           
----------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(1, 60), generate_series(1, 60)
         ->  Result
(4 rows)

insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
select count(*) from px_parallel_dml_t1;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t1');
                                              dml_explain_filter                                              
--------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (never executed)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1
         ->  PX Hash 6:6  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t1 px_parallel_dml_t1_1 (actual rows=N loops=1)
                     Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1;
select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2');
                                   dml_explain_filter                                    
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (never executed)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1
         ->  PX Hash 6:6  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2 (actual rows=N loops=1)
                     Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1280
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   480
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2 where c1 = '1';
insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1 where c1 = '1';
select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   502
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

set polar_px_enable_insert_from_tableless=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 VALUES(100,100);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 100, 100
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 VALUES(200,200);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 200, 200
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select 1,2;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 1, 2
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select 3,4;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 3, 4
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(201,250), c2 from px_parallel_dml_t2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (generate_series(201, 250)), px_parallel_dml_t2.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: (generate_series(201, 250)), px_parallel_dml_t2.c2, (1)
               ->  ProjectSet
                     Output: generate_series(201, 250), px_parallel_dml_t2.c2, 1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2
                           Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(10 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(301,350),generate_series(301,350) union select * from px_parallel_dml_t3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  HashAggregate
         Output: (generate_series(301, 350)), (generate_series(301, 350))
         Group Key: (generate_series(301, 350)), (generate_series(301, 350))
         ->  Append
               ->  ProjectSet
                     Output: generate_series(301, 350), generate_series(301, 350)
                     ->  Result
               ->  Seq Scan on public.px_parallel_dml_t3
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
(10 rows)

-- Use PX Insert
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Assert Op DML
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 1:6  (slice1)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Hash Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c2)
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  Hash
                           Output: px_parallel_dml_t3.c2
                           ->  Assert
                                 Output: px_parallel_dml_t3.c2
                                 Assert Cond: ((row_number() OVER (?)) = 1)
                                 ->  WindowAgg
                                       Output: row_number() OVER (?), px_parallel_dml_t3.c2
                                       ->  PX Coordinator 6:1  (slice3; segments: 6)
                                             Output: px_parallel_dml_t3.c2
                                             ->  Partial Seq Scan on public.px_parallel_dml_t3
                                                   Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(24 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
psql:sql/polar-px-dev/px_parallel_dml_base.sql:32: ERROR:  one or more assertions failed
DETAIL:  Expected no more than one row to be returned by expression

-- Test Ordered Sensitive
set polar_px_enable_insert_order_sensitive=1;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

set polar_px_enable_insert_order_sensitive=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

--Insert into normal table select * from partition table
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:55: ERROR:  INSERT has more expressions than target columns
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t2_list where job='student';
psql:sql/polar-px-dev/px_parallel_dml_base.sql:58: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
HINT:  You will need to rewrite or cast the expression.
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: (100000), px_parallel_dml_t2_list_p1.pvalue
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: (100000), px_parallel_dml_t2_list_p1.pvalue, (1)
               ->  Result
                     Output: 100000, px_parallel_dml_t2_list_p1.pvalue, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                 Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                 Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t2_list_p1.pvalue
         ->  PX Hash 1:6  (slice1)
               Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
               ->  Limit
                     Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                           ->  Limit
                                 Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                 ->  Nested Loop
                                       Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                       Join Filter: true
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             Output: px_parallel_dml_t0_hash_p1.id
                                             ->  Append
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                                         Output: px_parallel_dml_t0_hash_p1.id
                                                         Filter: (px_parallel_dml_t0_hash_p1.id < 5000)
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                                         Output: px_parallel_dml_t0_hash_p2.id
                                                         Filter: (px_parallel_dml_t0_hash_p2.id < 5000)
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                                         Output: px_parallel_dml_t0_hash_p3.id
                                                         Filter: (px_parallel_dml_t0_hash_p3.id < 5000)
                                       ->  Append
                                             ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                                   Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                                   Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(31 rows)

insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
select count(*)from px_parallel_dml_t0_insert;
 count 
-------
 23998
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t0_insert
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Open the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='on';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:6  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:6  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:6  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: 'student'::character varying(30), px_parallel_dml_t0_select_table.id
         ->  PX Hash 1:6  (slice1)
               Output: px_parallel_dml_t0_select_table.id
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 31000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 16000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 31002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value, (1)
               ->  Result
                     Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                                 Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                                 Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                                 Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                                 Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(15 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:87: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value, (1)
               ->  Result
                     Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                 Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
                                 Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                 Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
                                 Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                 Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
                                 Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(18 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:92: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_hash.id from px_parallel_dml_t0_hash where id > 28000;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: ('student'::character varying(30)), px_parallel_dml_t0_hash_p1.id
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: ('student'::character varying(30)), px_parallel_dml_t0_hash_p1.id, (1)
               ->  Result
                     Output: 'student'::character varying(30), px_parallel_dml_t0_hash_p1.id, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                 Output: px_parallel_dml_t0_hash_p1.id
                                 Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                 Output: px_parallel_dml_t0_hash_p2.id
                                 Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                 Output: px_parallel_dml_t0_hash_p3.id
                                 Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(18 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: ("varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false)), px_parallel_dml_t1_range_p1.value
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: ("varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false)), px_parallel_dml_t1_range_p1.value, (1)
               ->  Result
                     Output: "varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false), px_parallel_dml_t1_range_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                                 Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                                 Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                                 Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                                 Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(15 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 33000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 18000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 35002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

-- Close the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='off';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Subquery Scan on "*SELECT*"
         Output: 'student'::character varying(30), "*SELECT*".id
         ->  Limit
               Output: NULL::unknown, px_parallel_dml_t0_select_table.id
               ->  Seq Scan on public.px_parallel_dml_t0_select_table
                     Output: NULL::unknown, px_parallel_dml_t0_select_table.id
(7 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 34000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 19000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 36002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:125: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p1
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
               Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p2
               Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
               Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p3
               Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
               Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
(11 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:130: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from 'student',px_parallel_dml_t0_hash.id where id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:133: ERROR:  syntax error at or near "'student'"
LINE 1: ...insert into px_parallel_dml_t2_list select * from 'student',...
                                                             ^
insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 37000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 21000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 41002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

------------------------------------------------------------------------
--Insert into ... select from index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, (1)
               ->  Partial Index Scan using t_index_plan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, 1
                     Index Cond: (px_parallel_dml_t4.c1 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, 1
                     Filter: (px_parallel_dml_t4.c2 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
select count(*) from px_parallel_dml_t3;
 count 
-------
  1998
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t3
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Select Join
-- Innser join
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 LEFT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Right Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 RIGHT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
               ->  Hash Left Join
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 FULL OUTER JOIN px_parallel_dml_t3 using(c1);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)), px_parallel_dml_t3.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c2, (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1))
               ->  Merge Full Join
                     Output: px_parallel_dml_t3.c2, COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)
                     Merge Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c1)
                     ->  Sort
                           Output: px_parallel_dml_t2.c1
                           Sort Key: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
                     ->  Sort
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Sort Key: px_parallel_dml_t3.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                                 Hash Key: px_parallel_dml_t3.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t3
                                       Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(25 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select px_parallel_dml_t2.c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 CROSS JOIN px_parallel_dml_t3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2, (1)
               ->  Nested Loop
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2, 1
                     Join Filter: true
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1
                     ->  Partial Seq Scan on public.px_parallel_dml_t3
                           Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(15 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 NATURAL JOIN px_parallel_dml_t3;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: ((px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1) AND (px_parallel_dml_t3.c2 = px_parallel_dml_t2.c2))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(21 rows)

select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Group BY
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1386
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

--------------------------------------------------------------------------
-- Insert not NULL Constrains Table
set polar_px_optimizer_enable_dml_constraints='off';
insert into px_parallel_dml_t6 select generate_series(1,1000),NULL;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
                          QUERY PLAN                          
--------------------------------------------------------------
 Insert on public.px_parallel_dml_t5
   ->  Seq Scan on public.px_parallel_dml_t6
         Output: px_parallel_dml_t6.c1, px_parallel_dml_t6.c2
(3 rows)

insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:176: ERROR:  null value in column "c2" violates not-null constraint
DETAIL:  Failing row contains (1, null).
set polar_px_optimizer_enable_dml_constraints='on';
select count(*) from px_parallel_dml_t5;
 count 
-------
     0
(1 row)

                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on public.px_parallel_dml_t5
 Optimizer: PolarDB PX Optimizer
(5 rows)

----------------------------------------------------------------------------
---- Insert into table with default num
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t8
   ->  Result
         Output: px_parallel_dml_t9.c1, (99999), (NULL::character varying), ('Wed Jun 22 19:10:25 2016'::timestamp without time zone)
         ->  PX Hash 6:6  (slice1; segments: 6)
               Output: px_parallel_dml_t9.c1, (99999), (NULL::character varying), ('Wed Jun 22 19:10:25 2016'::timestamp without time zone), (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t9
                     Output: px_parallel_dml_t9.c1, 99999, NULL::character varying, 'Wed Jun 22 19:10:25 2016'::timestamp without time zone, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
select * from px_parallel_dml_t8 ORDER BY c1 ASC;
 c1 |  c2   | c3 |            c4            
----+-------+----+--------------------------
  1 | 99999 |    | Wed Jun 22 19:10:25 2016
  2 | 99999 |    | Wed Jun 22 19:10:25 2016
  3 | 99999 |    | Wed Jun 22 19:10:25 2016
  4 | 99999 |    | Wed Jun 22 19:10:25 2016
  5 | 99999 |    | Wed Jun 22 19:10:25 2016
  6 | 99999 |    | Wed Jun 22 19:10:25 2016
  7 | 99999 |    | Wed Jun 22 19:10:25 2016
  8 | 99999 |    | Wed Jun 22 19:10:25 2016
  9 | 99999 |    | Wed Jun 22 19:10:25 2016
 10 | 99999 |    | Wed Jun 22 19:10:25 2016
 11 | 99999 |    | Wed Jun 22 19:10:25 2016
 12 | 99999 |    | Wed Jun 22 19:10:25 2016
 13 | 99999 |    | Wed Jun 22 19:10:25 2016
 14 | 99999 |    | Wed Jun 22 19:10:25 2016
 15 | 99999 |    | Wed Jun 22 19:10:25 2016
 16 | 99999 |    | Wed Jun 22 19:10:25 2016
 17 | 99999 |    | Wed Jun 22 19:10:25 2016
 18 | 99999 |    | Wed Jun 22 19:10:25 2016
 19 | 99999 |    | Wed Jun 22 19:10:25 2016
 20 | 99999 |    | Wed Jun 22 19:10:25 2016
(20 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c1, c2, c3, c4
   Merge Key: c1
   ->  Sort
         Output: c1, c2, c3, c4
         Sort Key: px_parallel_dml_t8.c1
         ->  Partial Seq Scan on public.px_parallel_dml_t8
               Output: c1, c2, c3, c4
 Optimizer: PolarDB PX Optimizer
(9 rows)

-- Writer workers > Read workers
set polar_px_insert_dop_num = 10;
\i sql/polar-px-dev/px_parallel_dml_init.sql
-- create normal table
drop table if exists px_parallel_dml_t1 cascade;
CREATE TABLE px_parallel_dml_t1 (c1 int, c2 int) ;
insert into px_parallel_dml_t1 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t2 cascade;
CREATE TABLE px_parallel_dml_t2 (c1 int, c2 int) ;
insert into px_parallel_dml_t2 select generate_series(1,100),generate_series(1,100);
drop table if exists px_parallel_dml_t3 cascade;
CREATE TABLE px_parallel_dml_t3 (c1 int, c2 int) ;
insert into px_parallel_dml_t3 select generate_series(1,1000),generate_series(1,1000);
select count(*) from px_parallel_dml_t1;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   100
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- create partition table
drop table if exists px_parallel_dml_t0_hash_insert cascade;
CREATE TABLE px_parallel_dml_t0_hash_insert (id int, value int) PARTITION BY HASH(id);
drop table if exists px_parallel_dml_t0_insert cascade;
CREATE TABLE px_parallel_dml_t0_insert (id int, value int);
drop table if exists px_parallel_dml_t0_select_table cascade;
CREATE TABLE px_parallel_dml_t0_select_table (id int, value int);
insert into px_parallel_dml_t0_select_table select generate_series(1,12000),generate_series(1,12000);
drop table if exists px_parallel_dml_t0_select_list_table cascade;
CREATE TABLE px_parallel_dml_t0_select_list_table (status character varying(30), value int);
-- PX Insert... Select from Partition Table
------------------------------------------------------------------------
-- Create partition table
drop table if exists px_parallel_dml_t0_hash cascade;
CREATE TABLE px_parallel_dml_t0_hash (id int, value int) PARTITION BY HASH(id);
CREATE TABLE px_parallel_dml_t0_hash_p1 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 0);
CREATE TABLE px_parallel_dml_t0_hash_p2 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 1);
CREATE TABLE px_parallel_dml_t0_hash_p3 PARTITION OF px_parallel_dml_t0_hash FOR VALUES WITH (modulus 3, remainder 2);
insert into px_parallel_dml_t0_hash select generate_series(1,30000),generate_series(1,30000);
------------------------------------------------------------------------
--range partition
--Partition constraint: ((x IS NOT NULL) AND (x >= 10) AND (x < 20))
drop table if exists px_parallel_dml_t1_range cascade;
CREATE TABLE px_parallel_dml_t1_range(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2 PARTITION OF px_parallel_dml_t1_range FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3 PARTITION OF px_parallel_dml_t1_range DEFAULT;
insert into px_parallel_dml_t1_range select generate_series(1,30000, 2);
--range partition with INDEX
drop table if exists px_parallel_dml_t1_range_index cascade;
CREATE TABLE px_parallel_dml_t1_range_index(id int, value int) PARTITION BY RANGE(id);
CREATE TABLE px_parallel_dml_t1_range_p1_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (1) TO (10000);
CREATE TABLE px_parallel_dml_t1_range_p2_index PARTITION OF px_parallel_dml_t1_range_index FOR VALUES FROM (10000) TO (20000);
CREATE TABLE px_parallel_dml_t1_range_p3_index PARTITION OF px_parallel_dml_t1_range_index DEFAULT;
insert into px_parallel_dml_t1_range_index select generate_series(1,30000, 2);
CREATE INDEX px_parallel_dml_t1_partition_index on px_parallel_dml_t1_range_index(id);
------------------------------------------------------------------------
--list
--Partition constraint: ((b IS NOT NULL) AND (b = ANY (ARRAY[1, 3])))
drop table if exists px_parallel_dml_t2_list cascade;
create table px_parallel_dml_t2_list(job character varying(30), pvalue int) partition by list (job);
CREATE TABLE px_parallel_dml_t2_list_p1 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('student');
CREATE TABLE px_parallel_dml_t2_list_p2 PARTITION OF px_parallel_dml_t2_list FOR VALUES IN ('teacher');
CREATE TABLE px_parallel_dml_t2_list_p3 PARTITION OF px_parallel_dml_t2_list DEFAULT;
insert into px_parallel_dml_t2_list select 'student',generate_series(1,10000);
insert into px_parallel_dml_t2_list select 'teacher',generate_series(10000,20000);
insert into px_parallel_dml_t2_list select 'other',generate_series(20000,30000);
-- Index Test Init
drop table if exists px_parallel_dml_t4 cascade;
CREATE TABLE px_parallel_dml_t4 (c1 int, c2 int) ;
insert into px_parallel_dml_t4 select generate_series(1,1000),generate_series(1,1000);
CREATE INDEX t_index_plan on px_parallel_dml_t4(c1);
-- Constrain Test Init
drop table if exists px_parallel_dml_t5 cascade;
CREATE TABLE px_parallel_dml_t5 (c1 int, c2 int not NULL) ;
drop table if exists px_parallel_dml_t6 cascade;
CREATE TABLE px_parallel_dml_t6 (c1 int, c2 int) ;
---- Insert into table with default num
drop table if exists px_parallel_dml_t8 cascade;
CREATE TABLE px_parallel_dml_t8(
c1 int,
c2 int DEFAULT 99999,
c3 varchar DEFAULT NULL,
c4 timestamp default '2016-06-22 19:10:25-07'
);
drop table if exists px_parallel_dml_t9 cascade;
CREATE TABLE px_parallel_dml_t9 (c1 int, c2 int) ;
insert into px_parallel_dml_t9 select generate_series(1,20),generate_series(1,20);
\i sql/polar-px-dev/px_parallel_dml_base.sql
-- Insert
insert into px_parallel_dml_t1 select generate_series(1,60),generate_series(1,60);
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
                           QUERY PLAN                           
----------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(1, 60), generate_series(1, 60)
         ->  Result
(4 rows)

insert into px_parallel_dml_t2 select generate_series(1,60),generate_series(1,60);
select count(*) from px_parallel_dml_t1;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   160
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t1');
                                              dml_explain_filter                                              
--------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (never executed)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1
         ->  PX Hash 6:10  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t1 px_parallel_dml_t1_1 (actual rows=N loops=1)
                     Output: px_parallel_dml_t1_1.c2, px_parallel_dml_t1_1.c1, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1;
select dml_explain_filter('EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2');
                                   dml_explain_filter                                    
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1 (never executed)
   ->  Result (actual rows=N loops=1)
         Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1
         ->  PX Hash 6:10  (slice1; segments: 6) (actual rows=N loops=1)
               Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2 (actual rows=N loops=1)
                     Output: px_parallel_dml_t2.c2, px_parallel_dml_t2.c1, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1280
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   480
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t1 select c2, c1 from px_parallel_dml_t2 where c1 = '1';
insert into px_parallel_dml_t2 select c2, c1 from px_parallel_dml_t1 where c1 = '1';
select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

select count(*) from px_parallel_dml_t2;
 count 
-------
   502
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t2
 Optimizer: PolarDB PX Optimizer
(8 rows)

set polar_px_enable_insert_from_tableless=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 VALUES(100,100);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 100, 100
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 VALUES(200,200);
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 200, 200
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select 1,2;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: 1, 2
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2 select 3,4;
             QUERY PLAN              
-------------------------------------
 Insert on public.px_parallel_dml_t2
   ->  Result
         Output: 3, 4
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(201,250), c2 from px_parallel_dml_t2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (generate_series(201, 250)), px_parallel_dml_t2.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: (generate_series(201, 250)), px_parallel_dml_t2.c2, (1)
               ->  ProjectSet
                     Output: generate_series(201, 250), px_parallel_dml_t2.c2, 1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2
                           Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(10 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(301,350),generate_series(301,350) union select * from px_parallel_dml_t3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  HashAggregate
         Output: (generate_series(301, 350)), (generate_series(301, 350))
         Group Key: (generate_series(301, 350)), (generate_series(301, 350))
         ->  Append
               ->  ProjectSet
                     Output: generate_series(301, 350), generate_series(301, 350)
                     ->  Result
               ->  Seq Scan on public.px_parallel_dml_t3
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
(10 rows)

-- Use PX Insert
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Assert Op DML
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 1:10  (slice1)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Hash Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c2)
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  Hash
                           Output: px_parallel_dml_t3.c2
                           ->  Assert
                                 Output: px_parallel_dml_t3.c2
                                 Assert Cond: ((row_number() OVER (?)) = 1)
                                 ->  WindowAgg
                                       Output: row_number() OVER (?), px_parallel_dml_t3.c2
                                       ->  PX Coordinator 6:1  (slice3; segments: 6)
                                             Output: px_parallel_dml_t3.c2
                                             ->  Partial Seq Scan on public.px_parallel_dml_t3
                                                   Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(24 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 where c1 = (select c2 from px_parallel_dml_t3);
psql:sql/polar-px-dev/px_parallel_dml_base.sql:32: ERROR:  one or more assertions failed
DETAIL:  Expected no more than one row to be returned by expression

-- Test Ordered Sensitive
set polar_px_enable_insert_order_sensitive=1;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Coordinator 6:1  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

set polar_px_enable_insert_order_sensitive=0;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 order by px_parallel_dml_t2.c1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t2
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c2 from px_parallel_dml_t2 group by px_parallel_dml_t2.c2 order by px_parallel_dml_t2.c2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c2, NULL::integer
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select generate_series(101,150),generate_series(101,150);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  ProjectSet
         Output: generate_series(101, 150), generate_series(101, 150)
         ->  Result
(4 rows)

--Insert into normal table select * from partition table
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash where id < 2000;
insert into px_parallel_dml_t0_insert select px_parallel_dml_t0_hash.id,px_parallel_dml_t1_range.value from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t0_hash,px_parallel_dml_t1_range where px_parallel_dml_t0_hash.id = px_parallel_dml_t1_range.id and px_parallel_dml_t1_range.id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:55: ERROR:  INSERT has more expressions than target columns
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from  px_parallel_dml_t1_range where id > 29000;
insert into px_parallel_dml_t0_insert select * from px_parallel_dml_t2_list where job='student';
psql:sql/polar-px-dev/px_parallel_dml_base.sql:58: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: insert into px_parallel_dml_t0_insert select * from px_paral...
                                                     ^
HINT:  You will need to rewrite or cast the expression.
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: (100000), px_parallel_dml_t2_list_p1.pvalue
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: (100000), px_parallel_dml_t2_list_p1.pvalue, (1)
               ->  Result
                     Output: 100000, px_parallel_dml_t2_list_p1.pvalue, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                 Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                 Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(12 rows)

insert into px_parallel_dml_t0_insert select 100000,pvalue from px_parallel_dml_t2_list where job='student';
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_insert
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t2_list_p1.pvalue
         ->  PX Hash 1:10  (slice1)
               Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
               ->  Limit
                     Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                           ->  Limit
                                 Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                 ->  Nested Loop
                                       Output: px_parallel_dml_t2_list_p1.pvalue, px_parallel_dml_t0_hash_p1.id
                                       Join Filter: true
                                       ->  PX Broadcast 6:6  (slice3; segments: 6)
                                             Output: px_parallel_dml_t0_hash_p1.id
                                             ->  Append
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                                         Output: px_parallel_dml_t0_hash_p1.id
                                                         Filter: (px_parallel_dml_t0_hash_p1.id < 5000)
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                                         Output: px_parallel_dml_t0_hash_p2.id
                                                         Filter: (px_parallel_dml_t0_hash_p2.id < 5000)
                                                   ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                                         Output: px_parallel_dml_t0_hash_p3.id
                                                         Filter: (px_parallel_dml_t0_hash_p3.id < 5000)
                                       ->  Append
                                             ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                                                   Output: px_parallel_dml_t2_list_p1.job, px_parallel_dml_t2_list_p1.pvalue
                                                   Filter: ((px_parallel_dml_t2_list_p1.job)::text = 'student'::text)
 Optimizer: PolarDB PX Optimizer
(31 rows)

insert into px_parallel_dml_t0_insert select id, px_parallel_dml_t2_list.pvalue from px_parallel_dml_t2_list,px_parallel_dml_t0_hash where px_parallel_dml_t2_list.job='student' and px_parallel_dml_t0_hash.id < 5000 LIMIT 5000;
select count(*)from px_parallel_dml_t0_insert;
 count 
-------
 23998
(1 row)

                               QUERY PLAN                               
------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t0_insert
 Optimizer: PolarDB PX Optimizer
(8 rows)

-- Open the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='on';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:10  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:10  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Result
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  PX Hash 1:10  (slice1)
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: 'student'::character varying(30), px_parallel_dml_t0_select_table.id
         ->  PX Hash 1:10  (slice1)
               Output: px_parallel_dml_t0_select_table.id
               ->  Limit
                     Output: px_parallel_dml_t0_select_table.id
                     ->  PX Coordinator 6:1  (slice2; segments: 6)
                           Output: px_parallel_dml_t0_select_table.id
                           ->  Limit
                                 Output: px_parallel_dml_t0_select_table.id
                                 ->  Partial Seq Scan on public.px_parallel_dml_t0_select_table
                                       Output: px_parallel_dml_t0_select_table.id
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 31000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 16000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 31002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Result
         Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value, (1)
               ->  Result
                     Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                                 Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                                 Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                                 Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                                 Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(15 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:87: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Result
         Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value, (1)
               ->  Result
                     Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                 Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
                                 Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                 Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
                                 Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                 Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
                                 Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(18 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:92: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_hash.id from px_parallel_dml_t0_hash where id > 28000;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: ('student'::character varying(30)), px_parallel_dml_t0_hash_p1.id
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: ('student'::character varying(30)), px_parallel_dml_t0_hash_p1.id, (1)
               ->  Result
                     Output: 'student'::character varying(30), px_parallel_dml_t0_hash_p1.id, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                                 Output: px_parallel_dml_t0_hash_p1.id
                                 Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                                 Output: px_parallel_dml_t0_hash_p2.id
                                 Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
                                 Output: px_parallel_dml_t0_hash_p3.id
                                 Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
 Optimizer: PolarDB PX Optimizer
(18 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Result
         Output: ("varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false)), px_parallel_dml_t1_range_p1.value
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: ("varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false)), px_parallel_dml_t1_range_p1.value, (1)
               ->  Result
                     Output: "varchar"((px_parallel_dml_t1_range_p1.id)::character varying, 34, false), px_parallel_dml_t1_range_p1.value, 1
                     ->  Append
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                                 Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
                                 Filter: (px_parallel_dml_t1_range_p1.id < 2000)
                           ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
                                 Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
                                 Filter: (px_parallel_dml_t1_range_p3.id < 2000)
 Optimizer: PolarDB PX Optimizer
(15 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 33000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 18000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 35002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

-- Close the px_enable_insert_partition_table
set polar_px_enable_insert_partition_table='off';
--Insert into partition table select * from normal table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_select_table limit 1000;
-- With Index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range_index
   ->  Limit
         Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
         ->  Seq Scan on public.px_parallel_dml_t0_select_table
               Output: px_parallel_dml_t0_select_table.id, px_parallel_dml_t0_select_table.value
(5 rows)

insert into px_parallel_dml_t1_range_index select * from px_parallel_dml_t0_select_table limit 1000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select 'student',px_parallel_dml_t0_select_table.id from px_parallel_dml_t0_select_table limit 1000;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Subquery Scan on "*SELECT*"
         Output: 'student'::character varying(30), "*SELECT*".id
         ->  Limit
               Output: NULL::unknown, px_parallel_dml_t0_select_table.id
               ->  Seq Scan on public.px_parallel_dml_t0_select_table
                     Output: NULL::unknown, px_parallel_dml_t0_select_table.id
(7 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_select_table limit 1000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 34000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 19000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 36002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

--Insert into partition table select * from partition table
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t0_hash
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t1_range where id < 2000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t0_hash select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:125: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ...S OFF) insert into px_parallel_dml_t0_hash select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t0_hash select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1_range
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p1
               Output: px_parallel_dml_t0_hash_p1.id, px_parallel_dml_t0_hash_p1.value
               Filter: (px_parallel_dml_t0_hash_p1.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p2
               Output: px_parallel_dml_t0_hash_p2.id, px_parallel_dml_t0_hash_p2.value
               Filter: (px_parallel_dml_t0_hash_p2.id > 28000)
         ->  Seq Scan on public.px_parallel_dml_t0_hash_p3
               Output: px_parallel_dml_t0_hash_p3.id, px_parallel_dml_t0_hash_p3.value
               Filter: (px_parallel_dml_t0_hash_p3.id > 28000)
(11 rows)

insert into px_parallel_dml_t1_range select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1_range select * from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:130: ERROR:  column "id" is of type integer but expression is of type character varying
LINE 1: ... OFF) insert into px_parallel_dml_t1_range select * from px_...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
insert into px_parallel_dml_t1_range select 100000,pvalue from px_parallel_dml_t2_list where job='teachar' and pvalue < 12000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from 'student',px_parallel_dml_t0_hash.id where id > 28000;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:133: ERROR:  syntax error at or near "'student'"
LINE 1: ...insert into px_parallel_dml_t2_list select * from 'student',...
                                                             ^
insert into px_parallel_dml_t2_list select * from px_parallel_dml_t0_hash where id > 28000;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t2_list
   ->  Append
         ->  Seq Scan on public.px_parallel_dml_t1_range_p1
               Output: px_parallel_dml_t1_range_p1.id, px_parallel_dml_t1_range_p1.value
               Filter: (px_parallel_dml_t1_range_p1.id < 2000)
         ->  Seq Scan on public.px_parallel_dml_t1_range_p3
               Output: px_parallel_dml_t1_range_p3.id, px_parallel_dml_t1_range_p3.value
               Filter: (px_parallel_dml_t1_range_p3.id < 2000)
(8 rows)

insert into px_parallel_dml_t2_list select * from px_parallel_dml_t1_range where id < 2000;
select count(*) from px_parallel_dml_t0_hash;
 count 
-------
 37000
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t0_hash_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t1_range;
 count 
-------
 21000
(1 row)

                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t1_range_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

select count(*) from px_parallel_dml_t2_list;
 count 
-------
 41002
(1 row)

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p1
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p2
                     ->  Partial Seq Scan on public.px_parallel_dml_t2_list_p3
 Optimizer: PolarDB PX Optimizer
(11 rows)

------------------------------------------------------------------------
--Insert into ... select from index
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, (1)
               ->  Partial Index Scan using t_index_plan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, 1
                     Index Cond: (px_parallel_dml_t4.c1 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c1 < 500;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t3
   ->  Result
         Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t4
                     Output: px_parallel_dml_t4.c1, px_parallel_dml_t4.c2, 1
                     Filter: (px_parallel_dml_t4.c2 < 500)
 Optimizer: PolarDB PX Optimizer
(9 rows)

insert into px_parallel_dml_t3 select * from px_parallel_dml_t4 where c2 < 500;
select count(*) from px_parallel_dml_t3;
 count 
-------
  1998
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t3
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Select Join
-- Innser join
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 LEFT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Right Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 RIGHT OUTER JOIN px_parallel_dml_t3 using(c1);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
               ->  Hash Left Join
                     Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     Hash Cond: (px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1)
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
 Optimizer: PolarDB PX Optimizer
(21 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 FULL OUTER JOIN px_parallel_dml_t3 using(c1);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)), px_parallel_dml_t3.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t3.c2, (COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1))
               ->  Merge Full Join
                     Output: px_parallel_dml_t3.c2, COALESCE(px_parallel_dml_t2.c1, px_parallel_dml_t3.c1)
                     Merge Cond: (px_parallel_dml_t2.c1 = px_parallel_dml_t3.c1)
                     ->  Sort
                           Output: px_parallel_dml_t2.c1
                           Sort Key: px_parallel_dml_t2.c1
                           ->  PX Hash 6:6  (slice2; segments: 6)
                                 Output: px_parallel_dml_t2.c1
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1
                     ->  Sort
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Sort Key: px_parallel_dml_t3.c1
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                                 Hash Key: px_parallel_dml_t3.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t3
                                       Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(25 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select px_parallel_dml_t2.c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 CROSS JOIN px_parallel_dml_t3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2, (1)
               ->  Nested Loop
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2, 1
                     Join Filter: true
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1
                     ->  Partial Seq Scan on public.px_parallel_dml_t3
                           Output: px_parallel_dml_t3.c2
 Optimizer: PolarDB PX Optimizer
(15 rows)

EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select c1,px_parallel_dml_t3.c2 from px_parallel_dml_t2 NATURAL JOIN px_parallel_dml_t3;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
               ->  Hash Join
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t3.c2
                     Hash Cond: ((px_parallel_dml_t3.c1 = px_parallel_dml_t2.c1) AND (px_parallel_dml_t3.c2 = px_parallel_dml_t2.c2))
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                           Hash Key: px_parallel_dml_t3.c1
                           ->  Partial Seq Scan on public.px_parallel_dml_t3
                                 Output: px_parallel_dml_t3.c1, px_parallel_dml_t3.c2
                     ->  Hash
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  PX Hash 6:6  (slice3; segments: 6)
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                                 Hash Key: px_parallel_dml_t2.c1
                                 ->  Partial Seq Scan on public.px_parallel_dml_t2
                                       Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(21 rows)

select count(*) from px_parallel_dml_t1;
 count 
-------
  1286
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

------------------------------------------------------------------------
-- Group BY
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t1
   ->  Result
         Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
               ->  HashAggregate
                     Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     Group Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           Hash Key: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
                           ->  Partial Seq Scan on public.px_parallel_dml_t2
                                 Output: px_parallel_dml_t2.c1, px_parallel_dml_t2.c2
 Optimizer: PolarDB PX Optimizer
(14 rows)

insert into px_parallel_dml_t1 select * from px_parallel_dml_t2 group by c1,c2;
select count(*) from px_parallel_dml_t1;
 count 
-------
  1386
(1 row)

                           QUERY PLAN                            
-----------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Partial Seq Scan on public.px_parallel_dml_t1
 Optimizer: PolarDB PX Optimizer
(8 rows)

--------------------------------------------------------------------------
-- Insert not NULL Constrains Table
set polar_px_optimizer_enable_dml_constraints='off';
insert into px_parallel_dml_t6 select generate_series(1,1000),NULL;
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
                          QUERY PLAN                          
--------------------------------------------------------------
 Insert on public.px_parallel_dml_t5
   ->  Seq Scan on public.px_parallel_dml_t6
         Output: px_parallel_dml_t6.c1, px_parallel_dml_t6.c2
(3 rows)

insert into px_parallel_dml_t5 select * from px_parallel_dml_t6;
psql:sql/polar-px-dev/px_parallel_dml_base.sql:176: ERROR:  null value in column "c2" violates not-null constraint
DETAIL:  Failing row contains (1, null).
set polar_px_optimizer_enable_dml_constraints='on';
select count(*) from px_parallel_dml_t5;
 count 
-------
     0
(1 row)

                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         ->  Partial Seq Scan on public.px_parallel_dml_t5
 Optimizer: PolarDB PX Optimizer
(5 rows)

----------------------------------------------------------------------------
---- Insert into table with default num
EXPLAIN (VERBOSE, COSTS OFF) insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.px_parallel_dml_t8
   ->  Result
         Output: px_parallel_dml_t9.c1, (99999), (NULL::character varying), ('Wed Jun 22 19:10:25 2016'::timestamp without time zone)
         ->  PX Hash 6:10  (slice1; segments: 6)
               Output: px_parallel_dml_t9.c1, (99999), (NULL::character varying), ('Wed Jun 22 19:10:25 2016'::timestamp without time zone), (1)
               ->  Partial Seq Scan on public.px_parallel_dml_t9
                     Output: px_parallel_dml_t9.c1, 99999, NULL::character varying, 'Wed Jun 22 19:10:25 2016'::timestamp without time zone, 1
 Optimizer: PolarDB PX Optimizer
(8 rows)

insert into px_parallel_dml_t8 select c1 from px_parallel_dml_t9;
select * from px_parallel_dml_t8 ORDER BY c1 ASC;
 c1 |  c2   | c3 |            c4            
----+-------+----+--------------------------
  1 | 99999 |    | Wed Jun 22 19:10:25 2016
  2 | 99999 |    | Wed Jun 22 19:10:25 2016
  3 | 99999 |    | Wed Jun 22 19:10:25 2016
  4 | 99999 |    | Wed Jun 22 19:10:25 2016
  5 | 99999 |    | Wed Jun 22 19:10:25 2016
  6 | 99999 |    | Wed Jun 22 19:10:25 2016
  7 | 99999 |    | Wed Jun 22 19:10:25 2016
  8 | 99999 |    | Wed Jun 22 19:10:25 2016
  9 | 99999 |    | Wed Jun 22 19:10:25 2016
 10 | 99999 |    | Wed Jun 22 19:10:25 2016
 11 | 99999 |    | Wed Jun 22 19:10:25 2016
 12 | 99999 |    | Wed Jun 22 19:10:25 2016
 13 | 99999 |    | Wed Jun 22 19:10:25 2016
 14 | 99999 |    | Wed Jun 22 19:10:25 2016
 15 | 99999 |    | Wed Jun 22 19:10:25 2016
 16 | 99999 |    | Wed Jun 22 19:10:25 2016
 17 | 99999 |    | Wed Jun 22 19:10:25 2016
 18 | 99999 |    | Wed Jun 22 19:10:25 2016
 19 | 99999 |    | Wed Jun 22 19:10:25 2016
 20 | 99999 |    | Wed Jun 22 19:10:25 2016
(20 rows)

                        QUERY PLAN                         
-----------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: c1, c2, c3, c4
   Merge Key: c1
   ->  Sort
         Output: c1, c2, c3, c4
         Sort Key: px_parallel_dml_t8.c1
         ->  Partial Seq Scan on public.px_parallel_dml_t8
               Output: c1, c2, c3, c4
 Optimizer: PolarDB PX Optimizer
(9 rows)

reset client_min_messages;
