/*--EXPLAIN_QUERY_BEGIN*/
/*--EXPLAIN_ANALYZE_BEGIN*/
drop schema if exists dpe_single cascade;
NOTICE:  schema "dpe_single" does not exist, skipping
create schema dpe_single;
set search_path='dpe_single';
set polar_px_enable_adps = off;
drop table if exists pt;
NOTICE:  table "pt" does not exist, skipping
drop table if exists pt1;
NOTICE:  table "pt1" does not exist, skipping
drop table if exists t;
NOTICE:  table "t" does not exist, skipping
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table pt(dist int, pt1 text, pt2 text, pt3 text, ptid int) 
PARTITION BY RANGE(ptid);
CREATE TABLE pt_p1 PARTITION of pt for values from (0) to (1);
CREATE TABLE pt_p2 PARTITION of pt for values from (1) to (2);
CREATE TABLE pt_p3 PARTITION of pt for values from (2) to (3);
CREATE TABLE pt_p4 PARTITION of pt for values from (3) to (4);
CREATE TABLE pt_p5 PARTITION of pt for values from (4) to (5);
CREATE TABLE pt_junk_data PARTITION of pt default;
-- pt1 table is originally created distributed randomly
-- But a random policy impacts data distribution which
-- might lead to unstable stats info. Some test cases
-- test plan thus become flaky. We avoid flakiness by
-- creating the table distributed hashly and after
-- loading all the data, changing policy to randomly without
-- data movement. Thus every time we will have a static
-- data distribution plus randomly policy.
create table pt1(dist int, pt1 text, pt2 text, pt3 text, ptid int) 
PARTITION BY RANGE(ptid); 
CREATE TABLE pt1_p1 PARTITION of pt1 for values from (0) to (1);
CREATE TABLE pt1_p2 PARTITION of pt1 for values from (1) to (2);
CREATE TABLE pt1_p3 PARTITION of pt1 for values from (2) to (3);
CREATE TABLE pt1_p4 PARTITION of pt1 for values from (3) to (4);
CREATE TABLE pt1_p5 PARTITION of pt1 for values from (4) to (5);
CREATE TABLE pt1_junk_data PARTITION of pt1 default;
create table t(dist int, tid int, t1 text, t2 text);
create index pt1_idx on pt using btree (pt1);
create index ptid_idx on pt using btree (ptid);
insert into pt select i, 'hello' || i, 'world', 'drop this', i % 6 from generate_series(0,53) i;
insert into t select i, i % 6, 'hello' || i, 'bar' from generate_series(0,1) i;
create table t1(dist int, tid int, t1 text, t2 text);
insert into t1 select i, i % 6, 'hello' || i, 'bar' from generate_series(1,2) i;
insert into pt1 select * from pt;
insert into pt1 select dist, pt1, pt2, pt3, ptid-100 from pt;
analyze pt;
analyze pt1;
analyze t;
analyze t1;
--
-- Simple positive cases
--
explain (costs off, timing off, summary off) select * from t, pt where tid = ptid;
              QUERY PLAN              
--------------------------------------
 Hash Join
   Hash Cond: (pt_p1.ptid = t.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
(11 rows)

select * from t, pt where tid = ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0  | world | drop this |    0
    0 |   0 | hello0 | bar |    6 | hello6  | world | drop this |    0
    0 |   0 | hello0 | bar |   12 | hello12 | world | drop this |    0
    0 |   0 | hello0 | bar |   18 | hello18 | world | drop this |    0
    0 |   0 | hello0 | bar |   24 | hello24 | world | drop this |    0
    0 |   0 | hello0 | bar |   30 | hello30 | world | drop this |    0
    0 |   0 | hello0 | bar |   36 | hello36 | world | drop this |    0
    0 |   0 | hello0 | bar |   42 | hello42 | world | drop this |    0
    0 |   0 | hello0 | bar |   48 | hello48 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=18 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=6 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

explain (costs off, timing off, summary off) select * from t, pt where tid + 1 = ptid;
               QUERY PLAN                
-----------------------------------------
 Hash Join
   Hash Cond: (pt_p1.ptid = (t.tid + 1))
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
(11 rows)

select * from t, pt where tid + 1 = ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    1 | hello1  | world | drop this |    1
    0 |   0 | hello0 | bar |    7 | hello7  | world | drop this |    1
    0 |   0 | hello0 | bar |   13 | hello13 | world | drop this |    1
    0 |   0 | hello0 | bar |   19 | hello19 | world | drop this |    1
    0 |   0 | hello0 | bar |   25 | hello25 | world | drop this |    1
    0 |   0 | hello0 | bar |   31 | hello31 | world | drop this |    1
    0 |   0 | hello0 | bar |   37 | hello37 | world | drop this |    1
    0 |   0 | hello0 | bar |   43 | hello43 | world | drop this |    1
    0 |   0 | hello0 | bar |   49 | hello49 | world | drop this |    1
    1 |   1 | hello1 | bar |    2 | hello2  | world | drop this |    2
    1 |   1 | hello1 | bar |    8 | hello8  | world | drop this |    2
    1 |   1 | hello1 | bar |   14 | hello14 | world | drop this |    2
    1 |   1 | hello1 | bar |   20 | hello20 | world | drop this |    2
    1 |   1 | hello1 | bar |   26 | hello26 | world | drop this |    2
    1 |   1 | hello1 | bar |   32 | hello32 | world | drop this |    2
    1 |   1 | hello1 | bar |   38 | hello38 | world | drop this |    2
    1 |   1 | hello1 | bar |   44 | hello44 | world | drop this |    2
    1 |   1 | hello1 | bar |   50 | hello50 | world | drop this |    2
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = (t.tid + 1))
 Optimizer: PolarDB PX Optimizer
(27 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=18 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=6 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (never executed)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (actual rows=3 loops=3)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = (t.tid + 1))
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = (t.tid + 1))
 Optimizer: PolarDB PX Optimizer
(27 rows)

explain (costs off, timing off, summary off) select * from t, pt where tid = ptid and t1 = 'hello' || tid;
                         QUERY PLAN                          
-------------------------------------------------------------
 Hash Join
   Hash Cond: (pt_p1.ptid = t.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
               Filter: (t1 = ('hello'::text || (tid)::text))
(12 rows)

select * from t, pt where tid = ptid and t1 = 'hello' || tid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0  | world | drop this |    0
    0 |   0 | hello0 | bar |    6 | hello6  | world | drop this |    0
    0 |   0 | hello0 | bar |   12 | hello12 | world | drop this |    0
    0 |   0 | hello0 | bar |   18 | hello18 | world | drop this |    0
    0 |   0 | hello0 | bar |   24 | hello24 | world | drop this |    0
    0 |   0 | hello0 | bar |   30 | hello30 | world | drop this |    0
    0 |   0 | hello0 | bar |   36 | hello36 | world | drop this |    0
    0 |   0 | hello0 | bar |   42 | hello42 | world | drop this |    0
    0 |   0 | hello0 | bar |   48 | hello48 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6)
               Output: t.dist, t.tid, t.t1, t.t2
               ->  Partial Seq Scan on dpe_single.t
                     Output: t.dist, t.tid, t.t1, t.t2
                     Filter: (t.t1 = ('hello'::text || (t.tid)::text))
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(30 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=18 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
               ->  Partial Seq Scan on dpe_single.t (actual rows=2 loops=1)
                     Output: t.dist, t.tid, t.t1, t.t2
                     Filter: (t.t1 = ('hello'::text || (t.tid)::text))
         ->  Append (actual rows=6 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(30 rows)

explain (costs off, timing off, summary off) select * from t, pt where t1 = pt1 and ptid = tid;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Merge Join
   Merge Cond: (pt_p1.pt1 = t.t1)
   Join Filter: (t.tid = pt_p1.ptid)
   ->  Merge Append
         Sort Key: pt_p1.pt1
         ->  Index Scan using pt_p1_pt1_idx on pt_p1
         ->  Index Scan using pt_p2_pt1_idx on pt_p2
         ->  Index Scan using pt_p3_pt1_idx on pt_p3
         ->  Index Scan using pt_p4_pt1_idx on pt_p4
         ->  Index Scan using pt_p5_pt1_idx on pt_p5
         ->  Index Scan using pt_junk_data_pt1_idx on pt_junk_data
   ->  Sort
         Sort Key: t.t1
         ->  Seq Scan on t
(14 rows)

select * from t, pt where t1 = pt1 and ptid = tid;
 dist | tid |   t1   | t2  | dist |  pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+--------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1 | world | drop this |    1
(2 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.pt1 = t.t1)
                     Filter: ((pt_p1.pt1 = t.t1) AND (pt_p1.ptid = t.tid))
               ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.pt1 = t.t1)
                     Filter: ((pt_p2.pt1 = t.t1) AND (pt_p2.ptid = t.tid))
               ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.pt1 = t.t1)
                     Filter: ((pt_p3.pt1 = t.t1) AND (pt_p3.ptid = t.tid))
               ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.pt1 = t.t1)
                     Filter: ((pt_p4.pt1 = t.t1) AND (pt_p4.ptid = t.tid))
               ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.pt1 = t.t1)
                     Filter: ((pt_p5.pt1 = t.t1) AND (pt_p5.ptid = t.tid))
               ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.pt1 = t.t1)
                     Filter: ((pt_junk_data.pt1 = t.t1) AND (pt_junk_data.ptid = t.tid))
 Optimizer: PolarDB PX Optimizer
(33 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=2 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=2 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=1 loops=3)
               ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1 (actual rows=0 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.pt1 = t.t1)
                     Filter: ((pt_p1.pt1 = t.t1) AND (pt_p1.ptid = t.tid))
               ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2 (actual rows=0 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.pt1 = t.t1)
                     Filter: ((pt_p2.pt1 = t.t1) AND (pt_p2.ptid = t.tid))
               ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.pt1 = t.t1)
                     Filter: ((pt_p3.pt1 = t.t1) AND (pt_p3.ptid = t.tid))
               ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.pt1 = t.t1)
                     Filter: ((pt_p4.pt1 = t.t1) AND (pt_p4.ptid = t.tid))
               ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.pt1 = t.t1)
                     Filter: ((pt_p5.pt1 = t.t1) AND (pt_p5.ptid = t.tid))
               ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.pt1 = t.t1)
                     Filter: ((pt_junk_data.pt1 = t.t1) AND (pt_junk_data.ptid = t.tid))
 Optimizer: PolarDB PX Optimizer
(33 rows)

--
-- in and exists clauses
--
explain (costs off, timing off, summary off) select * from pt where ptid in (select tid from t where t1 = 'hello' || tid);
                         QUERY PLAN                          
-------------------------------------------------------------
 Hash Semi Join
   Hash Cond: (pt_p1.ptid = t.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
               Filter: (t1 = ('hello'::text || (tid)::text))
(12 rows)

select * from pt where ptid in (select tid from t where t1 = 'hello' || tid);
 dist |   pt1   |  pt2  |    pt3    | ptid 
------+---------+-------+-----------+------
    0 | hello0  | world | drop this |    0
    6 | hello6  | world | drop this |    0
   12 | hello12 | world | drop this |    0
   18 | hello18 | world | drop this |    0
   24 | hello24 | world | drop this |    0
   30 | hello30 | world | drop this |    0
   36 | hello36 | world | drop this |    0
   42 | hello42 | world | drop this |    0
   48 | hello48 | world | drop this |    0
    1 | hello1  | world | drop this |    1
    7 | hello7  | world | drop this |    1
   13 | hello13 | world | drop this |    1
   19 | hello19 | world | drop this |    1
   25 | hello25 | world | drop this |    1
   31 | hello31 | world | drop this |    1
   37 | hello37 | world | drop this |    1
   43 | hello43 | world | drop this |    1
   49 | hello49 | world | drop this |    1
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Hash Join
         Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Hash Cond: (pt_p1.ptid = t.tid)
         ->  Append
               Partition Selectors: $0
               ->  Partial Seq Scan on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               ->  Partial Seq Scan on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
               ->  Partial Seq Scan on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
               ->  Partial Seq Scan on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
               ->  Partial Seq Scan on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
               ->  Partial Seq Scan on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
         ->  Hash
               Output: t.tid
               ->  Partition Selector (selector id: $0)
                     Output: t.tid
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: t.tid
                           ->  GroupAggregate
                                 Output: t.tid
                                 Group Key: t.tid
                                 ->  Sort
                                       Output: t.tid
                                       Sort Key: t.tid
                                       ->  PX Hash 6:6  (slice3; segments: 6)
                                             Output: t.tid
                                             Hash Key: t.tid
                                             ->  Partial Seq Scan on dpe_single.t
                                                   Output: t.tid
                                                   Filter: (t.t1 = ('hello'::text || (t.tid)::text))
 Optimizer: PolarDB PX Optimizer
(38 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Hash Join (actual rows=18 loops=1)
         Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Hash Cond: (pt_p1.ptid = t.tid)
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  Append (actual rows=18 loops=1)
               Partition Selectors: $0
               ->  Partial Seq Scan on dpe_single.pt_p1 (actual rows=9 loops=1)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               ->  Partial Seq Scan on dpe_single.pt_p2 (actual rows=9 loops=1)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
               ->  Partial Seq Scan on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
               ->  Partial Seq Scan on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
               ->  Partial Seq Scan on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
               ->  Partial Seq Scan on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
         ->  Hash (actual rows=2 loops=1)
               Output: t.tid
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Partition Selector (selector id: $0) (actual rows=2 loops=1)
                     Output: t.tid
                     ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=2 loops=1)
                           Output: t.tid
                           ->  GroupAggregate (actual rows=1 loops=1)
                                 Output: t.tid
                                 Group Key: t.tid
                                 ->  Sort (actual rows=1 loops=1)
                                       Output: t.tid
                                       Sort Key: t.tid
                                       work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
                                       ->  PX Hash 6:6  (slice3; segments: 6) (actual rows=1 loops=1)
                                             Output: t.tid
                                             Hash Key: t.tid
                                             ->  Partial Seq Scan on dpe_single.t (actual rows=2 loops=1)
                                                   Output: t.tid
                                                   Filter: (t.t1 = ('hello'::text || (t.tid)::text))
 Optimizer: PolarDB PX Optimizer
(41 rows)

-- start_ignore
-- Known_opt_diff: MPP-21320
-- end_ignore
explain (costs off, timing off, summary off) select * from pt where exists (select 1 from t where tid = ptid and t1 = 'hello' || tid);
                         QUERY PLAN                          
-------------------------------------------------------------
 Hash Semi Join
   Hash Cond: (pt_p1.ptid = t.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
               Filter: (t1 = ('hello'::text || (tid)::text))
(12 rows)

select * from pt where exists (select 1 from t where tid = ptid and t1 = 'hello' || tid);
 dist |   pt1   |  pt2  |    pt3    | ptid 
------+---------+-------+-----------+------
    0 | hello0  | world | drop this |    0
    6 | hello6  | world | drop this |    0
   12 | hello12 | world | drop this |    0
   18 | hello18 | world | drop this |    0
   24 | hello24 | world | drop this |    0
   30 | hello30 | world | drop this |    0
   36 | hello36 | world | drop this |    0
   42 | hello42 | world | drop this |    0
   48 | hello48 | world | drop this |    0
    1 | hello1  | world | drop this |    1
    7 | hello7  | world | drop this |    1
   13 | hello13 | world | drop this |    1
   19 | hello19 | world | drop this |    1
   25 | hello25 | world | drop this |    1
   31 | hello31 | world | drop this |    1
   37 | hello37 | world | drop this |    1
   43 | hello43 | world | drop this |    1
   49 | hello49 | world | drop this |    1
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Hash Join
         Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Hash Cond: (pt_p1.ptid = t.tid)
         ->  Append
               Partition Selectors: $0
               ->  Partial Seq Scan on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               ->  Partial Seq Scan on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
               ->  Partial Seq Scan on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
               ->  Partial Seq Scan on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
               ->  Partial Seq Scan on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
               ->  Partial Seq Scan on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
         ->  Hash
               Output: t.tid
               ->  Partition Selector (selector id: $0)
                     Output: t.tid
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: t.tid
                           ->  GroupAggregate
                                 Output: t.tid
                                 Group Key: t.tid
                                 ->  Sort
                                       Output: t.tid
                                       Sort Key: t.tid
                                       ->  PX Hash 6:6  (slice3; segments: 6)
                                             Output: t.tid
                                             Hash Key: t.tid
                                             ->  Partial Seq Scan on dpe_single.t
                                                   Output: t.tid
                                                   Filter: (t.t1 = ('hello'::text || (t.tid)::text))
 Optimizer: PolarDB PX Optimizer
(38 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Hash Join (actual rows=18 loops=1)
         Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Hash Cond: (pt_p1.ptid = t.tid)
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  Append (actual rows=18 loops=1)
               Partition Selectors: $0
               ->  Partial Seq Scan on dpe_single.pt_p1 (actual rows=9 loops=1)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               ->  Partial Seq Scan on dpe_single.pt_p2 (actual rows=9 loops=1)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
               ->  Partial Seq Scan on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
               ->  Partial Seq Scan on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
               ->  Partial Seq Scan on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
               ->  Partial Seq Scan on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
         ->  Hash (actual rows=2 loops=1)
               Output: t.tid
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Partition Selector (selector id: $0) (actual rows=2 loops=1)
                     Output: t.tid
                     ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=2 loops=1)
                           Output: t.tid
                           ->  GroupAggregate (actual rows=1 loops=1)
                                 Output: t.tid
                                 Group Key: t.tid
                                 ->  Sort (actual rows=1 loops=1)
                                       Output: t.tid
                                       Sort Key: t.tid
                                       work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
                                       ->  PX Hash 6:6  (slice3; segments: 6) (actual rows=1 loops=1)
                                             Output: t.tid
                                             Hash Key: t.tid
                                             ->  Partial Seq Scan on dpe_single.t (actual rows=2 loops=1)
                                                   Output: t.tid
                                                   Filter: (t.t1 = ('hello'::text || (t.tid)::text))
 Optimizer: PolarDB PX Optimizer
(41 rows)

--
-- group-by on top
--
explain (costs off, timing off, summary off) select count(*) from t, pt where tid = ptid;
                 QUERY PLAN                 
--------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (pt_p1.ptid = t.tid)
         ->  Append
               ->  Seq Scan on pt_p1
               ->  Seq Scan on pt_p2
               ->  Seq Scan on pt_p3
               ->  Seq Scan on pt_p4
               ->  Seq Scan on pt_p5
               ->  Seq Scan on pt_junk_data
         ->  Hash
               ->  Seq Scan on t
(12 rows)

select count(*) from t, pt where tid = ptid;
 count 
-------
    18
(1 row)

                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Nested Loop
                     Join Filter: true
                     ->  PX Broadcast 6:6  (slice2; segments: 6)
                           Output: t.tid
                           ->  Partial Seq Scan on dpe_single.t
                                 Output: t.tid
                     ->  Append
                           ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                                 Output: pt_p1.ptid
                                 Index Cond: (pt_p1.ptid = t.tid)
                           ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                                 Output: pt_p2.ptid
                                 Index Cond: (pt_p2.ptid = t.tid)
                           ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                                 Output: pt_p3.ptid
                                 Index Cond: (pt_p3.ptid = t.tid)
                           ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                                 Output: pt_p4.ptid
                                 Index Cond: (pt_p4.ptid = t.tid)
                           ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                                 Output: pt_p5.ptid
                                 Index Cond: (pt_p5.ptid = t.tid)
                           ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                                 Output: pt_junk_data.ptid
                                 Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(32 rows)

                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6) (actual rows=6 loops=1)
         Output: (PARTIAL count())
         ->  Partial Aggregate (actual rows=1 loops=1)
               Output: PARTIAL count()
               ->  Nested Loop (actual rows=18 loops=1)
                     Join Filter: true
                     ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=2 loops=1)
                           Output: t.tid
                           ->  Partial Seq Scan on dpe_single.t (actual rows=2 loops=1)
                                 Output: t.tid
                     ->  Append (actual rows=6 loops=3)
                           ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                                 Output: pt_p1.ptid
                                 Index Cond: (pt_p1.ptid = t.tid)
                           ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                                 Output: pt_p2.ptid
                                 Index Cond: (pt_p2.ptid = t.tid)
                           ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                                 Output: pt_p3.ptid
                                 Index Cond: (pt_p3.ptid = t.tid)
                           ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                                 Output: pt_p4.ptid
                                 Index Cond: (pt_p4.ptid = t.tid)
                           ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                                 Output: pt_p5.ptid
                                 Index Cond: (pt_p5.ptid = t.tid)
                           ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                                 Output: pt_junk_data.ptid
                                 Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(32 rows)

--
-- window function on top
--
explain (costs off, timing off, summary off) select *, rank() over (order by ptid,pt1) from t, pt where tid = ptid;
                    QUERY PLAN                    
--------------------------------------------------
 WindowAgg
   ->  Sort
         Sort Key: pt_p1.ptid, pt_p1.pt1
         ->  Hash Join
               Hash Cond: (pt_p1.ptid = t.tid)
               ->  Append
                     ->  Seq Scan on pt_p1
                     ->  Seq Scan on pt_p2
                     ->  Seq Scan on pt_p3
                     ->  Seq Scan on pt_p4
                     ->  Seq Scan on pt_p5
                     ->  Seq Scan on pt_junk_data
               ->  Hash
                     ->  Seq Scan on t
(14 rows)

select *, rank() over (order by ptid,pt1) from t, pt where tid = ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid | rank 
------+-----+--------+-----+------+---------+-------+-----------+------+------
    0 |   0 | hello0 | bar |    0 | hello0  | world | drop this |    0 |    1
    0 |   0 | hello0 | bar |   12 | hello12 | world | drop this |    0 |    2
    0 |   0 | hello0 | bar |   18 | hello18 | world | drop this |    0 |    3
    0 |   0 | hello0 | bar |   24 | hello24 | world | drop this |    0 |    4
    0 |   0 | hello0 | bar |   30 | hello30 | world | drop this |    0 |    5
    0 |   0 | hello0 | bar |   36 | hello36 | world | drop this |    0 |    6
    0 |   0 | hello0 | bar |   42 | hello42 | world | drop this |    0 |    7
    0 |   0 | hello0 | bar |   48 | hello48 | world | drop this |    0 |    8
    0 |   0 | hello0 | bar |    6 | hello6  | world | drop this |    0 |    9
    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1 |   10
    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1 |   11
    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1 |   12
    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1 |   13
    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1 |   14
    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1 |   15
    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1 |   16
    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1 |   17
    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1 |   18
(18 rows)

                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, rank() OVER (?)
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Merge Key: pt_p1.ptid, pt_p1.pt1
         ->  Sort
               Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               Sort Key: pt_p1.ptid, pt_p1.pt1
               ->  Nested Loop
                     Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Join Filter: true
                     ->  Full Seq Scan on dpe_single.t
                           Output: t.dist, t.tid, t.t1, t.t2
                     ->  Append
                           ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                                 Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                                 Index Cond: (pt_p1.ptid = t.tid)
                           ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                                 Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                                 Index Cond: (pt_p2.ptid = t.tid)
                           ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                                 Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                                 Index Cond: (pt_p3.ptid = t.tid)
                           ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                                 Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                                 Index Cond: (pt_p4.ptid = t.tid)
                           ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                                 Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                                 Index Cond: (pt_p5.ptid = t.tid)
                           ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                                 Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                                 Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(33 rows)

                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg (actual rows=18 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, rank() OVER (?)
   ->  PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Merge Key: pt_p1.ptid, pt_p1.pt1
         ->  Sort (actual rows=18 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               Sort Key: pt_p1.ptid, pt_p1.pt1
               work_mem: 209kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
               ->  Nested Loop (actual rows=18 loops=1)
                     Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Join Filter: true
                     ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
                           Output: t.dist, t.tid, t.t1, t.t2
                     ->  Append (actual rows=6 loops=3)
                           ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                                 Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                                 Index Cond: (pt_p1.ptid = t.tid)
                           ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                                 Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                                 Index Cond: (pt_p2.ptid = t.tid)
                           ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                                 Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                                 Index Cond: (pt_p3.ptid = t.tid)
                           ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                                 Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                                 Index Cond: (pt_p4.ptid = t.tid)
                           ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                                 Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                                 Index Cond: (pt_p5.ptid = t.tid)
                           ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                                 Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                                 Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(34 rows)

--
-- set ops
--
explain (costs off, timing off, summary off) select * from t, pt where tid = ptid
	  union all
	  select * from t, pt where tid + 2 = ptid;
                        QUERY PLAN                         
-----------------------------------------------------------
 Append
   ->  Hash Join
         Hash Cond: (pt_p1.ptid = t.tid)
         ->  Append
               ->  Seq Scan on pt_p1
               ->  Seq Scan on pt_p2
               ->  Seq Scan on pt_p3
               ->  Seq Scan on pt_p4
               ->  Seq Scan on pt_p5
               ->  Seq Scan on pt_junk_data
         ->  Hash
               ->  Seq Scan on t
   ->  Hash Join
         Hash Cond: (pt_p1_1.ptid = (t_1.tid + 2))
         ->  Append
               ->  Seq Scan on pt_p1 pt_p1_1
               ->  Seq Scan on pt_p2 pt_p2_1
               ->  Seq Scan on pt_p3 pt_p3_1
               ->  Seq Scan on pt_p4 pt_p4_1
               ->  Seq Scan on pt_p5 pt_p5_1
               ->  Seq Scan on pt_junk_data pt_junk_data_1
         ->  Hash
               ->  Seq Scan on t t_1
(23 rows)

select * from t, pt where tid = ptid
	  union all
	  select * from t, pt where tid + 2 = ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0  | world | drop this |    0
    0 |   0 | hello0 | bar |    6 | hello6  | world | drop this |    0
    0 |   0 | hello0 | bar |   12 | hello12 | world | drop this |    0
    0 |   0 | hello0 | bar |   18 | hello18 | world | drop this |    0
    0 |   0 | hello0 | bar |   24 | hello24 | world | drop this |    0
    0 |   0 | hello0 | bar |   30 | hello30 | world | drop this |    0
    0 |   0 | hello0 | bar |   36 | hello36 | world | drop this |    0
    0 |   0 | hello0 | bar |   42 | hello42 | world | drop this |    0
    0 |   0 | hello0 | bar |   48 | hello48 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
    0 |   0 | hello0 | bar |    2 | hello2  | world | drop this |    2
    0 |   0 | hello0 | bar |    8 | hello8  | world | drop this |    2
    0 |   0 | hello0 | bar |   14 | hello14 | world | drop this |    2
    0 |   0 | hello0 | bar |   20 | hello20 | world | drop this |    2
    0 |   0 | hello0 | bar |   26 | hello26 | world | drop this |    2
    0 |   0 | hello0 | bar |   32 | hello32 | world | drop this |    2
    0 |   0 | hello0 | bar |   38 | hello38 | world | drop this |    2
    0 |   0 | hello0 | bar |   44 | hello44 | world | drop this |    2
    0 |   0 | hello0 | bar |   50 | hello50 | world | drop this |    2
    1 |   1 | hello1 | bar |    3 | hello3  | world | drop this |    3
    1 |   1 | hello1 | bar |    9 | hello9  | world | drop this |    3
    1 |   1 | hello1 | bar |   15 | hello15 | world | drop this |    3
    1 |   1 | hello1 | bar |   21 | hello21 | world | drop this |    3
    1 |   1 | hello1 | bar |   27 | hello27 | world | drop this |    3
    1 |   1 | hello1 | bar |   33 | hello33 | world | drop this |    3
    1 |   1 | hello1 | bar |   39 | hello39 | world | drop this |    3
    1 |   1 | hello1 | bar |   45 | hello45 | world | drop this |    3
    1 |   1 | hello1 | bar |   51 | hello51 | world | drop this |    3
(36 rows)

                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Append
         ->  Nested Loop
               Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               Join Filter: true
               ->  Full Seq Scan on dpe_single.t
                     Output: t.dist, t.tid, t.t1, t.t2
               ->  Append
                     ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                           Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                           Index Cond: (pt_p1.ptid = t.tid)
                     ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                           Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                           Index Cond: (pt_p2.ptid = t.tid)
                     ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                           Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                           Index Cond: (pt_p3.ptid = t.tid)
                     ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                           Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                           Index Cond: (pt_p4.ptid = t.tid)
                     ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                           Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                           Index Cond: (pt_p5.ptid = t.tid)
                     ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                           Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                           Index Cond: (pt_junk_data.ptid = t.tid)
         ->  Nested Loop
               Output: t_1.dist, t_1.tid, t_1.t1, t_1.t2, pt_p1_1.dist, pt_p1_1.pt1, pt_p1_1.pt2, pt_p1_1.pt3, pt_p1_1.ptid
               Join Filter: true
               ->  Full Seq Scan on dpe_single.t t_1
                     Output: t_1.dist, t_1.tid, t_1.t1, t_1.t2
               ->  Append
                     ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 pt_p1_1
                           Output: pt_p1_1.dist, pt_p1_1.pt1, pt_p1_1.pt2, pt_p1_1.pt3, pt_p1_1.ptid
                           Index Cond: (pt_p1_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 pt_p2_1
                           Output: pt_p2_1.dist, pt_p2_1.pt1, pt_p2_1.pt2, pt_p2_1.pt3, pt_p2_1.ptid
                           Index Cond: (pt_p2_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 pt_p3_1
                           Output: pt_p3_1.dist, pt_p3_1.pt1, pt_p3_1.pt2, pt_p3_1.pt3, pt_p3_1.ptid
                           Index Cond: (pt_p3_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 pt_p4_1
                           Output: pt_p4_1.dist, pt_p4_1.pt1, pt_p4_1.pt2, pt_p4_1.pt3, pt_p4_1.ptid
                           Index Cond: (pt_p4_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 pt_p5_1
                           Output: pt_p5_1.dist, pt_p5_1.pt1, pt_p5_1.pt2, pt_p5_1.pt3, pt_p5_1.ptid
                           Index Cond: (pt_p5_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data pt_junk_data_1
                           Output: pt_junk_data_1.dist, pt_junk_data_1.pt1, pt_junk_data_1.pt2, pt_junk_data_1.pt3, pt_junk_data_1.ptid
                           Index Cond: (pt_junk_data_1.ptid = (t_1.tid + 2))
 Optimizer: PolarDB PX Optimizer
(52 rows)

                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=36 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Append (actual rows=36 loops=1)
         ->  Nested Loop (actual rows=18 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               Join Filter: true
               ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
                     Output: t.dist, t.tid, t.t1, t.t2
               ->  Append (actual rows=6 loops=3)
                     ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                           Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                           Index Cond: (pt_p1.ptid = t.tid)
                     ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                           Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                           Index Cond: (pt_p2.ptid = t.tid)
                     ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                           Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                           Index Cond: (pt_p3.ptid = t.tid)
                     ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                           Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                           Index Cond: (pt_p4.ptid = t.tid)
                     ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                           Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                           Index Cond: (pt_p5.ptid = t.tid)
                     ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                           Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                           Index Cond: (pt_junk_data.ptid = t.tid)
         ->  Nested Loop (actual rows=18 loops=1)
               Output: t_1.dist, t_1.tid, t_1.t1, t_1.t2, pt_p1_1.dist, pt_p1_1.pt1, pt_p1_1.pt2, pt_p1_1.pt3, pt_p1_1.ptid
               Join Filter: true
               ->  Full Seq Scan on dpe_single.t t_1 (actual rows=2 loops=1)
                     Output: t_1.dist, t_1.tid, t_1.t1, t_1.t2
               ->  Append (actual rows=6 loops=3)
                     ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 pt_p1_1 (never executed)
                           Output: pt_p1_1.dist, pt_p1_1.pt1, pt_p1_1.pt2, pt_p1_1.pt3, pt_p1_1.ptid
                           Index Cond: (pt_p1_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 pt_p2_1 (never executed)
                           Output: pt_p2_1.dist, pt_p2_1.pt1, pt_p2_1.pt2, pt_p2_1.pt3, pt_p2_1.ptid
                           Index Cond: (pt_p2_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 pt_p3_1 (actual rows=3 loops=3)
                           Output: pt_p3_1.dist, pt_p3_1.pt1, pt_p3_1.pt2, pt_p3_1.pt3, pt_p3_1.ptid
                           Index Cond: (pt_p3_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 pt_p4_1 (actual rows=3 loops=3)
                           Output: pt_p4_1.dist, pt_p4_1.pt1, pt_p4_1.pt2, pt_p4_1.pt3, pt_p4_1.ptid
                           Index Cond: (pt_p4_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 pt_p5_1 (never executed)
                           Output: pt_p5_1.dist, pt_p5_1.pt1, pt_p5_1.pt2, pt_p5_1.pt3, pt_p5_1.ptid
                           Index Cond: (pt_p5_1.ptid = (t_1.tid + 2))
                     ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data pt_junk_data_1 (never executed)
                           Output: pt_junk_data_1.dist, pt_junk_data_1.pt1, pt_junk_data_1.pt2, pt_junk_data_1.pt3, pt_junk_data_1.ptid
                           Index Cond: (pt_junk_data_1.ptid = (t_1.tid + 2))
 Optimizer: PolarDB PX Optimizer
(52 rows)

--
-- set-ops
--
explain (costs off, timing off, summary off) select count(*) from
	( select * from t, pt where tid = ptid
	  union all
	  select * from t, pt where tid + 2 = ptid
	  ) foo;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Subquery Scan on "*SELECT* 1"
               ->  Hash Join
                     Hash Cond: (pt_p1.ptid = t.tid)
                     ->  Append
                           ->  Seq Scan on pt_p1
                           ->  Seq Scan on pt_p2
                           ->  Seq Scan on pt_p3
                           ->  Seq Scan on pt_p4
                           ->  Seq Scan on pt_p5
                           ->  Seq Scan on pt_junk_data
                     ->  Hash
                           ->  Seq Scan on t
         ->  Subquery Scan on "*SELECT* 2"
               ->  Hash Join
                     Hash Cond: (pt_p1_1.ptid = (t_1.tid + 2))
                     ->  Append
                           ->  Seq Scan on pt_p1 pt_p1_1
                           ->  Seq Scan on pt_p2 pt_p2_1
                           ->  Seq Scan on pt_p3 pt_p3_1
                           ->  Seq Scan on pt_p4 pt_p4_1
                           ->  Seq Scan on pt_p5 pt_p5_1
                           ->  Seq Scan on pt_junk_data pt_junk_data_1
                     ->  Hash
                           ->  Seq Scan on t t_1
(26 rows)

select count(*) from
	( select * from t, pt where tid = ptid
	  union all
	  select * from t, pt where tid + 2 = ptid
	  ) foo;
 count 
-------
    36
(1 row)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Nested Loop
                           Join Filter: true
                           ->  PX Broadcast 6:6  (slice2; segments: 6)
                                 Output: t.tid
                                 ->  Partial Seq Scan on dpe_single.t
                                       Output: t.tid
                           ->  Append
                                 ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                                       Output: pt_p1.ptid
                                       Index Cond: (pt_p1.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                                       Output: pt_p2.ptid
                                       Index Cond: (pt_p2.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                                       Output: pt_p3.ptid
                                       Index Cond: (pt_p3.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                                       Output: pt_p4.ptid
                                       Index Cond: (pt_p4.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                                       Output: pt_p5.ptid
                                       Index Cond: (pt_p5.ptid = t.tid)
                                 ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                                       Output: pt_junk_data.ptid
                                       Index Cond: (pt_junk_data.ptid = t.tid)
                     ->  Nested Loop
                           Join Filter: true
                           ->  PX Broadcast 6:6  (slice3; segments: 6)
                                 Output: t_1.tid
                                 ->  Partial Seq Scan on dpe_single.t t_1
                                       Output: t_1.tid
                           ->  Append
                                 ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 pt_p1_1
                                       Output: pt_p1_1.ptid
                                       Index Cond: (pt_p1_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 pt_p2_1
                                       Output: pt_p2_1.ptid
                                       Index Cond: (pt_p2_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 pt_p3_1
                                       Output: pt_p3_1.ptid
                                       Index Cond: (pt_p3_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 pt_p4_1
                                       Output: pt_p4_1.ptid
                                       Index Cond: (pt_p4_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 pt_p5_1
                                       Output: pt_p5_1.ptid
                                       Index Cond: (pt_p5_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data pt_junk_data_1
                                       Output: pt_junk_data_1.ptid
                                       Index Cond: (pt_junk_data_1.ptid = (t_1.tid + 2))
 Optimizer: PolarDB PX Optimizer
(58 rows)

                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6) (actual rows=6 loops=1)
         Output: (PARTIAL count())
         ->  Partial Aggregate (actual rows=1 loops=1)
               Output: PARTIAL count()
               ->  Append (actual rows=36 loops=1)
                     ->  Nested Loop (actual rows=18 loops=1)
                           Join Filter: true
                           ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=2 loops=1)
                                 Output: t.tid
                                 ->  Partial Seq Scan on dpe_single.t (actual rows=2 loops=1)
                                       Output: t.tid
                           ->  Append (actual rows=6 loops=3)
                                 ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                                       Output: pt_p1.ptid
                                       Index Cond: (pt_p1.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                                       Output: pt_p2.ptid
                                       Index Cond: (pt_p2.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                                       Output: pt_p3.ptid
                                       Index Cond: (pt_p3.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                                       Output: pt_p4.ptid
                                       Index Cond: (pt_p4.ptid = t.tid)
                                 ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                                       Output: pt_p5.ptid
                                       Index Cond: (pt_p5.ptid = t.tid)
                                 ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                                       Output: pt_junk_data.ptid
                                       Index Cond: (pt_junk_data.ptid = t.tid)
                     ->  Nested Loop (actual rows=18 loops=1)
                           Join Filter: true
                           ->  PX Broadcast 6:6  (slice3; segments: 6) (actual rows=2 loops=1)
                                 Output: t_1.tid
                                 ->  Partial Seq Scan on dpe_single.t t_1 (actual rows=2 loops=1)
                                       Output: t_1.tid
                           ->  Append (actual rows=6 loops=3)
                                 ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 pt_p1_1 (never executed)
                                       Output: pt_p1_1.ptid
                                       Index Cond: (pt_p1_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 pt_p2_1 (never executed)
                                       Output: pt_p2_1.ptid
                                       Index Cond: (pt_p2_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 pt_p3_1 (actual rows=3 loops=3)
                                       Output: pt_p3_1.ptid
                                       Index Cond: (pt_p3_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 pt_p4_1 (actual rows=3 loops=3)
                                       Output: pt_p4_1.ptid
                                       Index Cond: (pt_p4_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 pt_p5_1 (never executed)
                                       Output: pt_p5_1.ptid
                                       Index Cond: (pt_p5_1.ptid = (t_1.tid + 2))
                                 ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data pt_junk_data_1 (never executed)
                                       Output: pt_junk_data_1.ptid
                                       Index Cond: (pt_junk_data_1.ptid = (t_1.tid + 2))
 Optimizer: PolarDB PX Optimizer
(58 rows)

--
-- other join types (NL)
--
set polar_px_optimizer_enable_hashjoin=off;
set polar_px_optimizer_enable_nestloopjoin=on;
set polar_px_optimizer_enable_mergejoin=off;
explain (costs off, timing off, summary off) select * from t, pt where tid = ptid;
              QUERY PLAN              
--------------------------------------
 Hash Join
   Hash Cond: (pt_p1.ptid = t.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
(11 rows)

select * from t, pt where tid = ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0  | world | drop this |    0
    0 |   0 | hello0 | bar |    6 | hello6  | world | drop this |    0
    0 |   0 | hello0 | bar |   12 | hello12 | world | drop this |    0
    0 |   0 | hello0 | bar |   18 | hello18 | world | drop this |    0
    0 |   0 | hello0 | bar |   24 | hello24 | world | drop this |    0
    0 |   0 | hello0 | bar |   30 | hello30 | world | drop this |    0
    0 |   0 | hello0 | bar |   36 | hello36 | world | drop this |    0
    0 |   0 | hello0 | bar |   42 | hello42 | world | drop this |    0
    0 |   0 | hello0 | bar |   48 | hello48 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=18 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=6 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

--
-- index scan
--
set polar_px_optimizer_enable_nestloopjoin=on;
set polar_px_optimizer_enable_seqscan=off;
set polar_px_optimizer_enable_indexscan=on;
set polar_px_optimizer_enable_bitmapscan=off;
set polar_px_optimizer_enable_hashjoin=off;
-- start_ignore
-- Known_opt_diff: MPP-21322
-- end_ignore
explain (costs off, timing off, summary off) select * from t, pt where tid = ptid and pt1 = 'hello0';
                  QUERY PLAN                  
----------------------------------------------
 Nested Loop
   Join Filter: (t.tid = pt_p1.ptid)
   ->  Append
         ->  Seq Scan on pt_p1
               Filter: (pt1 = 'hello0'::text)
         ->  Seq Scan on pt_p2
               Filter: (pt1 = 'hello0'::text)
         ->  Seq Scan on pt_p3
               Filter: (pt1 = 'hello0'::text)
         ->  Seq Scan on pt_p4
               Filter: (pt1 = 'hello0'::text)
         ->  Seq Scan on pt_p5
               Filter: (pt1 = 'hello0'::text)
         ->  Seq Scan on pt_junk_data
               Filter: (pt1 = 'hello0'::text)
   ->  Materialize
         ->  Seq Scan on t
(17 rows)

select * from t, pt where tid = ptid and pt1 = 'hello0';
 dist | tid |   t1   | t2  | dist |  pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+--------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0 | world | drop this |    0
(1 row)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
                     Filter: ((pt_p1.ptid = t.tid) AND (pt_p1.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
                     Filter: ((pt_p2.ptid = t.tid) AND (pt_p2.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
                     Filter: ((pt_p3.ptid = t.tid) AND (pt_p3.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
                     Filter: ((pt_p4.ptid = t.tid) AND (pt_p4.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
                     Filter: ((pt_p5.ptid = t.tid) AND (pt_p5.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
                     Filter: ((pt_junk_data.ptid = t.tid) AND (pt_junk_data.pt1 = 'hello0'::text))
 Optimizer: PolarDB PX Optimizer
(33 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=1 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=1 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=0 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=0 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
                     Filter: ((pt_p1.ptid = t.tid) AND (pt_p1.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (never executed)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
                     Filter: ((pt_p2.ptid = t.tid) AND (pt_p2.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
                     Filter: ((pt_p3.ptid = t.tid) AND (pt_p3.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
                     Filter: ((pt_p4.ptid = t.tid) AND (pt_p4.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
                     Filter: ((pt_p5.ptid = t.tid) AND (pt_p5.pt1 = 'hello0'::text))
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
                     Filter: ((pt_junk_data.ptid = t.tid) AND (pt_junk_data.pt1 = 'hello0'::text))
 Optimizer: PolarDB PX Optimizer
(33 rows)

--
-- NL Index Scan
--
set polar_px_optimizer_enable_nestloopjoin=on;
set polar_px_optimizer_enable_indexscan=on;
set polar_px_optimizer_enable_seqscan=off;
set polar_px_optimizer_enable_hashjoin=off;
explain (costs off, timing off, summary off) select * from t, pt where tid = ptid;
              QUERY PLAN              
--------------------------------------
 Hash Join
   Hash Cond: (pt_p1.ptid = t.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Seq Scan on t
(11 rows)

select * from t, pt where tid = ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0  | world | drop this |    0
    0 |   0 | hello0 | bar |    6 | hello6  | world | drop this |    0
    0 |   0 | hello0 | bar |   12 | hello12 | world | drop this |    0
    0 |   0 | hello0 | bar |   18 | hello18 | world | drop this |    0
    0 |   0 | hello0 | bar |   24 | hello24 | world | drop this |    0
    0 |   0 | hello0 | bar |   30 | hello30 | world | drop this |    0
    0 |   0 | hello0 | bar |   36 | hello36 | world | drop this |    0
    0 |   0 | hello0 | bar |   42 | hello42 | world | drop this |    0
    0 |   0 | hello0 | bar |   48 | hello48 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
(18 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=18 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=18 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=6 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (actual rows=3 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid = t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid = t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid = t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid = t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid = t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid = t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

--
-- Negative test cases where transform does not apply
--
set polar_px_optimizer_enable_indexscan=off;
set polar_px_optimizer_enable_seqscan=on;
set polar_px_optimizer_enable_hashjoin=on;
set polar_px_optimizer_enable_nestloopjoin=off;
explain (costs off, timing off, summary off) select * from t, pt where t1 = pt1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Merge Join
   Merge Cond: (pt_p1.pt1 = t.t1)
   ->  Merge Append
         Sort Key: pt_p1.pt1
         ->  Index Scan using pt_p1_pt1_idx on pt_p1
         ->  Index Scan using pt_p2_pt1_idx on pt_p2
         ->  Index Scan using pt_p3_pt1_idx on pt_p3
         ->  Index Scan using pt_p4_pt1_idx on pt_p4
         ->  Index Scan using pt_p5_pt1_idx on pt_p5
         ->  Index Scan using pt_junk_data_pt1_idx on pt_junk_data
   ->  Sort
         Sort Key: t.t1
         ->  Seq Scan on t
(13 rows)

select * from t, pt where t1 = pt1;
 dist | tid |   t1   | t2  | dist |  pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+--------+-------+-----------+------
    0 |   0 | hello0 | bar |    0 | hello0 | world | drop this |    0
    1 |   1 | hello1 | bar |    1 | hello1 | world | drop this |    1
(2 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.pt1 = t.t1)
               ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.pt1 = t.t1)
               ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.pt1 = t.t1)
               ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.pt1 = t.t1)
               ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.pt1 = t.t1)
               ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.pt1 = t.t1)
 Optimizer: PolarDB PX Optimizer
(27 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=2 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=2 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=1 loops=3)
               ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1 (actual rows=0 loops=3)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.pt1 = t.t1)
               ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2 (actual rows=0 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.pt1 = t.t1)
               ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3 (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.pt1 = t.t1)
               ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4 (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.pt1 = t.t1)
               ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5 (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.pt1 = t.t1)
               ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.pt1 = t.t1)
 Optimizer: PolarDB PX Optimizer
(27 rows)

explain (costs off, timing off, summary off) select * from t, pt where tid < ptid;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   Join Filter: (t.tid < pt_p1.ptid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Materialize
         ->  Seq Scan on t
(11 rows)

select * from t, pt where tid < ptid;
 dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+---------+-------+-----------+------
    0 |   0 | hello0 | bar |    1 | hello1  | world | drop this |    1
    0 |   0 | hello0 | bar |    7 | hello7  | world | drop this |    1
    0 |   0 | hello0 | bar |   13 | hello13 | world | drop this |    1
    0 |   0 | hello0 | bar |   19 | hello19 | world | drop this |    1
    0 |   0 | hello0 | bar |   25 | hello25 | world | drop this |    1
    0 |   0 | hello0 | bar |   31 | hello31 | world | drop this |    1
    0 |   0 | hello0 | bar |   37 | hello37 | world | drop this |    1
    0 |   0 | hello0 | bar |   43 | hello43 | world | drop this |    1
    0 |   0 | hello0 | bar |   49 | hello49 | world | drop this |    1
    0 |   0 | hello0 | bar |    2 | hello2  | world | drop this |    2
    1 |   1 | hello1 | bar |    2 | hello2  | world | drop this |    2
    0 |   0 | hello0 | bar |    8 | hello8  | world | drop this |    2
    1 |   1 | hello1 | bar |    8 | hello8  | world | drop this |    2
    0 |   0 | hello0 | bar |   14 | hello14 | world | drop this |    2
    1 |   1 | hello1 | bar |   14 | hello14 | world | drop this |    2
    0 |   0 | hello0 | bar |   20 | hello20 | world | drop this |    2
    1 |   1 | hello1 | bar |   20 | hello20 | world | drop this |    2
    0 |   0 | hello0 | bar |   26 | hello26 | world | drop this |    2
    1 |   1 | hello1 | bar |   26 | hello26 | world | drop this |    2
    0 |   0 | hello0 | bar |   32 | hello32 | world | drop this |    2
    1 |   1 | hello1 | bar |   32 | hello32 | world | drop this |    2
    0 |   0 | hello0 | bar |   38 | hello38 | world | drop this |    2
    1 |   1 | hello1 | bar |   38 | hello38 | world | drop this |    2
    0 |   0 | hello0 | bar |   44 | hello44 | world | drop this |    2
    1 |   1 | hello1 | bar |   44 | hello44 | world | drop this |    2
    0 |   0 | hello0 | bar |   50 | hello50 | world | drop this |    2
    1 |   1 | hello1 | bar |   50 | hello50 | world | drop this |    2
    0 |   0 | hello0 | bar |    3 | hello3  | world | drop this |    3
    1 |   1 | hello1 | bar |    3 | hello3  | world | drop this |    3
    0 |   0 | hello0 | bar |    9 | hello9  | world | drop this |    3
    1 |   1 | hello1 | bar |    9 | hello9  | world | drop this |    3
    0 |   0 | hello0 | bar |   15 | hello15 | world | drop this |    3
    1 |   1 | hello1 | bar |   15 | hello15 | world | drop this |    3
    0 |   0 | hello0 | bar |   21 | hello21 | world | drop this |    3
    1 |   1 | hello1 | bar |   21 | hello21 | world | drop this |    3
    0 |   0 | hello0 | bar |   27 | hello27 | world | drop this |    3
    1 |   1 | hello1 | bar |   27 | hello27 | world | drop this |    3
    0 |   0 | hello0 | bar |   33 | hello33 | world | drop this |    3
    1 |   1 | hello1 | bar |   33 | hello33 | world | drop this |    3
    0 |   0 | hello0 | bar |   39 | hello39 | world | drop this |    3
    1 |   1 | hello1 | bar |   39 | hello39 | world | drop this |    3
    0 |   0 | hello0 | bar |   45 | hello45 | world | drop this |    3
    1 |   1 | hello1 | bar |   45 | hello45 | world | drop this |    3
    0 |   0 | hello0 | bar |   51 | hello51 | world | drop this |    3
    1 |   1 | hello1 | bar |   51 | hello51 | world | drop this |    3
    0 |   0 | hello0 | bar |    4 | hello4  | world | drop this |    4
    1 |   1 | hello1 | bar |    4 | hello4  | world | drop this |    4
    0 |   0 | hello0 | bar |   10 | hello10 | world | drop this |    4
    1 |   1 | hello1 | bar |   10 | hello10 | world | drop this |    4
    0 |   0 | hello0 | bar |   16 | hello16 | world | drop this |    4
    1 |   1 | hello1 | bar |   16 | hello16 | world | drop this |    4
    0 |   0 | hello0 | bar |   22 | hello22 | world | drop this |    4
    1 |   1 | hello1 | bar |   22 | hello22 | world | drop this |    4
    0 |   0 | hello0 | bar |   28 | hello28 | world | drop this |    4
    1 |   1 | hello1 | bar |   28 | hello28 | world | drop this |    4
    0 |   0 | hello0 | bar |   34 | hello34 | world | drop this |    4
    1 |   1 | hello1 | bar |   34 | hello34 | world | drop this |    4
    0 |   0 | hello0 | bar |   40 | hello40 | world | drop this |    4
    1 |   1 | hello1 | bar |   40 | hello40 | world | drop this |    4
    0 |   0 | hello0 | bar |   46 | hello46 | world | drop this |    4
    1 |   1 | hello1 | bar |   46 | hello46 | world | drop this |    4
    0 |   0 | hello0 | bar |   52 | hello52 | world | drop this |    4
    1 |   1 | hello1 | bar |   52 | hello52 | world | drop this |    4
    0 |   0 | hello0 | bar |    5 | hello5  | world | drop this |    5
    1 |   1 | hello1 | bar |    5 | hello5  | world | drop this |    5
    0 |   0 | hello0 | bar |   11 | hello11 | world | drop this |    5
    1 |   1 | hello1 | bar |   11 | hello11 | world | drop this |    5
    0 |   0 | hello0 | bar |   17 | hello17 | world | drop this |    5
    1 |   1 | hello1 | bar |   17 | hello17 | world | drop this |    5
    0 |   0 | hello0 | bar |   23 | hello23 | world | drop this |    5
    1 |   1 | hello1 | bar |   23 | hello23 | world | drop this |    5
    0 |   0 | hello0 | bar |   29 | hello29 | world | drop this |    5
    1 |   1 | hello1 | bar |   29 | hello29 | world | drop this |    5
    0 |   0 | hello0 | bar |   35 | hello35 | world | drop this |    5
    1 |   1 | hello1 | bar |   35 | hello35 | world | drop this |    5
    0 |   0 | hello0 | bar |   41 | hello41 | world | drop this |    5
    1 |   1 | hello1 | bar |   41 | hello41 | world | drop this |    5
    0 |   0 | hello0 | bar |   47 | hello47 | world | drop this |    5
    1 |   1 | hello1 | bar |   47 | hello47 | world | drop this |    5
    0 |   0 | hello0 | bar |   53 | hello53 | world | drop this |    5
    1 |   1 | hello1 | bar |   53 | hello53 | world | drop this |    5
(81 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid > t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid > t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid > t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid > t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid > t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid > t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=81 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Nested Loop (actual rows=81 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Join Filter: true
         ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
         ->  Append (actual rows=27 loops=3)
               ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (never executed)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                     Index Cond: (pt_p1.ptid > t.tid)
               ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                     Index Cond: (pt_p2.ptid > t.tid)
               ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (actual rows=6 loops=3)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                     Index Cond: (pt_p3.ptid > t.tid)
               ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (actual rows=6 loops=3)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                     Index Cond: (pt_p4.ptid > t.tid)
               ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (actual rows=6 loops=3)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                     Index Cond: (pt_p5.ptid > t.tid)
               ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (actual rows=6 loops=3)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                     Index Cond: (pt_junk_data.ptid > t.tid)
 Optimizer: PolarDB PX Optimizer
(27 rows)

reset polar_px_optimizer_enable_indexscan;
reset polar_px_optimizer_enable_seqscan;
reset polar_px_optimizer_enable_hashjoin;
reset polar_px_optimizer_enable_nestloopjoin;
--
-- multiple joins
--
-- one of the joined tables can be used for partition elimination, the other can not
explain (costs off, timing off, summary off) select * from t, t1, pt where t1.t2 = t.t2 and t1.tid = ptid;
                QUERY PLAN                 
-------------------------------------------
 Hash Join
   Hash Cond: (pt_p1.ptid = t1.tid)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
         ->  Seq Scan on pt_junk_data
   ->  Hash
         ->  Nested Loop
               Join Filter: (t.t2 = t1.t2)
               ->  Seq Scan on t
               ->  Materialize
                     ->  Seq Scan on t1
(15 rows)

select * from t, t1, pt where t1.t2 = t.t2 and t1.tid = ptid;
 dist | tid |   t1   | t2  | dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+-----+--------+-----+------+---------+-------+-----------+------
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
    0 |   0 | hello0 | bar |    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |    2 | hello2  | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |    2 | hello2  | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |    8 | hello8  | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |    8 | hello8  | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   14 | hello14 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   14 | hello14 | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   20 | hello20 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   20 | hello20 | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   26 | hello26 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   26 | hello26 | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   32 | hello32 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   32 | hello32 | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   38 | hello38 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   38 | hello38 | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   44 | hello44 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   44 | hello44 | world | drop this |    2
    1 |   1 | hello1 | bar |    2 |   2 | hello2 | bar |   50 | hello50 | world | drop this |    2
    0 |   0 | hello0 | bar |    2 |   2 | hello2 | bar |   50 | hello50 | world | drop this |    2
(36 rows)

                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: t.dist, t.tid, t.t1, t.t2, t1.dist, t1.tid, t1.t1, t1.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Hash Join
         Output: t.dist, t.tid, t.t1, t.t2, t1.dist, t1.tid, t1.t1, t1.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Hash Cond: (t1.t2 = t.t2)
         ->  Nested Loop
               Output: t1.dist, t1.tid, t1.t1, t1.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               Join Filter: true
               ->  Full Seq Scan on dpe_single.t1
                     Output: t1.dist, t1.tid, t1.t1, t1.t2
               ->  Append
                     ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1
                           Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                           Index Cond: (pt_p1.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2
                           Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                           Index Cond: (pt_p2.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3
                           Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                           Index Cond: (pt_p3.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4
                           Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                           Index Cond: (pt_p4.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5
                           Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                           Index Cond: (pt_p5.ptid = t1.tid)
                     ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data
                           Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                           Index Cond: (pt_junk_data.ptid = t1.tid)
         ->  Hash
               Output: t.dist, t.tid, t.t1, t.t2
               ->  Full Seq Scan on dpe_single.t
                     Output: t.dist, t.tid, t.t1, t.t2
 Optimizer: PolarDB PX Optimizer
(34 rows)

                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=36 loops=1)
   Output: t.dist, t.tid, t.t1, t.t2, t1.dist, t1.tid, t1.t1, t1.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
   ->  Hash Join (actual rows=36 loops=1)
         Output: t.dist, t.tid, t.t1, t.t2, t1.dist, t1.tid, t1.t1, t1.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
         Hash Cond: (t1.t2 = t.t2)
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  Nested Loop (actual rows=18 loops=1)
               Output: t1.dist, t1.tid, t1.t1, t1.t2, pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
               Join Filter: true
               ->  Full Seq Scan on dpe_single.t1 (actual rows=2 loops=1)
                     Output: t1.dist, t1.tid, t1.t1, t1.t2
               ->  Append (actual rows=6 loops=3)
                     ->  Partial Index Scan using pt_p1_ptid_idx on dpe_single.pt_p1 (never executed)
                           Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                           Index Cond: (pt_p1.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p2_ptid_idx on dpe_single.pt_p2 (actual rows=3 loops=3)
                           Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                           Index Cond: (pt_p2.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p3_ptid_idx on dpe_single.pt_p3 (actual rows=3 loops=3)
                           Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                           Index Cond: (pt_p3.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p4_ptid_idx on dpe_single.pt_p4 (never executed)
                           Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                           Index Cond: (pt_p4.ptid = t1.tid)
                     ->  Partial Index Scan using pt_p5_ptid_idx on dpe_single.pt_p5 (never executed)
                           Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                           Index Cond: (pt_p5.ptid = t1.tid)
                     ->  Partial Index Scan using pt_junk_data_ptid_idx on dpe_single.pt_junk_data (never executed)
                           Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                           Index Cond: (pt_junk_data.ptid = t1.tid)
         ->  Hash (actual rows=2 loops=1)
               Output: t.dist, t.tid, t.t1, t.t2
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Full Seq Scan on dpe_single.t (actual rows=2 loops=1)
                     Output: t.dist, t.tid, t.t1, t.t2
 Optimizer: PolarDB PX Optimizer
(36 rows)

-- Both joined tables can be used for partition elimination. Only partitions
-- that contain matching rows for both joins need to be scanned.
-- have to do some tricks to coerce the planner to choose the plan we want.
begin;
insert into t select i, -100, 'dummy' from generate_series(1,10) i;
insert into t1 select i, -100, 'dummy' from generate_series(1,10) i;
analyze t;
analyze t1;
explain (costs off, timing off, summary off) select * from t, t1, pt where t1.tid = ptid and t.tid = ptid;
                       QUERY PLAN                       
--------------------------------------------------------
 Hash Join
   Hash Cond: (t1.tid = pt_p1.ptid)
   ->  Seq Scan on t1
   ->  Hash
         ->  Hash Join
               Hash Cond: (t.tid = pt_p1.ptid)
               ->  Seq Scan on t
               ->  Hash
                     ->  Append
                           ->  Seq Scan on pt_p1
                           ->  Seq Scan on pt_p2
                           ->  Seq Scan on pt_p3
                           ->  Seq Scan on pt_p4
                           ->  Seq Scan on pt_p5
                           ->  Seq Scan on pt_junk_data
(15 rows)

select * from t, t1, pt where t1.tid = ptid and t.tid = ptid;
 dist | tid |   t1   | t2  | dist | tid |   t1   | t2  | dist |   pt1   |  pt2  |    pt3    | ptid 
------+-----+--------+-----+------+-----+--------+-----+------+---------+-------+-----------+------
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |    1 | hello1  | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |    7 | hello7  | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   13 | hello13 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   19 | hello19 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   25 | hello25 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   31 | hello31 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   37 | hello37 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   43 | hello43 | world | drop this |    1
    1 |   1 | hello1 | bar |    1 |   1 | hello1 | bar |   49 | hello49 | world | drop this |    1
(9 rows)

rollback;
-- One non-joined table contributing to partition elimination in two different
-- partitioned tables
begin;
-- have to force the planner for it to consider the kind of plan we want
-- to test
set local from_collapse_limit = 1;
set local join_collapse_limit = 1;
explain (costs off, timing off, summary off) select * from t1 inner join (select pt1.*, pt2.ptid as ptid2 from pt as pt1, pt as pt2 WHERE pt1.ptid <= pt2.ptid and pt1.dist = pt2.dist ) as ptx ON t1.dist = ptx.dist and t1.tid = ptx.ptid and t1.tid = ptx.ptid2;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Hash Join
   Hash Cond: ((pt1.dist = t1.dist) AND (pt1.ptid = t1.tid))
   ->  Hash Join
         Hash Cond: ((pt1.dist = pt2.dist) AND (pt1.ptid = pt2.ptid))
         Join Filter: (pt1.ptid <= pt2.ptid)
         ->  Append
               ->  Seq Scan on pt_p1 pt1
               ->  Seq Scan on pt_p2 pt1_1
               ->  Seq Scan on pt_p3 pt1_2
               ->  Seq Scan on pt_p4 pt1_3
               ->  Seq Scan on pt_p5 pt1_4
               ->  Seq Scan on pt_junk_data pt1_5
         ->  Hash
               ->  Append
                     ->  Seq Scan on pt_p1 pt2
                     ->  Seq Scan on pt_p2 pt2_1
                     ->  Seq Scan on pt_p3 pt2_2
                     ->  Seq Scan on pt_p4 pt2_3
                     ->  Seq Scan on pt_p5 pt2_4
                     ->  Seq Scan on pt_junk_data pt2_5
   ->  Hash
         ->  Seq Scan on t1
(22 rows)

rollback;
--
-- Partitioned table on both sides of the join. This will create a result node as Append node is
-- not projection capable.
--
explain (costs off, timing off, summary off) select * from pt, pt1 where pt.ptid = pt1.ptid and pt.pt1 = 'hello0' order by pt1.dist;
                        QUERY PLAN                        
----------------------------------------------------------
 Sort
   Sort Key: pt1_p1.dist
   ->  Hash Join
         Hash Cond: (pt1_p1.ptid = pt_p1.ptid)
         ->  Append
               ->  Seq Scan on pt1_p1
               ->  Seq Scan on pt1_p2
               ->  Seq Scan on pt1_p3
               ->  Seq Scan on pt1_p4
               ->  Seq Scan on pt1_p5
               ->  Seq Scan on pt1_junk_data
         ->  Hash
               ->  Append
                     ->  Seq Scan on pt_p1
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p2
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p3
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p4
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p5
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_junk_data
                           Filter: (pt1 = 'hello0'::text)
(25 rows)

select * from pt, pt1 where pt.ptid = pt1.ptid and pt.pt1 = 'hello0' order by pt1.dist;
 dist |  pt1   |  pt2  |    pt3    | ptid | dist |   pt1   |  pt2  |    pt3    | ptid 
------+--------+-------+-----------+------+------+---------+-------+-----------+------
    0 | hello0 | world | drop this |    0 |    0 | hello0  | world | drop this |    0
    0 | hello0 | world | drop this |    0 |    6 | hello6  | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   12 | hello12 | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   18 | hello18 | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   24 | hello24 | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   30 | hello30 | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   36 | hello36 | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   42 | hello42 | world | drop this |    0
    0 | hello0 | world | drop this |    0 |   48 | hello48 | world | drop this |    0
(9 rows)

                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
   Merge Key: pt1_p1.dist
   ->  Sort
         Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
         Sort Key: pt1_p1.dist
         ->  Append
               ->  Hash Join
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
                     Hash Cond: (pt1_p1.ptid = pt_p1.ptid)
                     ->  Partial Seq Scan on dpe_single.pt1_p1
                           Output: pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
                     ->  Hash
                           Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                           ->  PX Broadcast 6:6  (slice2; segments: 6)
                                 Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                                 ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1
                                       Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                                       Index Cond: (pt_p1.pt1 = 'hello0'::text)
               ->  Hash Join
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid, pt1_p2.dist, pt1_p2.pt1, pt1_p2.pt2, pt1_p2.pt3, pt1_p2.ptid
                     Hash Cond: (pt1_p2.ptid = pt_p2.ptid)
                     ->  Partial Seq Scan on dpe_single.pt1_p2
                           Output: pt1_p2.dist, pt1_p2.pt1, pt1_p2.pt2, pt1_p2.pt3, pt1_p2.ptid
                     ->  Hash
                           Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                           ->  PX Broadcast 6:6  (slice3; segments: 6)
                                 Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                                 ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2
                                       Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                                       Index Cond: (pt_p2.pt1 = 'hello0'::text)
               ->  Hash Join
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid, pt1_p3.dist, pt1_p3.pt1, pt1_p3.pt2, pt1_p3.pt3, pt1_p3.ptid
                     Hash Cond: (pt1_p3.ptid = pt_p3.ptid)
                     ->  Partial Seq Scan on dpe_single.pt1_p3
                           Output: pt1_p3.dist, pt1_p3.pt1, pt1_p3.pt2, pt1_p3.pt3, pt1_p3.ptid
                     ->  Hash
                           Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                           ->  PX Broadcast 6:6  (slice4; segments: 6)
                                 Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                                 ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3
                                       Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                                       Index Cond: (pt_p3.pt1 = 'hello0'::text)
               ->  Hash Join
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid, pt1_p4.dist, pt1_p4.pt1, pt1_p4.pt2, pt1_p4.pt3, pt1_p4.ptid
                     Hash Cond: (pt1_p4.ptid = pt_p4.ptid)
                     ->  Partial Seq Scan on dpe_single.pt1_p4
                           Output: pt1_p4.dist, pt1_p4.pt1, pt1_p4.pt2, pt1_p4.pt3, pt1_p4.ptid
                     ->  Hash
                           Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                           ->  PX Broadcast 6:6  (slice5; segments: 6)
                                 Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                                 ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4
                                       Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                                       Index Cond: (pt_p4.pt1 = 'hello0'::text)
               ->  Hash Join
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid, pt1_p5.dist, pt1_p5.pt1, pt1_p5.pt2, pt1_p5.pt3, pt1_p5.ptid
                     Hash Cond: (pt1_p5.ptid = pt_p5.ptid)
                     ->  Partial Seq Scan on dpe_single.pt1_p5
                           Output: pt1_p5.dist, pt1_p5.pt1, pt1_p5.pt2, pt1_p5.pt3, pt1_p5.ptid
                     ->  Hash
                           Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                           ->  PX Broadcast 6:6  (slice6; segments: 6)
                                 Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                                 ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5
                                       Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                                       Index Cond: (pt_p5.pt1 = 'hello0'::text)
               ->  Hash Join
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid, pt1_junk_data.dist, pt1_junk_data.pt1, pt1_junk_data.pt2, pt1_junk_data.pt3, pt1_junk_data.ptid
                     Hash Cond: (pt1_junk_data.ptid = pt_junk_data.ptid)
                     ->  Partial Seq Scan on dpe_single.pt1_junk_data
                           Output: pt1_junk_data.dist, pt1_junk_data.pt1, pt1_junk_data.pt2, pt1_junk_data.pt3, pt1_junk_data.ptid
                     ->  Hash
                           Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                           ->  PX Broadcast 6:6  (slice7; segments: 6)
                                 Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                                 ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data
                                       Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                                       Index Cond: (pt_junk_data.pt1 = 'hello0'::text)
 Optimizer: PolarDB PX Optimizer
(80 rows)

                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=9 loops=1)
   Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
   Merge Key: pt1_p1.dist
   ->  Sort (actual rows=9 loops=1)
         Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
         Sort Key: pt1_p1.dist
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Append (actual rows=9 loops=1)
               ->  Hash Join (actual rows=9 loops=1)
                     Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid, pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
                     Hash Cond: (pt1_p1.ptid = pt_p1.ptid)
                     work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
                     ->  Partial Seq Scan on dpe_single.pt1_p1 (actual rows=9 loops=1)
                           Output: pt1_p1.dist, pt1_p1.pt1, pt1_p1.pt2, pt1_p1.pt3, pt1_p1.ptid
                     ->  Hash (actual rows=1 loops=1)
                           Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=1 loops=1)
                                 Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                                 ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1 (actual rows=1 loops=1)
                                       Output: pt_p1.dist, pt_p1.pt1, pt_p1.pt2, pt_p1.pt3, pt_p1.ptid
                                       Index Cond: (pt_p1.pt1 = 'hello0'::text)
               ->  Hash Join (never executed)
                     Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid, pt1_p2.dist, pt1_p2.pt1, pt1_p2.pt2, pt1_p2.pt3, pt1_p2.ptid
                     Hash Cond: (pt1_p2.ptid = pt_p2.ptid)
                     work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                     ->  Partial Seq Scan on dpe_single.pt1_p2 (never executed)
                           Output: pt1_p2.dist, pt1_p2.pt1, pt1_p2.pt2, pt1_p2.pt3, pt1_p2.ptid
                     ->  Hash (never executed)
                           Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                           Buckets: 1024  Batches: 1  Memory Usage: 8kB
                           ->  PX Broadcast 6:6  (slice3; segments: 6) (never executed)
                                 Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                                 ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2 (never executed)
                                       Output: pt_p2.dist, pt_p2.pt1, pt_p2.pt2, pt_p2.pt3, pt_p2.ptid
                                       Index Cond: (pt_p2.pt1 = 'hello0'::text)
               ->  Hash Join (never executed)
                     Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid, pt1_p3.dist, pt1_p3.pt1, pt1_p3.pt2, pt1_p3.pt3, pt1_p3.ptid
                     Hash Cond: (pt1_p3.ptid = pt_p3.ptid)
                     work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                     ->  Partial Seq Scan on dpe_single.pt1_p3 (never executed)
                           Output: pt1_p3.dist, pt1_p3.pt1, pt1_p3.pt2, pt1_p3.pt3, pt1_p3.ptid
                     ->  Hash (never executed)
                           Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                           Buckets: 1024  Batches: 1  Memory Usage: 8kB
                           ->  PX Broadcast 6:6  (slice4; segments: 6) (never executed)
                                 Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                                 ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3 (never executed)
                                       Output: pt_p3.dist, pt_p3.pt1, pt_p3.pt2, pt_p3.pt3, pt_p3.ptid
                                       Index Cond: (pt_p3.pt1 = 'hello0'::text)
               ->  Hash Join (never executed)
                     Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid, pt1_p4.dist, pt1_p4.pt1, pt1_p4.pt2, pt1_p4.pt3, pt1_p4.ptid
                     Hash Cond: (pt1_p4.ptid = pt_p4.ptid)
                     work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                     ->  Partial Seq Scan on dpe_single.pt1_p4 (never executed)
                           Output: pt1_p4.dist, pt1_p4.pt1, pt1_p4.pt2, pt1_p4.pt3, pt1_p4.ptid
                     ->  Hash (never executed)
                           Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                           Buckets: 1024  Batches: 1  Memory Usage: 8kB
                           ->  PX Broadcast 6:6  (slice5; segments: 6) (never executed)
                                 Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                                 ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4 (never executed)
                                       Output: pt_p4.dist, pt_p4.pt1, pt_p4.pt2, pt_p4.pt3, pt_p4.ptid
                                       Index Cond: (pt_p4.pt1 = 'hello0'::text)
               ->  Hash Join (never executed)
                     Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid, pt1_p5.dist, pt1_p5.pt1, pt1_p5.pt2, pt1_p5.pt3, pt1_p5.ptid
                     Hash Cond: (pt1_p5.ptid = pt_p5.ptid)
                     work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                     ->  Partial Seq Scan on dpe_single.pt1_p5 (never executed)
                           Output: pt1_p5.dist, pt1_p5.pt1, pt1_p5.pt2, pt1_p5.pt3, pt1_p5.ptid
                     ->  Hash (never executed)
                           Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                           Buckets: 1024  Batches: 1  Memory Usage: 8kB
                           ->  PX Broadcast 6:6  (slice6; segments: 6) (never executed)
                                 Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                                 ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5 (never executed)
                                       Output: pt_p5.dist, pt_p5.pt1, pt_p5.pt2, pt_p5.pt3, pt_p5.ptid
                                       Index Cond: (pt_p5.pt1 = 'hello0'::text)
               ->  Hash Join (never executed)
                     Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid, pt1_junk_data.dist, pt1_junk_data.pt1, pt1_junk_data.pt2, pt1_junk_data.pt3, pt1_junk_data.ptid
                     Hash Cond: (pt1_junk_data.ptid = pt_junk_data.ptid)
                     work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                     ->  Partial Seq Scan on dpe_single.pt1_junk_data (never executed)
                           Output: pt1_junk_data.dist, pt1_junk_data.pt1, pt1_junk_data.pt2, pt1_junk_data.pt3, pt1_junk_data.ptid
                     ->  Hash (never executed)
                           Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                           Buckets: 1024  Batches: 1  Memory Usage: 8kB
                           ->  PX Broadcast 6:6  (slice7; segments: 6) (never executed)
                                 Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                                 ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data (never executed)
                                       Output: pt_junk_data.dist, pt_junk_data.pt1, pt_junk_data.pt2, pt_junk_data.pt3, pt_junk_data.ptid
                                       Index Cond: (pt_junk_data.pt1 = 'hello0'::text)
 Optimizer: PolarDB PX Optimizer
(93 rows)

explain (costs off, timing off, summary off) select count(*) from pt, pt1 where pt.ptid = pt1.ptid and pt.pt1 = 'hello0';
                        QUERY PLAN                        
----------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (pt1_p1.ptid = pt_p1.ptid)
         ->  Append
               ->  Seq Scan on pt1_p1
               ->  Seq Scan on pt1_p2
               ->  Seq Scan on pt1_p3
               ->  Seq Scan on pt1_p4
               ->  Seq Scan on pt1_p5
               ->  Seq Scan on pt1_junk_data
         ->  Hash
               ->  Append
                     ->  Seq Scan on pt_p1
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p2
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p3
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p4
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_p5
                           Filter: (pt1 = 'hello0'::text)
                     ->  Seq Scan on pt_junk_data
                           Filter: (pt1 = 'hello0'::text)
(24 rows)

select count(*) from pt, pt1 where pt.ptid = pt1.ptid and pt.pt1 = 'hello0';
 count 
-------
     9
(1 row)

                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6)
         Output: (PARTIAL count())
         ->  Partial Aggregate
               Output: PARTIAL count()
               ->  Append
                     ->  Hash Join
                           Hash Cond: (pt1_p1.ptid = pt_p1.ptid)
                           ->  Partial Seq Scan on dpe_single.pt1_p1
                                 Output: pt1_p1.ptid
                           ->  Hash
                                 Output: pt_p1.ptid
                                 ->  PX Broadcast 6:6  (slice2; segments: 6)
                                       Output: pt_p1.ptid
                                       ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1
                                             Output: pt_p1.ptid
                                             Index Cond: (pt_p1.pt1 = 'hello0'::text)
                     ->  Hash Join
                           Hash Cond: (pt1_p2.ptid = pt_p2.ptid)
                           ->  Partial Seq Scan on dpe_single.pt1_p2
                                 Output: pt1_p2.ptid
                           ->  Hash
                                 Output: pt_p2.ptid
                                 ->  PX Broadcast 6:6  (slice3; segments: 6)
                                       Output: pt_p2.ptid
                                       ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2
                                             Output: pt_p2.ptid
                                             Index Cond: (pt_p2.pt1 = 'hello0'::text)
                     ->  Hash Join
                           Hash Cond: (pt1_p3.ptid = pt_p3.ptid)
                           ->  Partial Seq Scan on dpe_single.pt1_p3
                                 Output: pt1_p3.ptid
                           ->  Hash
                                 Output: pt_p3.ptid
                                 ->  PX Broadcast 6:6  (slice4; segments: 6)
                                       Output: pt_p3.ptid
                                       ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3
                                             Output: pt_p3.ptid
                                             Index Cond: (pt_p3.pt1 = 'hello0'::text)
                     ->  Hash Join
                           Hash Cond: (pt1_p4.ptid = pt_p4.ptid)
                           ->  Partial Seq Scan on dpe_single.pt1_p4
                                 Output: pt1_p4.ptid
                           ->  Hash
                                 Output: pt_p4.ptid
                                 ->  PX Broadcast 6:6  (slice5; segments: 6)
                                       Output: pt_p4.ptid
                                       ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4
                                             Output: pt_p4.ptid
                                             Index Cond: (pt_p4.pt1 = 'hello0'::text)
                     ->  Hash Join
                           Hash Cond: (pt1_p5.ptid = pt_p5.ptid)
                           ->  Partial Seq Scan on dpe_single.pt1_p5
                                 Output: pt1_p5.ptid
                           ->  Hash
                                 Output: pt_p5.ptid
                                 ->  PX Broadcast 6:6  (slice6; segments: 6)
                                       Output: pt_p5.ptid
                                       ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5
                                             Output: pt_p5.ptid
                                             Index Cond: (pt_p5.pt1 = 'hello0'::text)
                     ->  Hash Join
                           Hash Cond: (pt1_junk_data.ptid = pt_junk_data.ptid)
                           ->  Partial Seq Scan on dpe_single.pt1_junk_data
                                 Output: pt1_junk_data.ptid
                           ->  Hash
                                 Output: pt_junk_data.ptid
                                 ->  PX Broadcast 6:6  (slice7; segments: 6)
                                       Output: pt_junk_data.ptid
                                       ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data
                                             Output: pt_junk_data.ptid
                                             Index Cond: (pt_junk_data.pt1 = 'hello0'::text)
 Optimizer: PolarDB PX Optimizer
(74 rows)

                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   Output: count()
   ->  PX Coordinator 6:1  (slice1; segments: 6) (actual rows=6 loops=1)
         Output: (PARTIAL count())
         ->  Partial Aggregate (actual rows=1 loops=1)
               Output: PARTIAL count()
               ->  Append (actual rows=9 loops=1)
                     ->  Hash Join (actual rows=9 loops=1)
                           Hash Cond: (pt1_p1.ptid = pt_p1.ptid)
                           work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
                           ->  Partial Seq Scan on dpe_single.pt1_p1 (actual rows=9 loops=1)
                                 Output: pt1_p1.ptid
                           ->  Hash (actual rows=1 loops=1)
                                 Output: pt_p1.ptid
                                 Buckets: 1024  Batches: 1  Memory Usage: 9kB
                                 ->  PX Broadcast 6:6  (slice2; segments: 6) (actual rows=1 loops=1)
                                       Output: pt_p1.ptid
                                       ->  Partial Index Scan using pt_p1_pt1_idx on dpe_single.pt_p1 (actual rows=1 loops=1)
                                             Output: pt_p1.ptid
                                             Index Cond: (pt_p1.pt1 = 'hello0'::text)
                     ->  Hash Join (never executed)
                           Hash Cond: (pt1_p2.ptid = pt_p2.ptid)
                           work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                           ->  Partial Seq Scan on dpe_single.pt1_p2 (never executed)
                                 Output: pt1_p2.ptid
                           ->  Hash (never executed)
                                 Output: pt_p2.ptid
                                 Buckets: 1024  Batches: 1  Memory Usage: 8kB
                                 ->  PX Broadcast 6:6  (slice3; segments: 6) (never executed)
                                       Output: pt_p2.ptid
                                       ->  Partial Index Scan using pt_p2_pt1_idx on dpe_single.pt_p2 (never executed)
                                             Output: pt_p2.ptid
                                             Index Cond: (pt_p2.pt1 = 'hello0'::text)
                     ->  Hash Join (never executed)
                           Hash Cond: (pt1_p3.ptid = pt_p3.ptid)
                           work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                           ->  Partial Seq Scan on dpe_single.pt1_p3 (never executed)
                                 Output: pt1_p3.ptid
                           ->  Hash (never executed)
                                 Output: pt_p3.ptid
                                 Buckets: 1024  Batches: 1  Memory Usage: 8kB
                                 ->  PX Broadcast 6:6  (slice4; segments: 6) (never executed)
                                       Output: pt_p3.ptid
                                       ->  Partial Index Scan using pt_p3_pt1_idx on dpe_single.pt_p3 (never executed)
                                             Output: pt_p3.ptid
                                             Index Cond: (pt_p3.pt1 = 'hello0'::text)
                     ->  Hash Join (never executed)
                           Hash Cond: (pt1_p4.ptid = pt_p4.ptid)
                           work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                           ->  Partial Seq Scan on dpe_single.pt1_p4 (never executed)
                                 Output: pt1_p4.ptid
                           ->  Hash (never executed)
                                 Output: pt_p4.ptid
                                 Buckets: 1024  Batches: 1  Memory Usage: 8kB
                                 ->  PX Broadcast 6:6  (slice5; segments: 6) (never executed)
                                       Output: pt_p4.ptid
                                       ->  Partial Index Scan using pt_p4_pt1_idx on dpe_single.pt_p4 (never executed)
                                             Output: pt_p4.ptid
                                             Index Cond: (pt_p4.pt1 = 'hello0'::text)
                     ->  Hash Join (never executed)
                           Hash Cond: (pt1_p5.ptid = pt_p5.ptid)
                           work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                           ->  Partial Seq Scan on dpe_single.pt1_p5 (never executed)
                                 Output: pt1_p5.ptid
                           ->  Hash (never executed)
                                 Output: pt_p5.ptid
                                 Buckets: 1024  Batches: 1  Memory Usage: 8kB
                                 ->  PX Broadcast 6:6  (slice6; segments: 6) (never executed)
                                       Output: pt_p5.ptid
                                       ->  Partial Index Scan using pt_p5_pt1_idx on dpe_single.pt_p5 (never executed)
                                             Output: pt_p5.ptid
                                             Index Cond: (pt_p5.pt1 = 'hello0'::text)
                     ->  Hash Join (never executed)
                           Hash Cond: (pt1_junk_data.ptid = pt_junk_data.ptid)
                           work_mem: 48kB  Workers: 6  Max: 8kB (worker 0)  Workfile: (0 spilling)
                           ->  Partial Seq Scan on dpe_single.pt1_junk_data (never executed)
                                 Output: pt1_junk_data.ptid
                           ->  Hash (never executed)
                                 Output: pt_junk_data.ptid
                                 Buckets: 1024  Batches: 1  Memory Usage: 8kB
                                 ->  PX Broadcast 6:6  (slice7; segments: 6) (never executed)
                                       Output: pt_junk_data.ptid
                                       ->  Partial Index Scan using pt_junk_data_pt1_idx on dpe_single.pt_junk_data (never executed)
                                             Output: pt_junk_data.ptid
                                             Index Cond: (pt_junk_data.pt1 = 'hello0'::text)
 Optimizer: PolarDB PX Optimizer
(86 rows)

--
-- Partition Selector under Material in NestLoopJoin inner side
--
drop table if exists pt;
drop table if exists t;
create table t(id int, a int);
create table pt(id int, b int) PARTITION BY RANGE(b);
CREATE TABLE pt_p1 PARTITION of pt for values from (0) to (1);
CREATE TABLE pt_p2 PARTITION of pt for values from (1) to (2);
CREATE TABLE pt_p3 PARTITION of pt for values from (2) to (3);
CREATE TABLE pt_p4 PARTITION of pt for values from (3) to (4);
CREATE TABLE pt_p5 PARTITION of pt for values from (4) to (5);
insert into t select i, i from generate_series(0,4) i;
insert into pt select i, i from generate_series(0,4) i;
analyze t;
analyze pt;
begin;
set polar_px_optimizer_enable_hashjoin=off;
set polar_px_optimizer_enable_seqscan=on;
set polar_px_optimizer_enable_nestloopjoin=on;
explain (costs off, timing off, summary off) select * from t, pt where a = b;
          QUERY PLAN           
-------------------------------
 Hash Join
   Hash Cond: (pt_p1.b = t.a)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
   ->  Hash
         ->  Seq Scan on t
(10 rows)

select * from t, pt where a = b;
 id | a | id | b 
----+---+----+---
  0 | 0 |  0 | 0
  1 | 1 |  1 | 1
  2 | 2 |  2 | 2
  3 | 3 |  3 | 3
  4 | 4 |  4 | 4
(5 rows)

rollback;
--
-- partition selector with 0 tuples and 0 matched partitions
--
drop table if exists t;
drop table if exists pt;
create table t(a int);
create table pt(b int)  PARTITION BY RANGE(b);
CREATE TABLE pt_p1 PARTITION of pt for values from (0) to (1);
CREATE TABLE pt_p2 PARTITION of pt for values from (1) to (2);
CREATE TABLE pt_p3 PARTITION of pt for values from (2) to (3);
CREATE TABLE pt_p4 PARTITION of pt for values from (3) to (4);
CREATE TABLE pt_p5 PARTITION of pt for values from (4) to (5);
begin;
set polar_px_optimizer_enable_hashjoin=off; -- foring nestloop join
set polar_px_optimizer_enable_nestloopjoin=on;
set polar_px_optimizer_enable_seqscan=on;
-- 7 in seg1, 8 in seg2, no data in seg0
insert into t select i from generate_series(7,8) i;
-- 0~2 in seg0, 3~4 in seg 1, no data in seg2
insert into pt select i from generate_series(0,4) i;
-- Insert some more rows to coerce the planner to put 'pt' on the outer
-- side of the join.
insert into t select i from generate_series(7,8) i;
insert into pt select 0 from generate_series(1,1000) g;
analyze t;
analyze pt;
explain (costs off, timing off, summary off) select * from t, pt where a = b;
          QUERY PLAN           
-------------------------------
 Hash Join
   Hash Cond: (pt_p1.b = t.a)
   ->  Append
         ->  Seq Scan on pt_p1
         ->  Seq Scan on pt_p2
         ->  Seq Scan on pt_p3
         ->  Seq Scan on pt_p4
         ->  Seq Scan on pt_p5
   ->  Hash
         ->  Seq Scan on t
(10 rows)

select * from t, pt where a = b;
 a | b 
---+---
(0 rows)

rollback;
--
-- Multi-level partitions
--
drop schema if exists dpe_multi cascade;
NOTICE:  schema "dpe_multi" does not exist, skipping
create schema dpe_multi;
set search_path='dpe_multi';
create table dim1(dist int, pid int, code text, t1 text);
insert into dim1 values (1, 0, 'OH', 'world1');
insert into dim1 values (1, 1, 'OH', 'world2');
insert into dim1 values (1, 100, 'GA', 'world2'); -- should not have a match at all
analyze dim1;
create table fact1(dist int, pid int, code text, u int)
partition by range(pid);
CREATE TABLE fact1_p1 PARTITION of fact1 for values from (0) to (1);
CREATE TABLE fact1_p2 PARTITION of fact1 for values from (1) to (2);
CREATE TABLE fact1_p3 PARTITION of fact1 for values from (2) to (3);
CREATE TABLE fact1_p4 PARTITION of fact1 for values from (3) to (4);
CREATE TABLE fact1_p5 PARTITION of fact1 for values from (4) to (5);
insert into fact1 select 1, i % 4 , 'OH', i from generate_series (1,100) i;
insert into fact1 select 1, i % 4 , 'CA', i + 10000 from generate_series (1,100) i;
--
-- Join on all partitioning columns
--
set polar_px_optimizer_enable_partition_selection=off;
explain (costs off, timing off, summary off) select * from dim1 inner join fact1 on (dim1.pid=fact1.pid and dim1.code=fact1.code) order by fact1.u;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Sort Key: fact1_p1.u
   ->  Hash Join
         Hash Cond: ((fact1_p1.pid = dim1.pid) AND (fact1_p1.code = dim1.code))
         ->  Append
               ->  Seq Scan on fact1_p1
               ->  Seq Scan on fact1_p2
               ->  Seq Scan on fact1_p3
               ->  Seq Scan on fact1_p4
               ->  Seq Scan on fact1_p5
         ->  Hash
               ->  Seq Scan on dim1
(12 rows)

select * from dim1 inner join fact1 on (dim1.pid=fact1.pid and dim1.code=fact1.code) order by fact1.u;
 dist | pid | code |   t1   | dist | pid | code |  u  
------+-----+------+--------+------+-----+------+-----
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   1
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   4
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   5
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   8
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   9
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  12
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  13
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  16
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  17
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  20
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  21
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  24
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  25
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  28
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  29
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  32
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  33
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  36
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  37
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  40
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  41
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  44
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  45
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  48
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  49
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  52
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  53
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  56
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  57
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  60
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  61
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  64
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  65
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  68
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  69
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  72
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  73
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  76
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  77
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  80
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  81
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  84
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  85
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  88
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  89
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  92
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  93
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  96
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  97
    1 |   0 | OH   | world1 |    1 |   0 | OH   | 100
(50 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         ->  Hash Join
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: ((fact1_p1.pid = dim1.pid) AND (fact1_p1.code = dim1.code))
               ->  Append
                     ->  Partial Seq Scan on dpe_multi.fact1_p1
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     ->  Full Seq Scan on dpe_multi.dim1
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(25 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=50 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort (actual rows=50 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Hash Join (actual rows=50 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: ((fact1_p1.pid = dim1.pid) AND (fact1_p1.code = dim1.code))
               work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
               ->  Append (actual rows=200 loops=1)
                     ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3 (actual rows=50 loops=1)
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4 (actual rows=50 loops=1)
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(28 rows)

set polar_px_optimizer_enable_partition_selection=on;
explain (costs off, timing off, summary off) select * from dim1 inner join fact1 on (dim1.pid=fact1.pid and dim1.code=fact1.code) order by fact1.u;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Sort Key: fact1_p1.u
   ->  Hash Join
         Hash Cond: ((fact1_p1.pid = dim1.pid) AND (fact1_p1.code = dim1.code))
         ->  Append
               ->  Seq Scan on fact1_p1
               ->  Seq Scan on fact1_p2
               ->  Seq Scan on fact1_p3
               ->  Seq Scan on fact1_p4
               ->  Seq Scan on fact1_p5
         ->  Hash
               ->  Seq Scan on dim1
(12 rows)

select * from dim1 inner join fact1 on (dim1.pid=fact1.pid and dim1.code=fact1.code) order by fact1.u;
 dist | pid | code |   t1   | dist | pid | code |  u  
------+-----+------+--------+------+-----+------+-----
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   1
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   4
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   5
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   8
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   9
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  12
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  13
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  16
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  17
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  20
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  21
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  24
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  25
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  28
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  29
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  32
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  33
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  36
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  37
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  40
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  41
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  44
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  45
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  48
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  49
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  52
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  53
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  56
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  57
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  60
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  61
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  64
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  65
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  68
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  69
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  72
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  73
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  76
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  77
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  80
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  81
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  84
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  85
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  88
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  89
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  92
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  93
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  96
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  97
    1 |   0 | OH   | world1 |    1 |   0 | OH   | 100
(50 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         ->  Hash Join
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: ((fact1_p1.pid = dim1.pid) AND (fact1_p1.code = dim1.code))
               ->  Append
                     Partition Selectors: $0
                     ->  Partial Seq Scan on dpe_multi.fact1_p1
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     ->  Partition Selector (selector id: $0)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                           ->  Full Seq Scan on dpe_multi.dim1
                                 Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(28 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=50 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort (actual rows=50 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Hash Join (actual rows=50 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: ((fact1_p1.pid = dim1.pid) AND (fact1_p1.code = dim1.code))
               work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
               ->  Append (actual rows=100 loops=1)
                     Partition Selectors: $0
                     ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3 (never executed)
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4 (never executed)
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Partition Selector (selector id: $0) (actual rows=3 loops=1)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                           ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                                 Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(31 rows)

--
-- Join on one of the partitioning columns
--
set polar_px_optimizer_enable_partition_selection=off;
explain (costs off, timing off, summary off) select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) order by fact1.u;
                  QUERY PLAN                  
----------------------------------------------
 Sort
   Sort Key: fact1_p1.u
   ->  Hash Join
         Hash Cond: (fact1_p1.pid = dim1.pid)
         ->  Append
               ->  Seq Scan on fact1_p1
               ->  Seq Scan on fact1_p2
               ->  Seq Scan on fact1_p3
               ->  Seq Scan on fact1_p4
               ->  Seq Scan on fact1_p5
         ->  Hash
               ->  Seq Scan on dim1
(12 rows)

select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) order by fact1.u;
 dist | pid | code |   t1   | dist | pid | code |   u   
------+-----+------+--------+------+-----+------+-------
    1 |   1 | OH   | world2 |    1 |   1 | OH   |     1
    1 |   0 | OH   | world1 |    1 |   0 | OH   |     4
    1 |   1 | OH   | world2 |    1 |   1 | OH   |     5
    1 |   0 | OH   | world1 |    1 |   0 | OH   |     8
    1 |   1 | OH   | world2 |    1 |   1 | OH   |     9
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    12
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    13
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    16
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    17
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    20
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    21
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    24
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    25
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    28
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    29
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    32
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    33
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    36
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    37
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    40
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    41
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    44
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    45
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    48
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    49
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    52
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    53
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    56
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    57
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    60
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    61
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    64
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    65
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    68
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    69
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    72
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    73
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    76
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    77
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    80
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    81
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    84
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    85
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    88
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    89
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    92
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    93
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    96
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    97
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   100
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10001
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10004
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10005
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10008
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10009
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10012
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10013
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10016
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10017
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10020
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10021
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10024
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10025
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10028
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10029
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10032
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10033
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10036
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10037
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10040
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10041
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10044
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10045
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10048
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10049
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10052
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10053
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10056
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10057
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10060
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10061
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10064
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10065
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10068
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10069
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10072
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10073
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10076
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10077
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10080
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10081
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10084
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10085
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10088
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10089
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10092
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10093
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10096
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10097
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10100
(100 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         ->  Hash Join
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               ->  Append
                     ->  Partial Seq Scan on dpe_multi.fact1_p1
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     ->  Full Seq Scan on dpe_multi.dim1
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(25 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=100 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort (actual rows=100 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Hash Join (actual rows=100 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
               ->  Append (actual rows=200 loops=1)
                     ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3 (actual rows=50 loops=1)
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4 (actual rows=50 loops=1)
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(28 rows)

set polar_px_optimizer_enable_partition_selection=on;
explain (costs off, timing off, summary off) select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) order by fact1.u;
                  QUERY PLAN                  
----------------------------------------------
 Sort
   Sort Key: fact1_p1.u
   ->  Hash Join
         Hash Cond: (fact1_p1.pid = dim1.pid)
         ->  Append
               ->  Seq Scan on fact1_p1
               ->  Seq Scan on fact1_p2
               ->  Seq Scan on fact1_p3
               ->  Seq Scan on fact1_p4
               ->  Seq Scan on fact1_p5
         ->  Hash
               ->  Seq Scan on dim1
(12 rows)

select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) order by fact1.u;
 dist | pid | code |   t1   | dist | pid | code |   u   
------+-----+------+--------+------+-----+------+-------
    1 |   1 | OH   | world2 |    1 |   1 | OH   |     1
    1 |   0 | OH   | world1 |    1 |   0 | OH   |     4
    1 |   1 | OH   | world2 |    1 |   1 | OH   |     5
    1 |   0 | OH   | world1 |    1 |   0 | OH   |     8
    1 |   1 | OH   | world2 |    1 |   1 | OH   |     9
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    12
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    13
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    16
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    17
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    20
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    21
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    24
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    25
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    28
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    29
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    32
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    33
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    36
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    37
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    40
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    41
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    44
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    45
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    48
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    49
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    52
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    53
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    56
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    57
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    60
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    61
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    64
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    65
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    68
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    69
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    72
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    73
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    76
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    77
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    80
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    81
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    84
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    85
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    88
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    89
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    92
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    93
    1 |   0 | OH   | world1 |    1 |   0 | OH   |    96
    1 |   1 | OH   | world2 |    1 |   1 | OH   |    97
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   100
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10001
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10004
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10005
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10008
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10009
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10012
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10013
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10016
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10017
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10020
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10021
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10024
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10025
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10028
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10029
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10032
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10033
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10036
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10037
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10040
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10041
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10044
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10045
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10048
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10049
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10052
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10053
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10056
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10057
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10060
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10061
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10064
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10065
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10068
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10069
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10072
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10073
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10076
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10077
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10080
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10081
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10084
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10085
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10088
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10089
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10092
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10093
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10096
    1 |   1 | OH   | world2 |    1 |   1 | CA   | 10097
    1 |   0 | OH   | world1 |    1 |   0 | CA   | 10100
(100 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         ->  Hash Join
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               ->  Append
                     Partition Selectors: $0
                     ->  Partial Seq Scan on dpe_multi.fact1_p1
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     ->  Partition Selector (selector id: $0)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                           ->  Full Seq Scan on dpe_multi.dim1
                                 Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(28 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=100 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort (actual rows=100 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Hash Join (actual rows=100 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
               ->  Append (actual rows=100 loops=1)
                     Partition Selectors: $0
                     ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p3 (never executed)
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p4 (never executed)
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                     ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
               ->  Hash (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Partition Selector (selector id: $0) (actual rows=3 loops=1)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                           ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                                 Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(31 rows)

--
-- Join on the subpartitioning column only
--
set polar_px_optimizer_enable_partition_selection=off;
explain (costs off, timing off, summary off)
select * from dim1 inner join fact1 on (dim1.dist = fact1.dist and dim1.code=fact1.code);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((fact1_p1.dist = dim1.dist) AND (fact1_p1.code = dim1.code))
   ->  Append
         ->  Seq Scan on fact1_p1
         ->  Seq Scan on fact1_p2
         ->  Seq Scan on fact1_p3
         ->  Seq Scan on fact1_p4
         ->  Seq Scan on fact1_p5
   ->  Hash
         ->  Seq Scan on dim1
(10 rows)

select * from dim1 inner join fact1 on (dim1.dist = fact1.dist and dim1.code=fact1.code);
 dist | pid | code |   t1   | dist | pid | code |  u  
------+-----+------+--------+------+-----+------+-----
    1 |   1 | OH   | world2 |    1 |   0 | OH   |   4
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   4
    1 |   1 | OH   | world2 |    1 |   0 | OH   |   8
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   8
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  12
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  12
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  16
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  16
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  20
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  20
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  24
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  24
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  28
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  28
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  32
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  32
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  36
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  36
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  40
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  40
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  44
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  44
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  48
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  48
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  52
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  52
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  56
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  56
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  60
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  60
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  64
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  64
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  68
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  68
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  72
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  72
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  76
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  76
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  80
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  80
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  84
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  84
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  88
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  88
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  92
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  92
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  96
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  96
    1 |   1 | OH   | world2 |    1 |   0 | OH   | 100
    1 |   0 | OH   | world1 |    1 |   0 | OH   | 100
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   1
    1 |   0 | OH   | world1 |    1 |   1 | OH   |   1
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   5
    1 |   0 | OH   | world1 |    1 |   1 | OH   |   5
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   9
    1 |   0 | OH   | world1 |    1 |   1 | OH   |   9
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  13
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  13
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  17
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  17
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  21
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  21
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  25
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  25
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  29
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  29
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  33
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  33
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  37
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  37
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  41
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  41
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  45
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  45
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  49
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  49
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  53
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  53
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  57
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  57
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  61
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  61
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  65
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  65
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  69
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  69
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  73
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  73
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  77
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  77
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  81
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  81
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  85
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  85
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  89
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  89
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  93
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  93
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  97
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  97
    1 |   1 | OH   | world2 |    1 |   2 | OH   |   2
    1 |   0 | OH   | world1 |    1 |   2 | OH   |   2
    1 |   1 | OH   | world2 |    1 |   2 | OH   |   6
    1 |   0 | OH   | world1 |    1 |   2 | OH   |   6
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  10
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  10
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  14
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  14
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  18
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  18
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  22
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  22
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  26
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  26
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  30
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  30
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  34
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  34
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  38
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  38
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  42
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  42
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  46
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  46
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  50
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  50
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  54
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  54
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  58
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  58
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  62
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  62
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  66
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  66
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  70
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  70
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  74
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  74
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  78
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  78
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  82
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  82
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  86
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  86
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  90
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  90
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  94
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  94
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  98
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  98
    1 |   1 | OH   | world2 |    1 |   3 | OH   |   3
    1 |   0 | OH   | world1 |    1 |   3 | OH   |   3
    1 |   1 | OH   | world2 |    1 |   3 | OH   |   7
    1 |   0 | OH   | world1 |    1 |   3 | OH   |   7
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  11
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  11
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  15
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  15
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  19
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  19
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  23
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  23
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  27
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  27
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  31
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  31
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  35
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  35
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  39
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  39
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  43
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  43
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  47
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  47
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  51
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  51
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  55
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  55
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  59
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  59
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  63
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  63
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  67
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  67
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  71
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  71
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  75
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  75
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  79
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  79
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  83
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  83
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  87
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  87
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  91
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  91
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  95
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  95
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  99
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  99
(200 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   ->  Hash Join
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Hash Cond: ((fact1_p1.dist = dim1.dist) AND (fact1_p1.code = dim1.code))
         ->  Append
               ->  Partial Seq Scan on dpe_multi.fact1_p1
                     Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               ->  Partial Seq Scan on dpe_multi.fact1_p2
                     Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
               ->  Partial Seq Scan on dpe_multi.fact1_p3
                     Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
               ->  Partial Seq Scan on dpe_multi.fact1_p4
                     Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
               ->  Partial Seq Scan on dpe_multi.fact1_p5
                     Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
         ->  Hash
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
               ->  Full Seq Scan on dpe_multi.dim1
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(21 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=200 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   ->  Hash Join (actual rows=200 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Hash Cond: ((fact1_p1.dist = dim1.dist) AND (fact1_p1.code = dim1.code))
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  Append (actual rows=200 loops=1)
               ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                     Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                     Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
               ->  Partial Seq Scan on dpe_multi.fact1_p3 (actual rows=50 loops=1)
                     Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
               ->  Partial Seq Scan on dpe_multi.fact1_p4 (actual rows=50 loops=1)
                     Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
               ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                     Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
         ->  Hash (actual rows=3 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(23 rows)

set polar_px_optimizer_enable_partition_selection=on;
explain (costs off, timing off, summary off)
select * from dim1 inner join fact1 on (dim1.dist = fact1.dist and dim1.code=fact1.code);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((fact1_p1.dist = dim1.dist) AND (fact1_p1.code = dim1.code))
   ->  Append
         ->  Seq Scan on fact1_p1
         ->  Seq Scan on fact1_p2
         ->  Seq Scan on fact1_p3
         ->  Seq Scan on fact1_p4
         ->  Seq Scan on fact1_p5
   ->  Hash
         ->  Seq Scan on dim1
(10 rows)

select * from dim1 inner join fact1 on (dim1.dist = fact1.dist and dim1.code=fact1.code);
 dist | pid | code |   t1   | dist | pid | code |  u  
------+-----+------+--------+------+-----+------+-----
    1 |   1 | OH   | world2 |    1 |   0 | OH   |   4
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   4
    1 |   1 | OH   | world2 |    1 |   0 | OH   |   8
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   8
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  12
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  12
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  16
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  16
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  20
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  20
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  24
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  24
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  28
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  28
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  32
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  32
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  36
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  36
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  40
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  40
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  44
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  44
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  48
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  48
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  52
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  52
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  56
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  56
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  60
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  60
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  64
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  64
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  68
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  68
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  72
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  72
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  76
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  76
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  80
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  80
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  84
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  84
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  88
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  88
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  92
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  92
    1 |   1 | OH   | world2 |    1 |   0 | OH   |  96
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  96
    1 |   1 | OH   | world2 |    1 |   0 | OH   | 100
    1 |   0 | OH   | world1 |    1 |   0 | OH   | 100
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   1
    1 |   0 | OH   | world1 |    1 |   1 | OH   |   1
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   5
    1 |   0 | OH   | world1 |    1 |   1 | OH   |   5
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   9
    1 |   0 | OH   | world1 |    1 |   1 | OH   |   9
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  13
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  13
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  17
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  17
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  21
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  21
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  25
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  25
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  29
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  29
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  33
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  33
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  37
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  37
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  41
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  41
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  45
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  45
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  49
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  49
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  53
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  53
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  57
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  57
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  61
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  61
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  65
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  65
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  69
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  69
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  73
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  73
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  77
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  77
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  81
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  81
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  85
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  85
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  89
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  89
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  93
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  93
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  97
    1 |   0 | OH   | world1 |    1 |   1 | OH   |  97
    1 |   1 | OH   | world2 |    1 |   2 | OH   |   2
    1 |   0 | OH   | world1 |    1 |   2 | OH   |   2
    1 |   1 | OH   | world2 |    1 |   2 | OH   |   6
    1 |   0 | OH   | world1 |    1 |   2 | OH   |   6
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  10
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  10
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  14
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  14
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  18
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  18
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  22
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  22
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  26
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  26
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  30
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  30
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  34
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  34
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  38
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  38
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  42
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  42
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  46
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  46
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  50
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  50
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  54
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  54
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  58
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  58
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  62
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  62
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  66
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  66
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  70
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  70
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  74
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  74
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  78
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  78
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  82
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  82
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  86
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  86
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  90
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  90
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  94
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  94
    1 |   1 | OH   | world2 |    1 |   2 | OH   |  98
    1 |   0 | OH   | world1 |    1 |   2 | OH   |  98
    1 |   1 | OH   | world2 |    1 |   3 | OH   |   3
    1 |   0 | OH   | world1 |    1 |   3 | OH   |   3
    1 |   1 | OH   | world2 |    1 |   3 | OH   |   7
    1 |   0 | OH   | world1 |    1 |   3 | OH   |   7
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  11
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  11
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  15
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  15
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  19
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  19
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  23
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  23
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  27
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  27
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  31
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  31
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  35
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  35
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  39
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  39
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  43
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  43
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  47
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  47
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  51
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  51
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  55
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  55
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  59
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  59
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  63
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  63
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  67
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  67
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  71
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  71
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  75
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  75
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  79
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  79
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  83
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  83
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  87
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  87
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  91
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  91
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  95
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  95
    1 |   1 | OH   | world2 |    1 |   3 | OH   |  99
    1 |   0 | OH   | world1 |    1 |   3 | OH   |  99
(200 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   ->  Hash Join
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Hash Cond: ((fact1_p1.dist = dim1.dist) AND (fact1_p1.code = dim1.code))
         ->  Append
               ->  Partial Seq Scan on dpe_multi.fact1_p1
                     Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               ->  Partial Seq Scan on dpe_multi.fact1_p2
                     Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
               ->  Partial Seq Scan on dpe_multi.fact1_p3
                     Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
               ->  Partial Seq Scan on dpe_multi.fact1_p4
                     Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
               ->  Partial Seq Scan on dpe_multi.fact1_p5
                     Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
         ->  Hash
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
               ->  Full Seq Scan on dpe_multi.dim1
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(21 rows)

                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=200 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   ->  Hash Join (actual rows=200 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Hash Cond: ((fact1_p1.dist = dim1.dist) AND (fact1_p1.code = dim1.code))
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  Append (actual rows=200 loops=1)
               ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                     Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                     Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
               ->  Partial Seq Scan on dpe_multi.fact1_p3 (actual rows=50 loops=1)
                     Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
               ->  Partial Seq Scan on dpe_multi.fact1_p4 (actual rows=50 loops=1)
                     Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
               ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                     Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
         ->  Hash (actual rows=3 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(23 rows)

--
-- Join on one of the partitioning columns and static elimination on other
--
set polar_px_optimizer_enable_partition_selection=off;
explain (costs off, timing off, summary off) select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) and fact1.code = 'OH' order by fact1.u;
                   QUERY PLAN                    
-------------------------------------------------
 Sort
   Sort Key: fact1_p1.u
   ->  Hash Join
         Hash Cond: (fact1_p1.pid = dim1.pid)
         ->  Append
               ->  Seq Scan on fact1_p1
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p2
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p3
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p4
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p5
                     Filter: (code = 'OH'::text)
         ->  Hash
               ->  Seq Scan on dim1
(17 rows)

select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) and fact1.code = 'OH' order by fact1.u;
 dist | pid | code |   t1   | dist | pid | code |  u  
------+-----+------+--------+------+-----+------+-----
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   1
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   4
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   5
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   8
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   9
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  12
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  13
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  16
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  17
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  20
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  21
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  24
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  25
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  28
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  29
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  32
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  33
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  36
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  37
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  40
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  41
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  44
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  45
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  48
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  49
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  52
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  53
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  56
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  57
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  60
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  61
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  64
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  65
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  68
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  69
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  72
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  73
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  76
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  77
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  80
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  81
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  84
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  85
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  88
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  89
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  92
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  93
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  96
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  97
    1 |   0 | OH   | world1 |    1 |   0 | OH   | 100
(50 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         ->  Hash Join
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               ->  Append
                     ->  Partial Seq Scan on dpe_multi.fact1_p1
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                           Filter: (fact1_p1.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p2
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                           Filter: (fact1_p2.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p3
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                           Filter: (fact1_p3.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p4
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                           Filter: (fact1_p4.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p5
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
                           Filter: (fact1_p5.code = 'OH'::text)
               ->  Hash
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     ->  Full Seq Scan on dpe_multi.dim1
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(30 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=50 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort (actual rows=50 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Hash Join (actual rows=50 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
               ->  Append (actual rows=100 loops=1)
                     ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=25 loops=1)
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                           Filter: (fact1_p1.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=25 loops=1)
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                           Filter: (fact1_p2.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p3 (actual rows=25 loops=1)
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                           Filter: (fact1_p3.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p4 (actual rows=25 loops=1)
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                           Filter: (fact1_p4.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
                           Filter: (fact1_p5.code = 'OH'::text)
               ->  Hash (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(33 rows)

set polar_px_optimizer_enable_partition_selection=on;
explain (costs off, timing off, summary off) select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) and fact1.code = 'OH' order by fact1.u;
                   QUERY PLAN                    
-------------------------------------------------
 Sort
   Sort Key: fact1_p1.u
   ->  Hash Join
         Hash Cond: (fact1_p1.pid = dim1.pid)
         ->  Append
               ->  Seq Scan on fact1_p1
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p2
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p3
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p4
                     Filter: (code = 'OH'::text)
               ->  Seq Scan on fact1_p5
                     Filter: (code = 'OH'::text)
         ->  Hash
               ->  Seq Scan on dim1
(17 rows)

select * from dim1 inner join fact1 on (dim1.pid=fact1.pid) and fact1.code = 'OH' order by fact1.u;
 dist | pid | code |   t1   | dist | pid | code |  u  
------+-----+------+--------+------+-----+------+-----
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   1
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   4
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   5
    1 |   0 | OH   | world1 |    1 |   0 | OH   |   8
    1 |   1 | OH   | world2 |    1 |   1 | OH   |   9
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  12
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  13
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  16
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  17
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  20
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  21
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  24
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  25
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  28
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  29
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  32
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  33
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  36
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  37
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  40
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  41
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  44
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  45
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  48
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  49
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  52
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  53
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  56
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  57
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  60
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  61
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  64
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  65
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  68
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  69
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  72
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  73
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  76
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  77
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  80
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  81
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  84
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  85
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  88
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  89
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  92
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  93
    1 |   0 | OH   | world1 |    1 |   0 | OH   |  96
    1 |   1 | OH   | world2 |    1 |   1 | OH   |  97
    1 |   0 | OH   | world1 |    1 |   0 | OH   | 100
(50 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         ->  Hash Join
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               ->  Append
                     Partition Selectors: $0
                     ->  Partial Seq Scan on dpe_multi.fact1_p1
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                           Filter: (fact1_p1.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p2
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                           Filter: (fact1_p2.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p3
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                           Filter: (fact1_p3.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p4
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                           Filter: (fact1_p4.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p5
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
                           Filter: (fact1_p5.code = 'OH'::text)
               ->  Hash
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     ->  Partition Selector (selector id: $0)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                           ->  Full Seq Scan on dpe_multi.dim1
                                 Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(33 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=50 loops=1)
   Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
   Merge Key: fact1_p1.u
   ->  Sort (actual rows=50 loops=1)
         Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
         Sort Key: fact1_p1.u
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Hash Join (actual rows=50 loops=1)
               Output: dim1.dist, dim1.pid, dim1.code, dim1.t1, fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
               Hash Cond: (fact1_p1.pid = dim1.pid)
               work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
               ->  Append (actual rows=50 loops=1)
                     Partition Selectors: $0
                     ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=25 loops=1)
                           Output: fact1_p1.dist, fact1_p1.pid, fact1_p1.code, fact1_p1.u
                           Filter: (fact1_p1.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=25 loops=1)
                           Output: fact1_p2.dist, fact1_p2.pid, fact1_p2.code, fact1_p2.u
                           Filter: (fact1_p2.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p3 (never executed)
                           Output: fact1_p3.dist, fact1_p3.pid, fact1_p3.code, fact1_p3.u
                           Filter: (fact1_p3.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p4 (never executed)
                           Output: fact1_p4.dist, fact1_p4.pid, fact1_p4.code, fact1_p4.u
                           Filter: (fact1_p4.code = 'OH'::text)
                     ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                           Output: fact1_p5.dist, fact1_p5.pid, fact1_p5.code, fact1_p5.u
                           Filter: (fact1_p5.code = 'OH'::text)
               ->  Hash (actual rows=3 loops=1)
                     Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Partition Selector (selector id: $0) (actual rows=3 loops=1)
                           Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
                           ->  Full Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                                 Output: dim1.dist, dim1.pid, dim1.code, dim1.t1
 Optimizer: PolarDB PX Optimizer
(36 rows)

--
-- add aggregates
--
set polar_px_optimizer_enable_partition_selection=off;
explain (costs off, timing off, summary off) select fact1.code, count(*) from dim1 inner join fact1 on (dim1.pid=fact1.pid) group by 1 order by 1;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: fact1_p1.code
   ->  HashAggregate
         Group Key: fact1_p1.code
         ->  Hash Join
               Hash Cond: (fact1_p1.pid = dim1.pid)
               ->  Append
                     ->  Seq Scan on fact1_p1
                     ->  Seq Scan on fact1_p2
                     ->  Seq Scan on fact1_p3
                     ->  Seq Scan on fact1_p4
                     ->  Seq Scan on fact1_p5
               ->  Hash
                     ->  Seq Scan on dim1
(14 rows)

select fact1.code, count(*) from dim1 inner join fact1 on (dim1.pid=fact1.pid) group by 1 order by 1;
 code | count 
------+-------
 CA   |    50
 OH   |    50
(2 rows)

                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fact1_p1.code, (count())
   Merge Key: fact1_p1.code
   ->  Sort
         Output: fact1_p1.code, (count())
         Sort Key: fact1_p1.code
         ->  Finalize GroupAggregate
               Output: fact1_p1.code, count()
               Group Key: fact1_p1.code
               ->  Sort
                     Output: fact1_p1.code, (PARTIAL count())
                     Sort Key: fact1_p1.code
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: fact1_p1.code, (PARTIAL count())
                           Hash Key: fact1_p1.code
                           ->  Partial GroupAggregate
                                 Output: fact1_p1.code, PARTIAL count()
                                 Group Key: fact1_p1.code
                                 ->  Sort
                                       Output: fact1_p1.code
                                       Sort Key: fact1_p1.code
                                       ->  Hash Join
                                             Output: fact1_p1.code
                                             Hash Cond: (fact1_p1.pid = dim1.pid)
                                             ->  Append
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p1
                                                         Output: fact1_p1.pid, fact1_p1.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p2
                                                         Output: fact1_p2.pid, fact1_p2.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p3
                                                         Output: fact1_p3.pid, fact1_p3.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p4
                                                         Output: fact1_p4.pid, fact1_p4.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p5
                                                         Output: fact1_p5.pid, fact1_p5.code
                                             ->  Hash
                                                   Output: dim1.pid
                                                   ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                         Output: dim1.pid
                                                         ->  Partial Seq Scan on dpe_multi.dim1
                                                               Output: dim1.pid
 Optimizer: PolarDB PX Optimizer
(42 rows)

                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=2 loops=1)
   Output: fact1_p1.code, (count())
   Merge Key: fact1_p1.code
   ->  Sort (actual rows=1 loops=1)
         Output: fact1_p1.code, (count())
         Sort Key: fact1_p1.code
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Finalize GroupAggregate (actual rows=1 loops=1)
               Output: fact1_p1.code, count()
               Group Key: fact1_p1.code
               ->  Sort (actual rows=1 loops=1)
                     Output: fact1_p1.code, (PARTIAL count())
                     Sort Key: fact1_p1.code
                     work_mem: 164kB  Workers: 6  Max: 28kB (worker 1)  Workfile: (0 spilling)
                     ->  PX Hash 6:6  (slice2; segments: 6) (actual rows=1 loops=1)
                           Output: fact1_p1.code, (PARTIAL count())
                           Hash Key: fact1_p1.code
                           ->  Partial GroupAggregate (actual rows=2 loops=1)
                                 Output: fact1_p1.code, PARTIAL count()
                                 Group Key: fact1_p1.code
                                 ->  Sort (actual rows=100 loops=1)
                                       Output: fact1_p1.code
                                       Sort Key: fact1_p1.code
                                       work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
                                       ->  Hash Join (actual rows=100 loops=1)
                                             Output: fact1_p1.code
                                             Hash Cond: (fact1_p1.pid = dim1.pid)
                                             work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
                                             ->  Append (actual rows=200 loops=1)
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                                                         Output: fact1_p1.pid, fact1_p1.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                                                         Output: fact1_p2.pid, fact1_p2.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p3 (actual rows=50 loops=1)
                                                         Output: fact1_p3.pid, fact1_p3.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p4 (actual rows=50 loops=1)
                                                         Output: fact1_p4.pid, fact1_p4.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                                                         Output: fact1_p5.pid, fact1_p5.code
                                             ->  Hash (actual rows=3 loops=1)
                                                   Output: dim1.pid
                                                   Buckets: 1024  Batches: 1  Memory Usage: 9kB
                                                   ->  PX Broadcast 6:6  (slice3; segments: 6) (actual rows=3 loops=1)
                                                         Output: dim1.pid
                                                         ->  Partial Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                                                               Output: dim1.pid
 Optimizer: PolarDB PX Optimizer
(47 rows)

set polar_px_optimizer_enable_partition_selection=on;
explain (costs off, timing off, summary off) select fact1.code, count(*) from dim1 inner join fact1 on (dim1.pid=fact1.pid) group by 1 order by 1;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: fact1_p1.code
   ->  HashAggregate
         Group Key: fact1_p1.code
         ->  Hash Join
               Hash Cond: (fact1_p1.pid = dim1.pid)
               ->  Append
                     ->  Seq Scan on fact1_p1
                     ->  Seq Scan on fact1_p2
                     ->  Seq Scan on fact1_p3
                     ->  Seq Scan on fact1_p4
                     ->  Seq Scan on fact1_p5
               ->  Hash
                     ->  Seq Scan on dim1
(14 rows)

select fact1.code, count(*) from dim1 inner join fact1 on (dim1.pid=fact1.pid) group by 1 order by 1;
 code | count 
------+-------
 CA   |    50
 OH   |    50
(2 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: fact1_p1.code, (count())
   Merge Key: fact1_p1.code
   ->  Sort
         Output: fact1_p1.code, (count())
         Sort Key: fact1_p1.code
         ->  Finalize GroupAggregate
               Output: fact1_p1.code, count()
               Group Key: fact1_p1.code
               ->  Sort
                     Output: fact1_p1.code, (PARTIAL count())
                     Sort Key: fact1_p1.code
                     ->  PX Hash 6:6  (slice2; segments: 6)
                           Output: fact1_p1.code, (PARTIAL count())
                           Hash Key: fact1_p1.code
                           ->  Partial GroupAggregate
                                 Output: fact1_p1.code, PARTIAL count()
                                 Group Key: fact1_p1.code
                                 ->  Sort
                                       Output: fact1_p1.code
                                       Sort Key: fact1_p1.code
                                       ->  Hash Join
                                             Output: fact1_p1.code
                                             Hash Cond: (fact1_p1.pid = dim1.pid)
                                             ->  Append
                                                   Partition Selectors: $0
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p1
                                                         Output: fact1_p1.pid, fact1_p1.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p2
                                                         Output: fact1_p2.pid, fact1_p2.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p3
                                                         Output: fact1_p3.pid, fact1_p3.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p4
                                                         Output: fact1_p4.pid, fact1_p4.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p5
                                                         Output: fact1_p5.pid, fact1_p5.code
                                             ->  Hash
                                                   Output: dim1.pid
                                                   ->  Partition Selector (selector id: $0)
                                                         Output: dim1.pid
                                                         ->  PX Broadcast 6:6  (slice3; segments: 6)
                                                               Output: dim1.pid
                                                               ->  Partial Seq Scan on dpe_multi.dim1
                                                                     Output: dim1.pid
 Optimizer: PolarDB PX Optimizer
(45 rows)

                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=2 loops=1)
   Output: fact1_p1.code, (count())
   Merge Key: fact1_p1.code
   ->  Sort (actual rows=1 loops=1)
         Output: fact1_p1.code, (count())
         Sort Key: fact1_p1.code
         work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
         ->  Finalize GroupAggregate (actual rows=1 loops=1)
               Output: fact1_p1.code, count()
               Group Key: fact1_p1.code
               ->  Sort (actual rows=1 loops=1)
                     Output: fact1_p1.code, (PARTIAL count())
                     Sort Key: fact1_p1.code
                     work_mem: 164kB  Workers: 6  Max: 28kB (worker 1)  Workfile: (0 spilling)
                     ->  PX Hash 6:6  (slice2; segments: 6) (actual rows=1 loops=1)
                           Output: fact1_p1.code, (PARTIAL count())
                           Hash Key: fact1_p1.code
                           ->  Partial GroupAggregate (actual rows=2 loops=1)
                                 Output: fact1_p1.code, PARTIAL count()
                                 Group Key: fact1_p1.code
                                 ->  Sort (actual rows=100 loops=1)
                                       Output: fact1_p1.code
                                       Sort Key: fact1_p1.code
                                       work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
                                       ->  Hash Join (actual rows=100 loops=1)
                                             Output: fact1_p1.code
                                             Hash Cond: (fact1_p1.pid = dim1.pid)
                                             work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
                                             ->  Append (actual rows=100 loops=1)
                                                   Partition Selectors: $0
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p1 (actual rows=50 loops=1)
                                                         Output: fact1_p1.pid, fact1_p1.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p2 (actual rows=50 loops=1)
                                                         Output: fact1_p2.pid, fact1_p2.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p3 (never executed)
                                                         Output: fact1_p3.pid, fact1_p3.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p4 (never executed)
                                                         Output: fact1_p4.pid, fact1_p4.code
                                                   ->  Partial Seq Scan on dpe_multi.fact1_p5 (never executed)
                                                         Output: fact1_p5.pid, fact1_p5.code
                                             ->  Hash (actual rows=3 loops=1)
                                                   Output: dim1.pid
                                                   Buckets: 1024  Batches: 1  Memory Usage: 9kB
                                                   ->  Partition Selector (selector id: $0) (actual rows=3 loops=1)
                                                         Output: dim1.pid
                                                         ->  PX Broadcast 6:6  (slice3; segments: 6) (actual rows=3 loops=1)
                                                               Output: dim1.pid
                                                               ->  Partial Seq Scan on dpe_multi.dim1 (actual rows=3 loops=1)
                                                                     Output: dim1.pid
 Optimizer: PolarDB PX Optimizer
(50 rows)

--
-- multi-attribute list partitioning
--
-- Before GPDB 7, we used to support multi-column list partitions natively,
-- and these queries did partition elimination. We don't support that anymore,
-- but emulate that by using a row expression as the partitioning key. You
-- don't get partition elimination with that, however, so these tests are not
-- very interesting anymore.
--
drop schema if exists dpe_malp cascade;
NOTICE:  schema "dpe_malp" does not exist, skipping
create schema dpe_malp;
set search_path='dpe_malp';
create type malp_key as (i int, j int);
create table malp (i int, j int, t text) 
partition by list ((row(i, j)::malp_key));
create table malp_p1 partition of malp for values in (row(1, 10));
ERROR:  syntax error at or near "row"
LINE 1: ...te table malp_p1 partition of malp for values in (row(1, 10)...
                                                             ^
create table malp_p2 partition of malp for values in (row(2, 20));
ERROR:  syntax error at or near "row"
LINE 1: ...te table malp_p2 partition of malp for values in (row(2, 20)...
                                                             ^
create table malp_p3 partition of malp for values in (row(3, 30));
ERROR:  syntax error at or near "row"
LINE 1: ...te table malp_p3 partition of malp for values in (row(3, 30)...
                                                             ^
insert into malp select 1, 10, 'hello1';
ERROR:  no partition of relation "malp" found for row
DETAIL:  Partition key of the failing row contains ((ROW(i, j)::malp_key)) = ((1,10)).
insert into malp select 1, 10, 'hello2';
ERROR:  no partition of relation "malp" found for row
DETAIL:  Partition key of the failing row contains ((ROW(i, j)::malp_key)) = ((1,10)).
insert into malp select 1, 10, 'hello3';
ERROR:  no partition of relation "malp" found for row
DETAIL:  Partition key of the failing row contains ((ROW(i, j)::malp_key)) = ((1,10)).
insert into malp select 2, 20, 'hello4';
ERROR:  no partition of relation "malp" found for row
DETAIL:  Partition key of the failing row contains ((ROW(i, j)::malp_key)) = ((2,20)).
insert into malp select 2, 20, 'hello5';
ERROR:  no partition of relation "malp" found for row
DETAIL:  Partition key of the failing row contains ((ROW(i, j)::malp_key)) = ((2,20)).
insert into malp select 3, 30, 'hello6';
ERROR:  no partition of relation "malp" found for row
DETAIL:  Partition key of the failing row contains ((ROW(i, j)::malp_key)) = ((3,30)).
create table dim(i int, j int)
distributed randomly;
ERROR:  syntax error at or near "distributed"
LINE 2: distributed randomly;
        ^
insert into dim values(1, 10);
ERROR:  relation "dim" does not exist
LINE 1: insert into dim values(1, 10);
                    ^
analyze malp;
analyze dim;
ERROR:  relation "dim" does not exist
-- ORCA doesn't do multi-attribute partitioning currently,so this falls
-- back to the Postgres planner
explain (costs off, timing off, summary off) select * from dim inner join malp on (dim.i = malp.i);
ERROR:  relation "dim" does not exist
LINE 1: ...costs off, timing off, summary off) select * from dim inner ...
                                                             ^
set polar_px_optimizer_enable_partition_selection = off;
select * from dim inner join malp on (dim.i = malp.i);
ERROR:  relation "dim" does not exist
LINE 1: select * from dim inner join malp on (dim.i = malp.i);
                      ^
set polar_px_optimizer_enable_partition_selection = on;
select * from dim inner join malp on (dim.i = malp.i);
ERROR:  relation "dim" does not exist
LINE 1: select * from dim inner join malp on (dim.i = malp.i);
                      ^
set polar_px_optimizer_enable_partition_selection = on;
-- if only the planner was smart enough, one partition would be chosen
select * from dim inner join malp on (dim.i = malp.i and dim.j = malp.j);
ERROR:  relation "dim" does not exist
LINE 1: select * from dim inner join malp on (dim.i = malp.i and dim...
                      ^
--
-- Plan where the Append that the PartitionSelector affects is not the immediate child
-- of the join.
--
create table apart (id int4, t text) partition by range (id);
CREATE TABLE apart_p1 PARTITION of apart for values from (0) to (200);
CREATE TABLE apart_p2 PARTITION of apart for values from (200) to (400);
CREATE TABLE apart_p3 PARTITION of apart for values from (400) to (600);
CREATE TABLE apart_p4 PARTITION of apart for values from (600) to (800);
CREATE TABLE apart_p5 PARTITION of apart for values from (800) to (1000);
create table b (id int4, t text);
create table c (id int4, t text);
insert into apart select g, g from generate_series(1, 999) g;
insert into b select g, g from generate_series(1, 5) g;
insert into c select g, g from generate_series(1, 20) g;
analyze apart;
analyze b;
analyze c;
set polar_px_optimizer_enable_partition_selection = off;
explain (costs off, timing off, summary off) select * from apart as a, b, c where a.t = b.t and a.id = c.id;
                 QUERY PLAN                 
--------------------------------------------
 Hash Join
   Hash Cond: (a.id = c.id)
   ->  Hash Join
         Hash Cond: (a.t = b.t)
         ->  Append
               ->  Seq Scan on apart_p1 a
               ->  Seq Scan on apart_p2 a_1
               ->  Seq Scan on apart_p3 a_2
               ->  Seq Scan on apart_p4 a_3
               ->  Seq Scan on apart_p5 a_4
         ->  Hash
               ->  Seq Scan on b
   ->  Hash
         ->  Seq Scan on c
(14 rows)

select * from apart as a, b, c where a.t = b.t and a.id = c.id;
 id | t | id | t | id | t 
----+---+----+---+----+---
  1 | 1 |  1 | 1 |  1 | 1
  2 | 2 |  2 | 2 |  2 | 2
  3 | 3 |  3 | 3 |  3 | 3
  4 | 4 |  4 | 4 |  4 | 4
  5 | 5 |  5 | 5 |  5 | 5
(5 rows)

                              QUERY PLAN                               
-----------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
   ->  Hash Join
         Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
         Hash Cond: (apart_p1.id = c.id)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: apart_p1.id, apart_p1.t, b.id, b.t
               Hash Key: apart_p1.id
               ->  Hash Join
                     Output: apart_p1.id, apart_p1.t, b.id, b.t
                     Hash Cond: (apart_p1.t = b.t)
                     ->  Append
                           ->  Partial Seq Scan on dpe_malp.apart_p1
                                 Output: apart_p1.id, apart_p1.t
                           ->  Partial Seq Scan on dpe_malp.apart_p2
                                 Output: apart_p2.id, apart_p2.t
                           ->  Partial Seq Scan on dpe_malp.apart_p3
                                 Output: apart_p3.id, apart_p3.t
                           ->  Partial Seq Scan on dpe_malp.apart_p4
                                 Output: apart_p4.id, apart_p4.t
                           ->  Partial Seq Scan on dpe_malp.apart_p5
                                 Output: apart_p5.id, apart_p5.t
                     ->  Hash
                           Output: b.id, b.t
                           ->  PX Broadcast 6:6  (slice3; segments: 6)
                                 Output: b.id, b.t
                                 ->  Partial Seq Scan on dpe_malp.b
                                       Output: b.id, b.t
         ->  Hash
               Output: c.id, c.t
               ->  PX Hash 6:6  (slice4; segments: 6)
                     Output: c.id, c.t
                     Hash Key: c.id
                     ->  Partial Seq Scan on dpe_malp.c
                           Output: c.id, c.t
 Optimizer: PolarDB PX Optimizer
(36 rows)

                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=5 loops=1)
   Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
   ->  Hash Join (actual rows=2 loops=1)
         Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
         Hash Cond: (apart_p1.id = c.id)
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 2)  Workfile: (0 spilling)
         ->  PX Hash 6:6  (slice2; segments: 6) (actual rows=2 loops=1)
               Output: apart_p1.id, apart_p1.t, b.id, b.t
               Hash Key: apart_p1.id
               ->  Hash Join (actual rows=5 loops=1)
                     Output: apart_p1.id, apart_p1.t, b.id, b.t
                     Hash Cond: (apart_p1.t = b.t)
                     work_mem: 50kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
                     ->  Append (actual rows=999 loops=1)
                           ->  Partial Seq Scan on dpe_malp.apart_p1 (actual rows=199 loops=1)
                                 Output: apart_p1.id, apart_p1.t
                           ->  Partial Seq Scan on dpe_malp.apart_p2 (actual rows=200 loops=1)
                                 Output: apart_p2.id, apart_p2.t
                           ->  Partial Seq Scan on dpe_malp.apart_p3 (actual rows=200 loops=1)
                                 Output: apart_p3.id, apart_p3.t
                           ->  Partial Seq Scan on dpe_malp.apart_p4 (actual rows=200 loops=1)
                                 Output: apart_p4.id, apart_p4.t
                           ->  Partial Seq Scan on dpe_malp.apart_p5 (actual rows=200 loops=1)
                                 Output: apart_p5.id, apart_p5.t
                     ->  Hash (actual rows=5 loops=1)
                           Output: b.id, b.t
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  PX Broadcast 6:6  (slice3; segments: 6) (actual rows=5 loops=1)
                                 Output: b.id, b.t
                                 ->  Partial Seq Scan on dpe_malp.b (actual rows=5 loops=1)
                                       Output: b.id, b.t
         ->  Hash (actual rows=5 loops=1)
               Output: c.id, c.t
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  PX Hash 6:6  (slice4; segments: 6) (actual rows=5 loops=1)
                     Output: c.id, c.t
                     Hash Key: c.id
                     ->  Partial Seq Scan on dpe_malp.c (actual rows=20 loops=1)
                           Output: c.id, c.t
 Optimizer: PolarDB PX Optimizer
(40 rows)

set polar_px_optimizer_enable_partition_selection = on;
explain (costs off, timing off, summary off) select * from apart as a, b, c where a.t = b.t and a.id = c.id;
                 QUERY PLAN                 
--------------------------------------------
 Hash Join
   Hash Cond: (a.id = c.id)
   ->  Hash Join
         Hash Cond: (a.t = b.t)
         ->  Append
               ->  Seq Scan on apart_p1 a
               ->  Seq Scan on apart_p2 a_1
               ->  Seq Scan on apart_p3 a_2
               ->  Seq Scan on apart_p4 a_3
               ->  Seq Scan on apart_p5 a_4
         ->  Hash
               ->  Seq Scan on b
   ->  Hash
         ->  Seq Scan on c
(14 rows)

select * from apart as a, b, c where a.t = b.t and a.id = c.id;
 id | t | id | t | id | t 
----+---+----+---+----+---
  1 | 1 |  1 | 1 |  1 | 1
  2 | 2 |  2 | 2 |  2 | 2
  3 | 3 |  3 | 3 |  3 | 3
  4 | 4 |  4 | 4 |  4 | 4
  5 | 5 |  5 | 5 |  5 | 5
(5 rows)

                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
   ->  Hash Join
         Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
         Hash Cond: (apart_p1.t = b.t)
         ->  PX Hash 6:6  (slice2; segments: 6)
               Output: apart_p1.id, apart_p1.t, c.id, c.t
               Hash Key: apart_p1.t
               ->  Hash Join
                     Output: apart_p1.id, apart_p1.t, c.id, c.t
                     Hash Cond: (apart_p1.id = c.id)
                     ->  Append
                           Partition Selectors: $0
                           ->  Partial Seq Scan on dpe_malp.apart_p1
                                 Output: apart_p1.id, apart_p1.t
                           ->  Partial Seq Scan on dpe_malp.apart_p2
                                 Output: apart_p2.id, apart_p2.t
                           ->  Partial Seq Scan on dpe_malp.apart_p3
                                 Output: apart_p3.id, apart_p3.t
                           ->  Partial Seq Scan on dpe_malp.apart_p4
                                 Output: apart_p4.id, apart_p4.t
                           ->  Partial Seq Scan on dpe_malp.apart_p5
                                 Output: apart_p5.id, apart_p5.t
                     ->  Hash
                           Output: c.id, c.t
                           ->  Partition Selector (selector id: $0)
                                 Output: c.id, c.t
                                 ->  PX Broadcast 6:6  (slice3; segments: 6)
                                       Output: c.id, c.t
                                       ->  Partial Seq Scan on dpe_malp.c
                                             Output: c.id, c.t
         ->  Hash
               Output: b.id, b.t
               ->  PX Hash 6:6  (slice4; segments: 6)
                     Output: b.id, b.t
                     Hash Key: b.t
                     ->  Partial Seq Scan on dpe_malp.b
                           Output: b.id, b.t
 Optimizer: PolarDB PX Optimizer
(39 rows)

                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=5 loops=1)
   Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
   ->  Hash Join (actual rows=1 loops=1)
         Output: apart_p1.id, apart_p1.t, b.id, b.t, c.id, c.t
         Hash Cond: (apart_p1.t = b.t)
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  PX Hash 6:6  (slice2; segments: 6) (actual rows=5 loops=1)
               Output: apart_p1.id, apart_p1.t, c.id, c.t
               Hash Key: apart_p1.t
               ->  Hash Join (actual rows=20 loops=1)
                     Output: apart_p1.id, apart_p1.t, c.id, c.t
                     Hash Cond: (apart_p1.id = c.id)
                     work_mem: 53kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
                     ->  Append (actual rows=199 loops=1)
                           Partition Selectors: $0
                           ->  Partial Seq Scan on dpe_malp.apart_p1 (actual rows=199 loops=1)
                                 Output: apart_p1.id, apart_p1.t
                           ->  Partial Seq Scan on dpe_malp.apart_p2 (never executed)
                                 Output: apart_p2.id, apart_p2.t
                           ->  Partial Seq Scan on dpe_malp.apart_p3 (never executed)
                                 Output: apart_p3.id, apart_p3.t
                           ->  Partial Seq Scan on dpe_malp.apart_p4 (never executed)
                                 Output: apart_p4.id, apart_p4.t
                           ->  Partial Seq Scan on dpe_malp.apart_p5 (never executed)
                                 Output: apart_p5.id, apart_p5.t
                     ->  Hash (actual rows=20 loops=1)
                           Output: c.id, c.t
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  Partition Selector (selector id: $0) (actual rows=20 loops=1)
                                 Output: c.id, c.t
                                 ->  PX Broadcast 6:6  (slice3; segments: 6) (actual rows=20 loops=1)
                                       Output: c.id, c.t
                                       ->  Partial Seq Scan on dpe_malp.c (actual rows=20 loops=1)
                                             Output: c.id, c.t
         ->  Hash (actual rows=1 loops=1)
               Output: b.id, b.t
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  PX Hash 6:6  (slice4; segments: 6) (actual rows=1 loops=1)
                     Output: b.id, b.t
                     Hash Key: b.t
                     ->  Partial Seq Scan on dpe_malp.b (actual rows=5 loops=1)
                           Output: b.id, b.t
 Optimizer: PolarDB PX Optimizer
(43 rows)

--
-- DPE: assertion failed with window function
--
drop schema if exists dpe_bugs cascade;
NOTICE:  schema "dpe_bugs" does not exist, skipping
create schema dpe_bugs;
set search_path='dpe_bugs';
create table pat(a int, b date) partition by range (b);
CREATE TABLE pat_p1 PARTITION of pat for values from ('2010-01-01') to ('2010-01-02');
CREATE TABLE pat_p2 PARTITION of pat for values from ('2010-01-02') to ('2010-01-03');
CREATE TABLE pat_p3 PARTITION of pat for values from ('2010-01-03') to ('2010-01-04');
CREATE TABLE pat_p4 PARTITION of pat for values from ('2010-01-04') to ('2010-01-05');
CREATE TABLE pat_p5 PARTITION of pat for values from ('2010-01-01') to ('2010-01-02');
ERROR:  partition "pat_p5" would overlap partition "pat_p1"
CREATE TABLE pat_p6 PARTITION of pat default;
insert into pat select i,date '2010-01-01' + i from generate_series(1, 10)i;  
create table jpat(a int, b date);
insert into jpat values(1, '2010-01-02');
analyze jpat;
-- start_ignore
-- Known_opt_diff: MPP-21323
-- end_ignore
explain (costs off, timing off, summary off) select * from (select count(*) over (order by a rows between 1 preceding and 1 following), a, b from jpat)jpat inner join pat using(b);
                      QUERY PLAN                       
-------------------------------------------------------
 Hash Join
   Hash Cond: (pat_p1.b = jpat.b)
   ->  Append
         ->  Seq Scan on pat_p1
         ->  Seq Scan on pat_p2
         ->  Seq Scan on pat_p3
         ->  Seq Scan on pat_p4
         ->  Seq Scan on pat_p6
   ->  Hash
         ->  Subquery Scan on jpat
               ->  WindowAgg
                     ->  Sort
                           Sort Key: jpat_1.a
                           ->  Seq Scan on jpat jpat_1
(14 rows)

select * from (select count(*) over (order by a rows between 1 preceding and 1 following), a, b from jpat)jpat inner join pat using(b);
     b      | count | a | a 
------------+-------+---+---
 01-02-2010 |     1 | 1 | 1
(1 row)

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6)
   Output: jpat.b, (count(*) OVER (?)), jpat.a, pat_p1.a
   ->  Hash Join
         Output: jpat.b, (count(*) OVER (?)), jpat.a, pat_p1.a
         Hash Cond: (pat_p1.b = jpat.b)
         ->  Append
               Partition Selectors: $0
               ->  Partial Seq Scan on dpe_bugs.pat_p1
                     Output: pat_p1.a, pat_p1.b
               ->  Partial Seq Scan on dpe_bugs.pat_p2
                     Output: pat_p2.a, pat_p2.b
               ->  Partial Seq Scan on dpe_bugs.pat_p3
                     Output: pat_p3.a, pat_p3.b
               ->  Partial Seq Scan on dpe_bugs.pat_p4
                     Output: pat_p4.a, pat_p4.b
               ->  Partial Seq Scan on dpe_bugs.pat_p6
                     Output: pat_p6.a, pat_p6.b
         ->  Hash
               Output: jpat.a, jpat.b, (count(*) OVER (?))
               ->  Partition Selector (selector id: $0)
                     Output: jpat.a, jpat.b, (count(*) OVER (?))
                     ->  PX Broadcast 1:6  (slice2)
                           Output: jpat.a, jpat.b, (count(*) OVER (?))
                           ->  WindowAgg
                                 Output: jpat.a, jpat.b, count(*) OVER (?)
                                 ->  PX Coordinator 6:1  (slice3; segments: 6)
                                       Output: jpat.a, jpat.b
                                       Merge Key: jpat.a
                                       ->  Sort
                                             Output: jpat.a, jpat.b
                                             Sort Key: jpat.a
                                             ->  Partial Seq Scan on dpe_bugs.jpat
                                                   Output: jpat.a, jpat.b
 Optimizer: PolarDB PX Optimizer
(34 rows)

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 PX Coordinator 6:1  (slice1; segments: 6) (actual rows=1 loops=1)
   Output: jpat.b, (count(*) OVER (?)), jpat.a, pat_p1.a
   ->  Hash Join (actual rows=1 loops=1)
         Output: jpat.b, (count(*) OVER (?)), jpat.a, pat_p1.a
         Hash Cond: (pat_p1.b = jpat.b)
         work_mem: 49kB  Workers: 6  Max: 9kB (worker 0)  Workfile: (0 spilling)
         ->  Append (actual rows=1 loops=1)
               Partition Selectors: $0
               ->  Partial Seq Scan on dpe_bugs.pat_p1 (never executed)
                     Output: pat_p1.a, pat_p1.b
               ->  Partial Seq Scan on dpe_bugs.pat_p2 (actual rows=1 loops=1)
                     Output: pat_p2.a, pat_p2.b
               ->  Partial Seq Scan on dpe_bugs.pat_p3 (never executed)
                     Output: pat_p3.a, pat_p3.b
               ->  Partial Seq Scan on dpe_bugs.pat_p4 (never executed)
                     Output: pat_p4.a, pat_p4.b
               ->  Partial Seq Scan on dpe_bugs.pat_p6 (never executed)
                     Output: pat_p6.a, pat_p6.b
         ->  Hash (actual rows=1 loops=1)
               Output: jpat.a, jpat.b, (count(*) OVER (?))
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Partition Selector (selector id: $0) (actual rows=1 loops=1)
                     Output: jpat.a, jpat.b, (count(*) OVER (?))
                     ->  PX Broadcast 1:6  (slice2) (actual rows=1 loops=1)
                           Output: jpat.a, jpat.b, (count(*) OVER (?))
                           ->  WindowAgg (actual rows=1 loops=1)
                                 Output: jpat.a, jpat.b, count(*) OVER (?)
                                 ->  PX Coordinator 6:1  (slice3; segments: 6) (actual rows=1 loops=1)
                                       Output: jpat.a, jpat.b
                                       Merge Key: jpat.a
                                       ->  Sort (actual rows=1 loops=1)
                                             Output: jpat.a, jpat.b
                                             Sort Key: jpat.a
                                             work_mem: 208kB  Workers: 6  Max: 35kB (worker 0)  Workfile: (0 spilling)
                                             ->  Partial Seq Scan on dpe_bugs.jpat (actual rows=1 loops=1)
                                                   Output: jpat.a, jpat.b
 Optimizer: PolarDB PX Optimizer
(37 rows)

--
-- Partitioning on an expression
--
drop table if exists t;
NOTICE:  table "t" does not exist, skipping
drop table if exists pt;
NOTICE:  table "pt" does not exist, skipping
create table t(id int, b int);
create table pt(id int, b int) partition by range (id);
create table pt1 partition of pt for values from (1) to (2);
create table pt2 partition of pt for values from (2) to (3);
create table pt3 partition of pt for values from (3) to (4);
create table ptx (id int, b int) partition by list (((b) % 2));
create table ptx_even partition of ptx for values in (0);
create table ptx_odd partition of ptx for values in (1);
alter table pt attach partition ptx for values from (4) to (20);
insert into t values (1, 1);
insert into t values (2, 2);
insert into pt select i, i from generate_series(1,7) i;
analyze t;
analyze pt;
-- Prune on the simple partition columns, but not on the expression
explain (costs off, timing off, summary off)
select * from pt, t where t.id = pt.id;
            QUERY PLAN            
----------------------------------
 Hash Join
   Hash Cond: (pt1.id = t.id)
   ->  Append
         ->  Seq Scan on pt1
         ->  Seq Scan on pt2
         ->  Seq Scan on pt3
         ->  Seq Scan on ptx_even
         ->  Seq Scan on ptx_odd
   ->  Hash
         ->  Seq Scan on t
(10 rows)

insert into t values (4, 4), (6, 6), (8, 8), (10, 10);
explain (costs off, timing off, summary off)
select * from pt, t where t.id = pt.id;
            QUERY PLAN            
----------------------------------
 Hash Join
   Hash Cond: (pt1.id = t.id)
   ->  Append
         ->  Seq Scan on pt1
         ->  Seq Scan on pt2
         ->  Seq Scan on pt3
         ->  Seq Scan on ptx_even
         ->  Seq Scan on ptx_odd
   ->  Hash
         ->  Seq Scan on t
(10 rows)

-- Plan-time pruning based on the 'id' partitioning column, and
-- run-time join pruning based on the expression
explain (costs off, timing off, summary off)
select * from pt, t where pt.id = 4 and t.id = 4 and (t.b % 2) = (pt.b % 2);
                  QUERY PLAN                   
-----------------------------------------------
 Nested Loop
   Join Filter: ((ptx_even.b % 2) = (t.b % 2))
   ->  Seq Scan on t
         Filter: (id = 4)
   ->  Append
         ->  Seq Scan on ptx_even
               Filter: (id = 4)
         ->  Seq Scan on ptx_odd
               Filter: (id = 4)
(9 rows)

-- Mixed case
insert into pt values (4, 5);
explain (costs off, timing off, summary off)
select * from pt, t where t.id = pt.id and (t.b % 2) = (pt.b % 2);
                          QUERY PLAN                          
--------------------------------------------------------------
 Hash Join
   Hash Cond: ((pt1.id = t.id) AND ((pt1.b % 2) = (t.b % 2)))
   ->  Append
         ->  Seq Scan on pt1
         ->  Seq Scan on pt2
         ->  Seq Scan on pt3
         ->  Seq Scan on ptx_even
         ->  Seq Scan on ptx_odd
   ->  Hash
         ->  Seq Scan on t
(10 rows)

--
-- Join pruning on an inequality qual
--
drop table if exists t;
drop table if exists pt;
create table t(dist int, tid int) ;
create table pt(dist int, ptid int)  partition by range (ptid);
create table pt1 partition of pt for values from (1) to (2);
create table pt2 partition of pt for values from (2) to (3);
create table pt3 partition of pt for values from (3) to (4);
create table pt4 partition of pt for values from (4) to (5);
create table pt5 partition of pt for values from (5) to (6);
create table ptdefault partition of pt default;
insert into t values (0, 4);
insert into t values (0, 3);
insert into pt select 0, i from generate_series(1,9) i;
analyze t;
analyze pt;
explain (costs off, timing off, summary off)
select * from pt, t where t.dist = pt.dist and t.tid < pt.ptid;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop
   Join Filter: ((t.tid < pt1.ptid) AND (pt1.dist = t.dist))
   ->  Append
         ->  Seq Scan on pt1
         ->  Seq Scan on pt2
         ->  Seq Scan on pt3
         ->  Seq Scan on pt4
         ->  Seq Scan on pt5
         ->  Seq Scan on ptdefault
   ->  Materialize
         ->  Seq Scan on t
(11 rows)

--
-- Test join pruning with a MergeAppend
--
drop table if exists t;
drop table if exists pt;
create table t(dist int, tid int, sk int);
create table pt(dist int, ptid int, sk int)  partition by range (ptid);
create table pt1 partition of pt for values from (1) to (2);
create table pt2 partition of pt for values from (2) to (3);
create table pt3 partition of pt for values from (3) to (4);
create table pt4 partition of pt for values from (4) to (5);
create table pt5 partition of pt for values from (5) to (6);
create table ptdefault partition of pt default;
insert into t values (1, 1, 1);
insert into t values (2, 2, 2);
insert into t select i, i, i from generate_series(5,100) i;
insert into pt select i, i, i from generate_series(1,7) i;
insert into pt select i, i, i from generate_series(1000, 1100) i;
analyze t;
analyze pt;
create index on pt (ptid, sk);
set polar_px_optimizer_enable_mergejoin=on;
set polar_px_optimizer_enable_seqscan=off;
-- force_explain
explain (timing off, summary off, costs off)
select * from pt, t where t.dist = pt.dist and t.tid = pt.ptid order by t.tid, t.sk;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Sort
   Sort Key: pt1.ptid, t.sk
   ->  Merge Join
         Merge Cond: (pt1.ptid = t.tid)
         Join Filter: (pt1.dist = t.dist)
         ->  Merge Append
               Sort Key: pt1.ptid
               ->  Index Scan using pt1_ptid_sk_idx on pt1
               ->  Index Scan using pt2_ptid_sk_idx on pt2
               ->  Index Scan using pt3_ptid_sk_idx on pt3
               ->  Index Scan using pt4_ptid_sk_idx on pt4
               ->  Index Scan using pt5_ptid_sk_idx on pt5
               ->  Index Scan using ptdefault_ptid_sk_idx on ptdefault
         ->  Sort
               Sort Key: t.tid
               ->  Seq Scan on t
(16 rows)

set client_min_messages='warning';
reset polar_px_enable_adps;
drop schema dpe_single cascade;
