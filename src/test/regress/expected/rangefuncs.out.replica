CREATE TABLE rngfunc2(rngfuncid int, f2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO rngfunc2 VALUES(1, 11);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO rngfunc2 VALUES(2, 22);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO rngfunc2 VALUES(1, 111);
ERROR:  cannot execute INSERT in a read-only transaction
CREATE FUNCTION rngfunct(int) returns setof rngfunc2 as 'SELECT * FROM rngfunc2 WHERE rngfuncid = $1 ORDER BY f2;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
-- function with ORDINALITY
select * from rngfunct(1) with ordinality as z(a,b,ord);
 a |  b  | ord 
---+-----+-----
 1 |  11 |   1
 1 | 111 |   2
(2 rows)

select * from rngfunct(1) with ordinality as z(a,b,ord) where b > 100;   -- ordinal 2, not 1
 a |  b  | ord 
---+-----+-----
 1 | 111 |   2
(1 row)

-- ordinality vs. column names and types
select a,b,ord from rngfunct(1) with ordinality as z(a,b,ord);
 a |  b  | ord 
---+-----+-----
 1 |  11 |   1
 1 | 111 |   2
(2 rows)

select a,ord from unnest(array['a','b']) with ordinality as z(a,ord);
 a | ord 
---+-----
 a |   1
 b |   2
(2 rows)

select * from unnest(array['a','b']) with ordinality as z(a,ord);
 a | ord 
---+-----
 a |   1
 b |   2
(2 rows)

select a,ord from unnest(array[1.0::float8]) with ordinality as z(a,ord);
 a | ord 
---+-----
 1 |   1
(1 row)

select * from unnest(array[1.0::float8]) with ordinality as z(a,ord);
 a | ord 
---+-----
 1 |   1
(1 row)

select row_to_json(s.*) from generate_series(11,14) with ordinality s;
       row_to_json       
-------------------------
 {"s":11,"ordinality":1}
 {"s":12,"ordinality":2}
 {"s":13,"ordinality":3}
 {"s":14,"ordinality":4}
(4 rows)

-- ordinality vs. views
create temporary view vw_ord as select * from (values (1)) v(n) join rngfunct(1) with ordinality as z(a,b,ord) on (n=ord);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from vw_ord;
ERROR:  relation "vw_ord" does not exist
LINE 1: select * from vw_ord;
                      ^
select definition from pg_views where viewname='vw_ord';
                               definition                                
-------------------------------------------------------------------------
  SELECT v.n,                                                           +
     z.a,                                                               +
     z.b,                                                               +
     z.ord                                                              +
    FROM (( VALUES (1)) v(n)                                            +
      JOIN rngfunct(1) WITH ORDINALITY z(a, b, ord) ON ((v.n = z.ord)));
(1 row)

drop view vw_ord;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- multiple functions
select * from rows from(rngfunct(1),rngfunct(2)) with ordinality as z(a,b,c,d,ord);
 a |  b  | c | d  | ord 
---+-----+---+----+-----
 1 |  11 | 2 | 22 |   1
 1 | 111 |   |    |   2
(2 rows)

create temporary view vw_ord as select * from (values (1)) v(n) join rows from(rngfunct(1),rngfunct(2)) with ordinality as z(a,b,c,d,ord) on (n=ord);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from vw_ord;
ERROR:  relation "vw_ord" does not exist
LINE 1: select * from vw_ord;
                      ^
select definition from pg_views where viewname='vw_ord';
                                              definition                                               
-------------------------------------------------------------------------------------------------------
  SELECT v.n,                                                                                         +
     z.a,                                                                                             +
     z.b,                                                                                             +
     z.c,                                                                                             +
     z.d,                                                                                             +
     z.ord                                                                                            +
    FROM (( VALUES (1)) v(n)                                                                          +
      JOIN ROWS FROM(rngfunct(1), rngfunct(2)) WITH ORDINALITY z(a, b, c, d, ord) ON ((v.n = z.ord)));
(1 row)

drop view vw_ord;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- expansions of unnest()
select * from unnest(array[10,20],array['foo','bar'],array[1.0]);
 unnest | unnest | unnest 
--------+--------+--------
     10 | foo    |    1.0
     20 | bar    |       
(2 rows)

select * from unnest(array[10,20],array['foo','bar'],array[1.0]) with ordinality as z(a,b,c,ord);
 a  |  b  |  c  | ord 
----+-----+-----+-----
 10 | foo | 1.0 |   1
 20 | bar |     |   2
(2 rows)

select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
 a  |  b  |  c  | ord 
----+-----+-----+-----
 10 | foo | 1.0 |   1
 20 | bar |     |   2
(2 rows)

select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
 a  |  b  |  c  | ord 
----+-----+-----+-----
 10 | foo | 101 |   1
 20 | bar | 102 |   2
(2 rows)

create temporary view vw_ord as select * from unnest(array[10,20],array['foo','bar'],array[1.0]) as z(a,b,c);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from vw_ord;
ERROR:  relation "vw_ord" does not exist
LINE 1: select * from vw_ord;
                      ^
select definition from pg_views where viewname='vw_ord';
                                       definition                                       
----------------------------------------------------------------------------------------
  SELECT z.a,                                                                          +
     z.b,                                                                              +
     z.c                                                                               +
    FROM UNNEST(ARRAY[10, 20], ARRAY['foo'::text, 'bar'::text], ARRAY[1.0]) z(a, b, c);
(1 row)

drop view vw_ord;
ERROR:  cannot execute DROP VIEW in a read-only transaction
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from vw_ord;
ERROR:  relation "vw_ord" does not exist
LINE 1: select * from vw_ord;
                      ^
select definition from pg_views where viewname='vw_ord';
                                       definition                                       
----------------------------------------------------------------------------------------
  SELECT z.a,                                                                          +
     z.b,                                                                              +
     z.c                                                                               +
    FROM UNNEST(ARRAY[10, 20], ARRAY['foo'::text, 'bar'::text], ARRAY[1.0]) z(a, b, c);
(1 row)

drop view vw_ord;
ERROR:  cannot execute DROP VIEW in a read-only transaction
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from vw_ord;
ERROR:  relation "vw_ord" does not exist
LINE 1: select * from vw_ord;
                      ^
select definition from pg_views where viewname='vw_ord';
                                                      definition                                                      
----------------------------------------------------------------------------------------------------------------------
  SELECT z.a,                                                                                                        +
     z.b,                                                                                                            +
     z.c                                                                                                             +
    FROM ROWS FROM(unnest(ARRAY[10, 20]), unnest(ARRAY['foo'::text, 'bar'::text]), generate_series(1, 2)) z(a, b, c);
(1 row)

drop view vw_ord;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- ordinality and multiple functions vs. rewind and reverse scan
begin;
declare rf_cur scroll cursor for select * from rows from(generate_series(1,5),generate_series(1,2)) with ordinality as g(i,j,o);
fetch all from rf_cur;
 i | j | o 
---+---+---
 1 | 1 | 1
 2 | 2 | 2
 3 |   | 3
 4 |   | 4
 5 |   | 5
(5 rows)

fetch backward all from rf_cur;
 i | j | o 
---+---+---
 5 |   | 5
 4 |   | 4
 3 |   | 3
 2 | 2 | 2
 1 | 1 | 1
(5 rows)

fetch all from rf_cur;
 i | j | o 
---+---+---
 1 | 1 | 1
 2 | 2 | 2
 3 |   | 3
 4 |   | 4
 5 |   | 5
(5 rows)

fetch next from rf_cur;
 i | j | o 
---+---+---
(0 rows)

fetch next from rf_cur;
 i | j | o 
---+---+---
(0 rows)

fetch prior from rf_cur;
 i | j | o 
---+---+---
 5 |   | 5
(1 row)

fetch absolute 1 from rf_cur;
 i | j | o 
---+---+---
 1 | 1 | 1
(1 row)

fetch next from rf_cur;
 i | j | o 
---+---+---
 2 | 2 | 2
(1 row)

fetch next from rf_cur;
 i | j | o 
---+---+---
 3 |   | 3
(1 row)

fetch next from rf_cur;
 i | j | o 
---+---+---
 4 |   | 4
(1 row)

fetch prior from rf_cur;
 i | j | o 
---+---+---
 3 |   | 3
(1 row)

fetch prior from rf_cur;
 i | j | o 
---+---+---
 2 | 2 | 2
(1 row)

fetch prior from rf_cur;
 i | j | o 
---+---+---
 1 | 1 | 1
(1 row)

commit;
-- function with implicit LATERAL
select * from rngfunc2, rngfunct(rngfunc2.rngfuncid) z where rngfunc2.f2 = z.f2;
 rngfuncid | f2  | rngfuncid | f2  
-----------+-----+-----------+-----
         1 |  11 |         1 |  11
         2 |  22 |         2 |  22
         1 | 111 |         1 | 111
(3 rows)

-- function with implicit LATERAL and explicit ORDINALITY
select * from rngfunc2, rngfunct(rngfunc2.rngfuncid) with ordinality as z(rngfuncid,f2,ord) where rngfunc2.f2 = z.f2;
 rngfuncid | f2  | rngfuncid | f2  | ord 
-----------+-----+-----------+-----+-----
         1 |  11 |         1 |  11 |   1
         2 |  22 |         2 |  22 |   1
         1 | 111 |         1 | 111 |   2
(3 rows)

-- function in subselect
select * from rngfunc2 where f2 in (select f2 from rngfunct(rngfunc2.rngfuncid) z where z.rngfuncid = rngfunc2.rngfuncid) ORDER BY 1,2;
 rngfuncid | f2  
-----------+-----
         1 |  11
         1 | 111
         2 |  22
(3 rows)

-- function in subselect
select * from rngfunc2 where f2 in (select f2 from rngfunct(1) z where z.rngfuncid = rngfunc2.rngfuncid) ORDER BY 1,2;
 rngfuncid | f2  
-----------+-----
         1 |  11
         1 | 111
(2 rows)

-- function in subselect
select * from rngfunc2 where f2 in (select f2 from rngfunct(rngfunc2.rngfuncid) z where z.rngfuncid = 1) ORDER BY 1,2;
 rngfuncid | f2  
-----------+-----
         1 |  11
         1 | 111
(2 rows)

-- nested functions
select rngfunct.rngfuncid, rngfunct.f2 from rngfunct(sin(pi()/2)::int) ORDER BY 1,2;
 rngfuncid | f2  
-----------+-----
         1 |  11
         1 | 111
(2 rows)

CREATE TABLE rngfunc (rngfuncid int, rngfuncsubid int, rngfuncname text, primary key(rngfuncid,rngfuncsubid));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO rngfunc VALUES(1,1,'Joe');
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO rngfunc VALUES(1,2,'Ed');
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO rngfunc VALUES(2,1,'Mary');
ERROR:  cannot execute INSERT in a read-only transaction
-- sql, proretset = f, prorettype = b
CREATE FUNCTION getrngfunc1(int) RETURNS int AS 'SELECT $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc1(1) AS t1;
 t1 
----
  1
(1 row)

SELECT * FROM getrngfunc1(1) WITH ORDINALITY AS t1(v,o);
 v | o 
---+---
 1 | 1
(1 row)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc1(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 getrngfunc1 
-------------
           1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc1(1) WITH ORDINALITY as t1(v,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 v | o 
---+---
 1 | 1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- sql, proretset = t, prorettype = b
CREATE FUNCTION getrngfunc2(int) RETURNS setof int AS 'SELECT rngfuncid FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc2(1) AS t1;
 t1 
----
  1
  1
(2 rows)

SELECT * FROM getrngfunc2(1) WITH ORDINALITY AS t1(v,o);
 v | o 
---+---
 1 | 1
 1 | 2
(2 rows)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc2(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 getrngfunc2 
-------------
           1
           1
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc2(1) WITH ORDINALITY AS t1(v,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 v | o 
---+---
 1 | 1
 1 | 2
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- sql, proretset = t, prorettype = b
CREATE FUNCTION getrngfunc3(int) RETURNS setof text AS 'SELECT rngfuncname FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc3(1) AS t1;
 t1  
-----
 Joe
 Ed
(2 rows)

SELECT * FROM getrngfunc3(1) WITH ORDINALITY AS t1(v,o);
  v  | o 
-----+---
 Joe | 1
 Ed  | 2
(2 rows)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc3(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 getrngfunc3 
-------------
 Joe
 Ed
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc3(1) WITH ORDINALITY AS t1(v,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
  v  | o 
-----+---
 Joe | 1
 Ed  | 2
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- sql, proretset = f, prorettype = c
CREATE FUNCTION getrngfunc4(int) RETURNS rngfunc AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc4(1) AS t1;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
(1 row)

SELECT * FROM getrngfunc4(1) WITH ORDINALITY AS t1(a,b,c,o);
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
(1 row)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc4(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc4(1) WITH ORDINALITY AS t1(a,b,c,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- sql, proretset = t, prorettype = c
CREATE FUNCTION getrngfunc5(int) RETURNS setof rngfunc AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc5(1) AS t1;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
         1 |            2 | Ed
(2 rows)

SELECT * FROM getrngfunc5(1) WITH ORDINALITY AS t1(a,b,c,o);
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
 1 | 2 | Ed  | 2
(2 rows)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc5(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
         1 |            2 | Ed
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc5(1) WITH ORDINALITY AS t1(a,b,c,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
 1 | 2 | Ed  | 2
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- sql, proretset = f, prorettype = record
CREATE FUNCTION getrngfunc6(int) RETURNS RECORD AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc6(1) AS t1(rngfuncid int, rngfuncsubid int, rngfuncname text);
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
(1 row)

SELECT * FROM ROWS FROM( getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) ) WITH ORDINALITY;
 rngfuncid | rngfuncsubid | rngfuncname | ordinality 
-----------+--------------+-------------+------------
         1 |            1 | Joe         |          1
(1 row)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc6(1) AS
(rngfuncid int, rngfuncsubid int, rngfuncname text);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS
  SELECT * FROM ROWS FROM( getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) )
                WITH ORDINALITY;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname | ordinality 
-----------+--------------+-------------+------------
         1 |            1 | Joe         |          1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- sql, proretset = t, prorettype = record
CREATE FUNCTION getrngfunc7(int) RETURNS setof record AS 'SELECT * FROM rngfunc WHERE rngfuncid = $1;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc7(1) AS t1(rngfuncid int, rngfuncsubid int, rngfuncname text);
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
         1 |            2 | Ed
(2 rows)

SELECT * FROM ROWS FROM( getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) ) WITH ORDINALITY;
 rngfuncid | rngfuncsubid | rngfuncname | ordinality 
-----------+--------------+-------------+------------
         1 |            1 | Joe         |          1
         1 |            2 | Ed          |          2
(2 rows)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc7(1) AS
(rngfuncid int, rngfuncsubid int, rngfuncname text);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
         1 |            2 | Ed
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS
  SELECT * FROM ROWS FROM( getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text) )
                WITH ORDINALITY;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname | ordinality 
-----------+--------------+-------------+------------
         1 |            1 | Joe         |          1
         1 |            2 | Ed          |          2
(2 rows)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- plpgsql, proretset = f, prorettype = b
CREATE FUNCTION getrngfunc8(int) RETURNS int AS 'DECLARE rngfuncint int; BEGIN SELECT rngfuncid into rngfuncint FROM rngfunc WHERE rngfuncid = $1; RETURN rngfuncint; END;' LANGUAGE plpgsql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc8(1) AS t1;
 t1 
----
  1
(1 row)

SELECT * FROM getrngfunc8(1) WITH ORDINALITY AS t1(v,o);
 v | o 
---+---
 1 | 1
(1 row)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc8(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 getrngfunc8 
-------------
           1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc8(1) WITH ORDINALITY AS t1(v,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 v | o 
---+---
 1 | 1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- plpgsql, proretset = f, prorettype = c
CREATE FUNCTION getrngfunc9(int) RETURNS rngfunc AS 'DECLARE rngfunctup rngfunc%ROWTYPE; BEGIN SELECT * into rngfunctup FROM rngfunc WHERE rngfuncid = $1; RETURN rngfunctup; END;' LANGUAGE plpgsql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM getrngfunc9(1) AS t1;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
(1 row)

SELECT * FROM getrngfunc9(1) WITH ORDINALITY AS t1(a,b,c,o);
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
(1 row)

CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc9(1);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 rngfuncid | rngfuncsubid | rngfuncname 
-----------+--------------+-------------
         1 |            1 | Joe
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
CREATE VIEW vw_getrngfunc AS SELECT * FROM getrngfunc9(1) WITH ORDINALITY AS t1(a,b,c,o);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
SELECT * FROM vw_getrngfunc;
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
(1 row)

DROP VIEW vw_getrngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- mix 'n match kinds, to exercise expandRTE and related logic
select * from rows from(getrngfunc1(1),getrngfunc2(1),getrngfunc3(1),getrngfunc4(1),getrngfunc5(1),
                    getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),
                    getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),
                    getrngfunc8(1),getrngfunc9(1))
              with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
 a | b |  c  | d | e |  f  | g | h |  i  | j | k |  l  | m | o |  p  | q | r | s |  t  | u 
---+---+-----+---+---+-----+---+---+-----+---+---+-----+---+---+-----+---+---+---+-----+---
 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | 1 | Joe | 1
   | 1 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |   |     | 2
(2 rows)

select * from rows from(getrngfunc9(1),getrngfunc8(1),
                    getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),
                    getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),
                    getrngfunc5(1),getrngfunc4(1),getrngfunc3(1),getrngfunc2(1),getrngfunc1(1))
              with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
 a | b |  c  | d | e | f |  g  | h | i |  j  | k | l |  m  | o | p |  q  |  r  | s | t | u 
---+---+-----+---+---+---+-----+---+---+-----+---+---+-----+---+---+-----+-----+---+---+---
 1 | 1 | Joe | 1 | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | Joe | 1 | 1 | 1
   |   |     |   | 1 | 2 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |     | Ed  | 1 |   | 2
(2 rows)

create temporary view vw_rngfunc as
  select * from rows from(getrngfunc9(1),
                      getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),
                      getrngfunc1(1))
                with ordinality as t1(a,b,c,d,e,f,g,n);
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from vw_rngfunc;
ERROR:  relation "vw_rngfunc" does not exist
LINE 1: select * from vw_rngfunc;
                      ^
select pg_get_viewdef('vw_rngfunc');
ERROR:  relation "vw_rngfunc" does not exist
drop view vw_rngfunc;
ERROR:  cannot execute DROP VIEW in a read-only transaction
DROP FUNCTION getrngfunc1(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc2(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc3(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc4(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc5(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc6(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc7(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc8(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION getrngfunc9(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION rngfunct(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP TABLE rngfunc2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE rngfunc;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Rescan tests --
CREATE TEMPORARY SEQUENCE rngfunc_rescan_seq1;
ERROR:  cannot execute CREATE SEQUENCE in a read-only transaction
CREATE TEMPORARY SEQUENCE rngfunc_rescan_seq2;
ERROR:  cannot execute CREATE SEQUENCE in a read-only transaction
CREATE TYPE rngfunc_rescan_t AS (i integer, s bigint);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
CREATE FUNCTION rngfunc_sql(int,int) RETURNS setof rngfunc_rescan_t AS 'SELECT i, nextval(''rngfunc_rescan_seq1'') FROM generate_series($1,$2) i;' LANGUAGE SQL;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
-- plpgsql functions use materialize mode
CREATE FUNCTION rngfunc_mat(int,int) RETURNS setof rngfunc_rescan_t AS 'begin for i in $1..$2 loop return next (i, nextval(''rngfunc_rescan_seq2'')); end loop; end;' LANGUAGE plpgsql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
--invokes ExecReScanFunctionScan - all these cases should materialize the function only once
-- LEFT JOIN on a condition that the planner can't prove to be true is used to ensure the function
-- is on the inner path of a nestloop join
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_sql(11,13) ON (r+i)<100;
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_sql(11,13) WITH ORDINALITY AS f(i,s,o) ON (r+i)<100;
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_mat(11,13) ON (r+i)<100;
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN rngfunc_mat(11,13) WITH ORDINALITY AS f(i,s,o) ON (r+i)<100;
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN ROWS FROM( rngfunc_sql(11,13), rngfunc_mat(11,13) ) WITH ORDINALITY AS f(i1,s1,i2,s2,o) ON (r+i1+i2)<100;
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN generate_series(11,13) f(i) ON (r+i)<100;
 r | i  
---+----
 1 | 11
 1 | 12
 1 | 13
 2 | 11
 2 | 12
 2 | 13
 3 | 11
 3 | 12
 3 | 13
(9 rows)

SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN generate_series(11,13) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
 r | i  | o 
---+----+---
 1 | 11 | 1
 1 | 12 | 2
 1 | 13 | 3
 2 | 11 | 1
 2 | 12 | 2
 2 | 13 | 3
 3 | 11 | 1
 3 | 12 | 2
 3 | 13 | 3
(9 rows)

SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) f(i) ON (r+i)<100;
 r | i  
---+----
 1 | 10
 1 | 20
 1 | 30
 2 | 10
 2 | 20
 2 | 30
 3 | 10
 3 | 20
 3 | 30
(9 rows)

SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
 r | i  | o 
---+----+---
 1 | 10 | 1
 1 | 20 | 2
 1 | 30 | 3
 2 | 10 | 1
 2 | 20 | 2
 2 | 30 | 3
 3 | 10 | 1
 3 | 20 | 2
 3 | 30 | 3
(9 rows)

--invokes ExecReScanFunctionScan with chgParam != NULL (using implied LATERAL)
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(10+r,13);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(10+r,13) WITH ORDINALITY AS f(i,s,o);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(11,10+r);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_sql(11,10+r) WITH ORDINALITY AS f(i,s,o);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_sql(r1,r2);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_sql(r1,r2) WITH ORDINALITY AS f(i,s,o);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(10+r,13);
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(10+r,13) WITH ORDINALITY AS f(i,s,o);
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(11,10+r);
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), rngfunc_mat(11,10+r) WITH ORDINALITY AS f(i,s,o);
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_mat(r1,r2);
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (11,12),(13,15),(16,20)) v(r1,r2), rngfunc_mat(r1,r2) WITH ORDINALITY AS f(i,s,o);
ERROR:  relation "rngfunc_rescan_seq2" does not exist
LINE 1: SELECT (i, nextval('rngfunc_rescan_seq2'))
                           ^
QUERY:  SELECT (i, nextval('rngfunc_rescan_seq2'))
CONTEXT:  PL/pgSQL function rngfunc_mat(integer,integer) line 1 at RETURN NEXT
-- selective rescan of multiple functions:
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(11,11), rngfunc_mat(10+r,13) );
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(10+r,13), rngfunc_mat(11,11) );
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(10+r,13), rngfunc_mat(10+r,13) );
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc_rescan_seq2',1,false);
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT setval('rngfunc_rescan_seq1',1,false),setval('rngfunc...
                      ^
SELECT * FROM generate_series(1,2) r1, generate_series(r1,3) r2, ROWS FROM( rngfunc_sql(10+r1,13), rngfunc_mat(10+r2,13) );
ERROR:  relation "rngfunc_rescan_seq1" does not exist
LINE 1: SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_serie...
                          ^
QUERY:  SELECT i, nextval('rngfunc_rescan_seq1') FROM generate_series($1,$2) i;
CONTEXT:  SQL function "rngfunc_sql" during startup
SELECT * FROM (VALUES (1),(2),(3)) v(r), generate_series(10+r,20-r) f(i);
 r | i  
---+----
 1 | 11
 1 | 12
 1 | 13
 1 | 14
 1 | 15
 1 | 16
 1 | 17
 1 | 18
 1 | 19
 2 | 12
 2 | 13
 2 | 14
 2 | 15
 2 | 16
 2 | 17
 2 | 18
 3 | 13
 3 | 14
 3 | 15
 3 | 16
 3 | 17
(21 rows)

SELECT * FROM (VALUES (1),(2),(3)) v(r), generate_series(10+r,20-r) WITH ORDINALITY AS f(i,o);
 r | i  | o 
---+----+---
 1 | 11 | 1
 1 | 12 | 2
 1 | 13 | 3
 1 | 14 | 4
 1 | 15 | 5
 1 | 16 | 6
 1 | 17 | 7
 1 | 18 | 8
 1 | 19 | 9
 2 | 12 | 1
 2 | 13 | 2
 2 | 14 | 3
 2 | 15 | 4
 2 | 16 | 5
 2 | 17 | 6
 2 | 18 | 7
 3 | 13 | 1
 3 | 14 | 2
 3 | 15 | 3
 3 | 16 | 4
 3 | 17 | 5
(21 rows)

SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) f(i);
 r | i  
---+----
 1 | 10
 1 | 20
 1 | 30
 2 | 20
 2 | 40
 2 | 60
 3 | 30
 3 | 60
 3 | 90
(9 rows)

SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) WITH ORDINALITY AS f(i,o);
 r | i  | o 
---+----+---
 1 | 10 | 1
 1 | 20 | 2
 1 | 30 | 3
 2 | 20 | 1
 2 | 40 | 2
 2 | 60 | 3
 3 | 30 | 1
 3 | 60 | 2
 3 | 90 | 3
(9 rows)

-- deep nesting
SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
                                         LEFT JOIN generate_series(21,23) f(i) ON ((r2+i)<100) OFFSET 0) s1;
 r1 | r1 | r2 | i  
----+----+----+----
  1 |  1 | 10 | 21
  1 |  1 | 10 | 22
  1 |  1 | 10 | 23
  1 |  1 | 20 | 21
  1 |  1 | 20 | 22
  1 |  1 | 20 | 23
  1 |  1 | 30 | 21
  1 |  1 | 30 | 22
  1 |  1 | 30 | 23
  2 |  2 | 10 | 21
  2 |  2 | 10 | 22
  2 |  2 | 10 | 23
  2 |  2 | 20 | 21
  2 |  2 | 20 | 22
  2 |  2 | 20 | 23
  2 |  2 | 30 | 21
  2 |  2 | 30 | 22
  2 |  2 | 30 | 23
  3 |  3 | 10 | 21
  3 |  3 | 10 | 22
  3 |  3 | 10 | 23
  3 |  3 | 20 | 21
  3 |  3 | 20 | 22
  3 |  3 | 20 | 23
  3 |  3 | 30 | 21
  3 |  3 | 30 | 22
  3 |  3 | 30 | 23
(27 rows)

SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
                                         LEFT JOIN generate_series(20+r1,23) f(i) ON ((r2+i)<100) OFFSET 0) s1;
 r1 | r1 | r2 | i  
----+----+----+----
  1 |  1 | 10 | 21
  1 |  1 | 10 | 22
  1 |  1 | 10 | 23
  1 |  1 | 20 | 21
  1 |  1 | 20 | 22
  1 |  1 | 20 | 23
  1 |  1 | 30 | 21
  1 |  1 | 30 | 22
  1 |  1 | 30 | 23
  2 |  2 | 10 | 22
  2 |  2 | 10 | 23
  2 |  2 | 20 | 22
  2 |  2 | 20 | 23
  2 |  2 | 30 | 22
  2 |  2 | 30 | 23
  3 |  3 | 10 | 23
  3 |  3 | 20 | 23
  3 |  3 | 30 | 23
(18 rows)

SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
                                         LEFT JOIN generate_series(r2,r2+3) f(i) ON ((r2+i)<100) OFFSET 0) s1;
 r1 | r1 | r2 | i  
----+----+----+----
  1 |  1 | 10 | 10
  1 |  1 | 10 | 11
  1 |  1 | 10 | 12
  1 |  1 | 10 | 13
  1 |  1 | 20 | 20
  1 |  1 | 20 | 21
  1 |  1 | 20 | 22
  1 |  1 | 20 | 23
  1 |  1 | 30 | 30
  1 |  1 | 30 | 31
  1 |  1 | 30 | 32
  1 |  1 | 30 | 33
  2 |  2 | 10 | 10
  2 |  2 | 10 | 11
  2 |  2 | 10 | 12
  2 |  2 | 10 | 13
  2 |  2 | 20 | 20
  2 |  2 | 20 | 21
  2 |  2 | 20 | 22
  2 |  2 | 20 | 23
  2 |  2 | 30 | 30
  2 |  2 | 30 | 31
  2 |  2 | 30 | 32
  2 |  2 | 30 | 33
  3 |  3 | 10 | 10
  3 |  3 | 10 | 11
  3 |  3 | 10 | 12
  3 |  3 | 10 | 13
  3 |  3 | 20 | 20
  3 |  3 | 20 | 21
  3 |  3 | 20 | 22
  3 |  3 | 20 | 23
  3 |  3 | 30 | 30
  3 |  3 | 30 | 31
  3 |  3 | 30 | 32
  3 |  3 | 30 | 33
(36 rows)

SELECT * FROM (VALUES (1),(2),(3)) v1(r1),
              LATERAL (SELECT r1, * FROM (VALUES (10),(20),(30)) v2(r2)
                                         LEFT JOIN generate_series(r1,2+r2/5) f(i) ON ((r2+i)<100) OFFSET 0) s1;
 r1 | r1 | r2 | i 
----+----+----+---
  1 |  1 | 10 | 1
  1 |  1 | 10 | 2
  1 |  1 | 10 | 3
  1 |  1 | 10 | 4
  1 |  1 | 20 | 1
  1 |  1 | 20 | 2
  1 |  1 | 20 | 3
  1 |  1 | 20 | 4
  1 |  1 | 20 | 5
  1 |  1 | 20 | 6
  1 |  1 | 30 | 1
  1 |  1 | 30 | 2
  1 |  1 | 30 | 3
  1 |  1 | 30 | 4
  1 |  1 | 30 | 5
  1 |  1 | 30 | 6
  1 |  1 | 30 | 7
  1 |  1 | 30 | 8
  2 |  2 | 10 | 2
  2 |  2 | 10 | 3
  2 |  2 | 10 | 4
  2 |  2 | 20 | 2
  2 |  2 | 20 | 3
  2 |  2 | 20 | 4
  2 |  2 | 20 | 5
  2 |  2 | 20 | 6
  2 |  2 | 30 | 2
  2 |  2 | 30 | 3
  2 |  2 | 30 | 4
  2 |  2 | 30 | 5
  2 |  2 | 30 | 6
  2 |  2 | 30 | 7
  2 |  2 | 30 | 8
  3 |  3 | 10 | 3
  3 |  3 | 10 | 4
  3 |  3 | 20 | 3
  3 |  3 | 20 | 4
  3 |  3 | 20 | 5
  3 |  3 | 20 | 6
  3 |  3 | 30 | 3
  3 |  3 | 30 | 4
  3 |  3 | 30 | 5
  3 |  3 | 30 | 6
  3 |  3 | 30 | 7
  3 |  3 | 30 | 8
(45 rows)

DROP FUNCTION rngfunc_sql(int,int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION rngfunc_mat(int,int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP SEQUENCE rngfunc_rescan_seq1;
ERROR:  cannot execute DROP SEQUENCE in a read-only transaction
DROP SEQUENCE rngfunc_rescan_seq2;
ERROR:  cannot execute DROP SEQUENCE in a read-only transaction
--
-- Test cases involving OUT parameters
--
CREATE FUNCTION rngfunc(in f1 int, out f2 int)
AS 'select $1+1' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT rngfunc(42);
 rngfunc 
---------
      43
(1 row)

SELECT * FROM rngfunc(42);
 f2 
----
 43
(1 row)

SELECT * FROM rngfunc(42) AS p(x);
 x  
----
 43
(1 row)

-- explicit spec of return type is OK
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int) RETURNS int
AS 'select $1+1' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
-- error, wrong result type
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int) RETURNS float
AS 'select $1+1' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
-- with multiple OUT params you must get a RECORD result
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int, out f3 text) RETURNS int
AS 'select $1+1' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int, out f3 text)
RETURNS record
AS 'select $1+1' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
CREATE OR REPLACE FUNCTION rngfuncr(in f1 int, out f2 int, out text)
AS $$select $1-1, $1::text || 'z'$$ LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT f1, rngfuncr(f1) FROM int4_tbl;
     f1      |          rngfuncr          
-------------+----------------------------
           0 | (-1,0z)
      123456 | (123455,123456z)
     -123456 | (-123457,-123456z)
  2147483647 | (2147483646,2147483647z)
 -2147483647 | (-2147483648,-2147483647z)
(5 rows)

SELECT * FROM rngfuncr(42);
 f2 | column2 
----+---------
 41 | 42z
(1 row)

SELECT * FROM rngfuncr(42) AS p(a,b);
 a  |  b  
----+-----
 41 | 42z
(1 row)

CREATE OR REPLACE FUNCTION rngfuncb(in f1 int, inout f2 int, out text)
AS $$select $2-1, $1::text || 'z'$$ LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT f1, rngfuncb(f1, f1/2) FROM int4_tbl;
     f1      |          rngfuncb          
-------------+----------------------------
           0 | (-1,0z)
      123456 | (61727,123456z)
     -123456 | (-61729,-123456z)
  2147483647 | (1073741822,2147483647z)
 -2147483647 | (-1073741824,-2147483647z)
(5 rows)

SELECT * FROM rngfuncb(42, 99);
 f2 | column2 
----+---------
 98 | 42z
(1 row)

SELECT * FROM rngfuncb(42, 99) AS p(a,b);
 a  |  b  
----+-----
 98 | 42z
(1 row)

-- Can reference function with or without OUT params for DROP, etc
DROP FUNCTION rngfunc(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION rngfuncr(in f2 int, out f1 int, out text);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
DROP FUNCTION rngfuncb(in f1 int, inout f2 int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
--
-- For my next trick, polymorphic OUT parameters
--
CREATE FUNCTION dup (f1 anyelement, f2 out anyelement, f3 out anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT dup(22);
      dup       
----------------
 (22,"{22,22}")
(1 row)

SELECT dup('xyz');	-- fails
ERROR:  could not determine polymorphic type because input has type unknown
SELECT dup('xyz'::text);
        dup        
-------------------
 (xyz,"{xyz,xyz}")
(1 row)

SELECT * FROM dup('xyz'::text);
 f2  |    f3     
-----+-----------
 xyz | {xyz,xyz}
(1 row)

-- fails, as we are attempting to rename first argument
CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
DROP FUNCTION dup(anyelement);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- equivalent behavior, though different name exposed for input arg
CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT dup(22);
      dup       
----------------
 (22,"{22,22}")
(1 row)

DROP FUNCTION dup(anyelement);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- fails, no way to deduce outputs
CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
--
-- table functions
--
CREATE OR REPLACE FUNCTION rngfunc()
RETURNS TABLE(a int)
AS $$ SELECT a FROM generate_series(1,5) a(a) $$ LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM rngfunc();
 a 
---
 1
 2
 3
 4
 5
(5 rows)

DROP FUNCTION rngfunc();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
CREATE OR REPLACE FUNCTION rngfunc(int)
RETURNS TABLE(a int, b int)
AS $$ SELECT a, b
         FROM generate_series(1,$1) a(a),
              generate_series(1,$1) b(b) $$ LANGUAGE sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM rngfunc(3);
 a | b 
---+---
 1 | 1
 1 | 2
 1 | 3
 2 | 1
 2 | 2
 2 | 3
 3 | 1
 3 | 2
 3 | 3
(9 rows)

DROP FUNCTION rngfunc(int);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- case that causes change of typmod knowledge during inlining
CREATE OR REPLACE FUNCTION rngfunc()
RETURNS TABLE(a varchar(5))
AS $$ SELECT 'hello'::varchar(5) $$ LANGUAGE sql STABLE;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT * FROM rngfunc() GROUP BY 1;
   a   
-------
 hello
(1 row)

DROP FUNCTION rngfunc();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
--
-- some tests on SQL functions with RETURNING
--
create temp table tt(f1 serial, data text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create function insert_tt(text) returns int as
$$ insert into tt(data) values($1) returning f1 $$
language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select insert_tt('foo');
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1) returning f1 
                     ^
QUERY:   insert into tt(data) values($1) returning f1 
CONTEXT:  SQL function "insert_tt" during inlining
select insert_tt('bar');
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1) returning f1 
                     ^
QUERY:   insert into tt(data) values($1) returning f1 
CONTEXT:  SQL function "insert_tt" during inlining
select * from tt;
ERROR:  relation "tt" does not exist
LINE 1: select * from tt;
                      ^
-- insert will execute to completion even if function needs just 1 row
create or replace function insert_tt(text) returns int as
$$ insert into tt(data) values($1),($1||$1) returning f1 $$
language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select insert_tt('fool');
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1),($1||$1) returning f1 
                     ^
QUERY:   insert into tt(data) values($1),($1||$1) returning f1 
CONTEXT:  SQL function "insert_tt" during inlining
select * from tt;
ERROR:  relation "tt" does not exist
LINE 1: select * from tt;
                      ^
-- setof does what's expected
create or replace function insert_tt2(text,text) returns setof int as
$$ insert into tt(data) values($1),($2) returning f1 $$
language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select insert_tt2('foolish','barrish');
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1),($2) returning f1 
                     ^
QUERY:   insert into tt(data) values($1),($2) returning f1 
CONTEXT:  SQL function "insert_tt2" during startup
select * from insert_tt2('baz','quux');
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1),($2) returning f1 
                     ^
QUERY:   insert into tt(data) values($1),($2) returning f1 
CONTEXT:  SQL function "insert_tt2" during startup
select * from tt;
ERROR:  relation "tt" does not exist
LINE 1: select * from tt;
                      ^
-- limit doesn't prevent execution to completion
select insert_tt2('foolish','barrish') limit 1;
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1),($2) returning f1 
                     ^
QUERY:   insert into tt(data) values($1),($2) returning f1 
CONTEXT:  SQL function "insert_tt2" during startup
select * from tt;
ERROR:  relation "tt" does not exist
LINE 1: select * from tt;
                      ^
-- triggers will fire, too
create function noticetrigger() returns trigger as $$
begin
  raise notice 'noticetrigger % %', new.f1, new.data;
  return null;
end $$ language plpgsql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
create trigger tnoticetrigger after insert on tt for each row
execute procedure noticetrigger();
ERROR:  cannot execute CREATE TRIGGER in a read-only transaction
select insert_tt2('foolme','barme') limit 1;
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1),($2) returning f1 
                     ^
QUERY:   insert into tt(data) values($1),($2) returning f1 
CONTEXT:  SQL function "insert_tt2" during startup
select * from tt;
ERROR:  relation "tt" does not exist
LINE 1: select * from tt;
                      ^
-- and rules work
create temp table tt_log(f1 int, data text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create rule insert_tt_rule as on insert to tt do also
  insert into tt_log values(new.*);
ERROR:  cannot execute CREATE RULE in a read-only transaction
select insert_tt2('foollog','barlog') limit 1;
ERROR:  relation "tt" does not exist
LINE 1:  insert into tt(data) values($1),($2) returning f1 
                     ^
QUERY:   insert into tt(data) values($1),($2) returning f1 
CONTEXT:  SQL function "insert_tt2" during startup
select * from tt;
ERROR:  relation "tt" does not exist
LINE 1: select * from tt;
                      ^
-- note that nextval() gets executed a second time in the rule expansion,
-- which is expected.
select * from tt_log;
ERROR:  relation "tt_log" does not exist
LINE 1: select * from tt_log;
                      ^
-- test case for a whole-row-variable bug
create function rngfunc1(n integer, out a text, out b text)
  returns setof record
  language sql
  as $$ select 'foo ' || i, 'bar ' || i from generate_series(1,$1) i $$;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
set work_mem='64kB';
select t.a, t, t.a from rngfunc1(10000) t limit 1;
   a   |         t         |   a   
-------+-------------------+-------
 foo 1 | ("foo 1","bar 1") | foo 1
(1 row)

reset work_mem;
select t.a, t, t.a from rngfunc1(10000) t limit 1;
   a   |         t         |   a   
-------+-------------------+-------
 foo 1 | ("foo 1","bar 1") | foo 1
(1 row)

drop function rngfunc1(n integer);
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- test use of SQL functions returning record
-- this is supported in some cases where the query doesn't specify
-- the actual record type ...
create function array_to_set(anyarray) returns setof record as $$
  select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i
$$ language sql strict immutable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select array_to_set(array['one', 'two']);
 array_to_set 
--------------
 (1,one)
 (2,two)
(2 rows)

select * from array_to_set(array['one', 'two']) as t(f1 int,f2 text);
 f1 | f2  
----+-----
  1 | one
  2 | two
(2 rows)

select * from array_to_set(array['one', 'two']); -- fail
ERROR:  a column definition list is required for functions returning "record"
LINE 1: select * from array_to_set(array['one', 'two']);
                      ^
create temp table rngfunc(f1 int8, f2 int8);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create function testrngfunc() returns record as $$
  insert into rngfunc values (1,2) returning *;
$$ language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select testrngfunc();
ERROR:  relation "rngfunc" does not exist
LINE 2:   insert into rngfunc values (1,2) returning *;
                      ^
QUERY:  
  insert into rngfunc values (1,2) returning *;

CONTEXT:  SQL function "testrngfunc" during startup
select * from testrngfunc() as t(f1 int8,f2 int8);
ERROR:  relation "rngfunc" does not exist
LINE 2:   insert into rngfunc values (1,2) returning *;
                      ^
QUERY:  
  insert into rngfunc values (1,2) returning *;

CONTEXT:  SQL function "testrngfunc" during startup
select * from testrngfunc(); -- fail
ERROR:  a column definition list is required for functions returning "record"
LINE 1: select * from testrngfunc();
                      ^
drop function testrngfunc();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
create function testrngfunc() returns setof record as $$
  insert into rngfunc values (1,2), (3,4) returning *;
$$ language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select testrngfunc();
ERROR:  relation "rngfunc" does not exist
LINE 2:   insert into rngfunc values (1,2), (3,4) returning *;
                      ^
QUERY:  
  insert into rngfunc values (1,2), (3,4) returning *;

CONTEXT:  SQL function "testrngfunc" during startup
select * from testrngfunc() as t(f1 int8,f2 int8);
ERROR:  relation "rngfunc" does not exist
LINE 2:   insert into rngfunc values (1,2), (3,4) returning *;
                      ^
QUERY:  
  insert into rngfunc values (1,2), (3,4) returning *;

CONTEXT:  SQL function "testrngfunc" during startup
select * from testrngfunc(); -- fail
ERROR:  a column definition list is required for functions returning "record"
LINE 1: select * from testrngfunc();
                      ^
drop function testrngfunc();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
--
-- Check some cases involving added/dropped columns in a rowtype result
--
create temp table users (userid text, seq int, email text, todrop bool, moredrop int, enabled bool);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into users values ('id',1,'email',true,11,true);
ERROR:  relation "users" does not exist
LINE 1: insert into users values ('id',1,'email',true,11,true);
                    ^
insert into users values ('id2',2,'email2',true,12,true);
ERROR:  relation "users" does not exist
LINE 1: insert into users values ('id2',2,'email2',true,12,true);
                    ^
alter table users drop column todrop;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create or replace function get_first_user() returns users as
$$ SELECT * FROM users ORDER BY userid LIMIT 1; $$
language sql stable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT get_first_user();
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid LIMIT 1; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid LIMIT 1; 
CONTEXT:  SQL function "get_first_user" during inlining
SELECT * FROM get_first_user();
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid LIMIT 1; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid LIMIT 1; 
CONTEXT:  SQL function "get_first_user" during inlining
create or replace function get_users() returns setof users as
$$ SELECT * FROM users ORDER BY userid; $$
language sql stable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
SELECT get_users();
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid; 
CONTEXT:  SQL function "get_users" during startup
SELECT * FROM get_users();
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid; 
CONTEXT:  SQL function "get_users" during inlining
SELECT * FROM get_users() WITH ORDINALITY;   -- make sure ordinality copes
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid; 
CONTEXT:  SQL function "get_users" during startup
-- multiple functions vs. dropped columns
SELECT * FROM ROWS FROM(generate_series(10,11), get_users()) WITH ORDINALITY;
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid; 
CONTEXT:  SQL function "get_users" during startup
SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
ERROR:  relation "users" does not exist
LINE 1:  SELECT * FROM users ORDER BY userid; 
                       ^
QUERY:   SELECT * FROM users ORDER BY userid; 
CONTEXT:  SQL function "get_users" during startup
-- check that we can cope with post-parsing changes in rowtypes
create temp view usersview as
SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from usersview;
ERROR:  relation "usersview" does not exist
LINE 1: select * from usersview;
                      ^
alter table users add column junk text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from usersview;
ERROR:  relation "usersview" does not exist
LINE 1: select * from usersview;
                      ^
begin;
alter table users drop column moredrop;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from usersview;  -- expect clean failure
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
alter table users alter column seq type numeric;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from usersview;  -- expect clean failure
ERROR:  relation "usersview" does not exist
LINE 1: select * from usersview;
                      ^
drop view usersview;
ERROR:  cannot execute DROP VIEW in a read-only transaction
drop function get_first_user();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
drop function get_users();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
drop table users;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- this won't get inlined because of type coercion, but it shouldn't fail
create or replace function rngfuncbar() returns setof text as
$$ select 'foo'::varchar union all select 'bar'::varchar ; $$
language sql stable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select rngfuncbar();
 rngfuncbar 
------------
 foo
 bar
(2 rows)

select * from rngfuncbar();
 rngfuncbar 
------------
 foo
 bar
(2 rows)

drop function rngfuncbar();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- check handling of a SQL function with multiple OUT params (bug #5777)
create or replace function rngfuncbar(out integer, out numeric) as
$$ select (1, 2.1) $$ language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select * from rngfuncbar();
 column1 | column2 
---------+---------
       1 |     2.1
(1 row)

create or replace function rngfuncbar(out integer, out numeric) as
$$ select (1, 2) $$ language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select * from rngfuncbar();  -- fail
ERROR:  function return row and query-specified return row do not match
DETAIL:  Returned type integer at ordinal position 2, but query expects numeric.
create or replace function rngfuncbar(out integer, out numeric) as
$$ select (1, 2.1, 3) $$ language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select * from rngfuncbar();  -- fail
ERROR:  function return row and query-specified return row do not match
DETAIL:  Returned row contains 3 attributes, but query expects 2.
drop function rngfuncbar();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- check whole-row-Var handling in nested lateral functions (bug #11703)
create function extractq2(t int8_tbl) returns int8 as $$
  select t.q2
$$ language sql immutable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
explain (verbose, costs off)
select x from int8_tbl, extractq2(int8_tbl) f(x);
                QUERY PLAN                
------------------------------------------
 Nested Loop
   Output: f.x
   ->  Seq Scan on public.int8_tbl
         Output: int8_tbl.q1, int8_tbl.q2
   ->  Function Scan on f
         Output: f.x
         Function Call: int8_tbl.q2
(7 rows)

select x from int8_tbl, extractq2(int8_tbl) f(x);
         x         
-------------------
               456
  4567890123456789
               123
  4567890123456789
 -4567890123456789
(5 rows)

create function extractq2_2(t int8_tbl) returns table(ret1 int8) as $$
  select extractq2(t) offset 0
$$ language sql immutable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
explain (verbose, costs off)
select x from int8_tbl, extractq2_2(int8_tbl) f(x);
            QUERY PLAN             
-----------------------------------
 Nested Loop
   Output: ((int8_tbl.*).q2)
   ->  Seq Scan on public.int8_tbl
         Output: int8_tbl.*
   ->  Result
         Output: (int8_tbl.*).q2
(6 rows)

select x from int8_tbl, extractq2_2(int8_tbl) f(x);
         x         
-------------------
               456
  4567890123456789
               123
  4567890123456789
 -4567890123456789
(5 rows)

-- without the "offset 0", this function gets optimized quite differently
create function extractq2_2_opt(t int8_tbl) returns table(ret1 int8) as $$
  select extractq2(t)
$$ language sql immutable;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
explain (verbose, costs off)
select x from int8_tbl, extractq2_2_opt(int8_tbl) f(x);
         QUERY PLAN          
-----------------------------
 Seq Scan on public.int8_tbl
   Output: int8_tbl.q2
(2 rows)

select x from int8_tbl, extractq2_2_opt(int8_tbl) f(x);
         x         
-------------------
               456
  4567890123456789
               123
  4567890123456789
 -4567890123456789
(5 rows)

-- check handling of nulls in SRF results (bug #7808)
create type rngfunc2 as (a integer, b text);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
select *, row_to_json(u) from unnest(array[(1,'foo')::rngfunc2, null::rngfunc2]) u;
 a |  b  |     row_to_json     
---+-----+---------------------
 1 | foo | {"a":1,"b":"foo"}
   |     | {"a":null,"b":null}
(2 rows)

select *, row_to_json(u) from unnest(array[null::rngfunc2, null::rngfunc2]) u;
 a | b |     row_to_json     
---+---+---------------------
   |   | {"a":null,"b":null}
   |   | {"a":null,"b":null}
(2 rows)

select *, row_to_json(u) from unnest(array[null::rngfunc2, (1,'foo')::rngfunc2, null::rngfunc2]) u;
 a |  b  |     row_to_json     
---+-----+---------------------
   |     | {"a":null,"b":null}
 1 | foo | {"a":1,"b":"foo"}
   |     | {"a":null,"b":null}
(3 rows)

select *, row_to_json(u) from unnest(array[]::rngfunc2[]) u;
 a | b | row_to_json 
---+---+-------------
(0 rows)

drop type rngfunc2;
ERROR:  cannot execute DROP TYPE in a read-only transaction
