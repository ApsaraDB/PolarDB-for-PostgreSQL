--
-- ALTER_TABLE
--
-- Clean up in case a prior regression run failed
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_alter_table_user1;
ERROR:  cannot execute DROP ROLE in a read-only transaction
RESET client_min_messages;
CREATE USER regress_alter_table_user1;
ERROR:  cannot execute CREATE ROLE in a read-only transaction
--
-- add attribute
--
CREATE TABLE attmp (initial int4);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
COMMENT ON TABLE attmp_wrong IS 'table comment';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON TABLE attmp IS 'table comment';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON TABLE attmp IS NULL;
ERROR:  cannot execute COMMENT in a read-only transaction
ALTER TABLE attmp ADD COLUMN xmin integer; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN a int4 default 3;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN b name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN c text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN d float8;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN e float4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN f int2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN g polygon;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN h abstime;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN i char;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN j abstime[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN k int4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN l tid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN m xid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN n oidvector;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
--ALTER TABLE attmp ADD COLUMN o lock;
ALTER TABLE attmp ADD COLUMN p smgr;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN q point;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN r lseg;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN s path;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN t box;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN u tinterval;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN v timestamp;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN w interval;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN x float8[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN y float4[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN z int2[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
INSERT INTO attmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
ERROR:  cannot execute INSERT in a read-only transaction
SELECT * FROM attmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE attmp;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- the wolf bug - schema mods caused inconsistent row descriptors
CREATE TABLE attmp (
	initial 	int4
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN a int4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN b name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN c text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN d float8;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN e float4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN f int2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN g polygon;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN h abstime;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN i char;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN j abstime[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN k int4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN l tid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN m xid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN n oidvector;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
--ALTER TABLE attmp ADD COLUMN o lock;
ALTER TABLE attmp ADD COLUMN p smgr;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN q point;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN r lseg;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN s path;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN t box;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN u tinterval;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN v timestamp;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN w interval;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN x float8[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN y float4[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ADD COLUMN z int2[];
ERROR:  cannot execute ALTER TABLE in a read-only transaction
INSERT INTO attmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
ERROR:  cannot execute INSERT in a read-only transaction
SELECT * FROM attmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

CREATE INDEX attmp_idx ON attmp (a, (d + e), b);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
ERROR:  column number must be in range from 1 to 32767
LINE 1: ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
                                           ^
ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
\d+ attmp_idx
ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
DROP TABLE attmp;
ERROR:  cannot execute DROP TABLE in a read-only transaction
--
-- rename - check on both non-temp and temp tables
--
CREATE TABLE attmp (regtable int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TEMP TABLE attmp (attmptable int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE attmp RENAME TO attmp_new;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT * FROM attmp;
 regtable 
----------
(0 rows)

SELECT * FROM attmp_new;
ERROR:  relation "attmp_new" does not exist
LINE 1: SELECT * FROM attmp_new;
                      ^
ALTER TABLE attmp RENAME TO attmp_new2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT * FROM attmp;		-- should fail
ERROR:  relation "attmp" does not exist
LINE 1: SELECT * FROM attmp;
                      ^
SELECT * FROM attmp_new;
ERROR:  relation "attmp_new" does not exist
LINE 1: SELECT * FROM attmp_new;
                      ^
SELECT * FROM attmp_new2;
 regtable 
----------
(0 rows)

DROP TABLE attmp_new;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp_new2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check rename of partitioned tables and indexes also
CREATE TABLE part_attmp (a int primary key) partition by range (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER TABLE part_attmp RENAME TO part_at2tmp;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_attmp1 RENAME TO part_at2tmp1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SET ROLE regress_alter_table_user1;
ALTER INDEX part_attmp_index RENAME TO fail;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX part_attmp1_index RENAME TO fail;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER TABLE part_at2tmp RENAME TO fail;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_at2tmp1 RENAME TO fail;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
RESET ROLE;
DROP TABLE part_at2tmp;
ERROR:  cannot execute DROP TABLE in a read-only transaction
--
-- check renaming to a table's array type's autogenerated name
-- (the array type's name should get out of the way)
--
CREATE TABLE attmp_array (id int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE attmp_array2 (id int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
   typname    
--------------
 _attmp_array
(1 row)

SELECT typname FROM pg_type WHERE oid = 'attmp_array2[]'::regtype;
    typname    
---------------
 _attmp_array2
(1 row)

ALTER TABLE attmp_array2 RENAME TO _attmp_array;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
    typname    
---------------
 __attmp_array
(1 row)

SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
    typname     
----------------
 ___attmp_array
(1 row)

DROP TABLE _attmp_array;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp_array;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- renaming to table's own array type's name is an interesting corner case
CREATE TABLE attmp_array (id int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
   typname    
--------------
 _attmp_array
(1 row)

ALTER TABLE attmp_array RENAME TO _attmp_array;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
    typname    
---------------
 __attmp_array
(1 row)

DROP TABLE _attmp_array;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- ALTER TABLE ... RENAME on non-table relations
-- renaming indexes (FIXME: this should probably test the index's functionality)
ALTER INDEX IF EXISTS __onek_unique1 RENAME TO attmp_onek_unique1;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX IF EXISTS __attmp_onek_unique1 RENAME TO onek_unique1;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX onek_unique1 RENAME TO attmp_onek_unique1;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
SET ROLE regress_alter_table_user1;
ALTER INDEX onek_unique1 RENAME TO fail;  -- permission denied
ERROR:  cannot execute ALTER INDEX in a read-only transaction
RESET ROLE;
-- renaming views
CREATE VIEW attmp_view (unique1) AS SELECT unique1 FROM tenk1;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
ALTER TABLE attmp_view RENAME TO attmp_view_new;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SET ROLE regress_alter_table_user1;
ALTER VIEW attmp_view_new RENAME TO fail;  -- permission denied
ERROR:  cannot execute ALTER VIEW in a read-only transaction
RESET ROLE;
-- hack to ensure we get an indexscan here
set enable_seqscan to off;
set enable_bitmapscan to off;
-- 5 values, sorted
SELECT unique1 FROM tenk1 WHERE unique1 < 5;
 unique1 
---------
       0
       1
       2
       3
       4
(5 rows)

reset enable_seqscan;
reset enable_bitmapscan;
DROP VIEW attmp_view_new;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- toast-like relation name
alter table stud_emp rename to pg_toast_stud_emp;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table pg_toast_stud_emp rename to stud_emp;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- renaming index should rename constraint as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
ERROR:  cannot execute ALTER INDEX in a read-only transaction
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- renaming constraint
ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- renaming constraint should rename index as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP INDEX onek_unique1_constraint;  -- to see whether it's there
ERROR:  cannot execute DROP INDEX in a read-only transaction
ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
ERROR:  cannot execute DROP INDEX in a read-only transaction
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- renaming constraints vs. inheritance
CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
\d constraint_rename_test
CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
\d constraint_rename_test2
ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d constraint_rename_test
\d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d constraint_rename_test
\d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d constraint_rename_test
\d constraint_rename_test2
DROP TABLE constraint_rename_test2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE constraint_rename_test;
ERROR:  cannot execute DROP TABLE in a read-only transaction
ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo; -- ok
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- renaming constraints with cache reset of target relation
CREATE TABLE constraint_rename_cache (a int,
  CONSTRAINT chk_a CHECK (a > 0),
  PRIMARY KEY (a));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT chk_a TO chk_a_new;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE like_constraint_rename_cache
  (LIKE constraint_rename_cache INCLUDING ALL);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
\d like_constraint_rename_cache
DROP TABLE constraint_rename_cache;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE like_constraint_rename_cache;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- FOREIGN KEY CONSTRAINT adding TEST
CREATE TABLE attmp2 (a int primary key);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE attmp3 (a int, b int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE attmp4 (a int, b int, unique(a,b));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE attmp5 (a int, b int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- Insert rows into attmp2 (pktable)
INSERT INTO attmp2 values (1);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO attmp2 values (2);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO attmp2 values (3);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO attmp2 values (4);
ERROR:  cannot execute INSERT in a read-only transaction
-- Insert rows into attmp3
INSERT INTO attmp3 values (1,10);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO attmp3 values (1,20);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO attmp3 values (5,50);
ERROR:  cannot execute INSERT in a read-only transaction
-- Try (and fail) to add constraint due to invalid source columns
ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Try (and fail) to add constraint due to invalid destination columns explicitly given
ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Try (and fail) to add constraint due to invalid data
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Delete failing row
DELETE FROM attmp3 where a=5;
ERROR:  cannot execute DELETE in a read-only transaction
-- Try (and succeed)
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 drop constraint attmpconstr;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
INSERT INTO attmp3 values (5,50);
ERROR:  cannot execute INSERT in a read-only transaction
-- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full NOT VALID;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 validate constraint attmpconstr;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Delete failing row
DELETE FROM attmp3 where a=5;
ERROR:  cannot execute DELETE in a read-only transaction
-- Try (and succeed) and repeat to show it works on already valid constraint
ALTER TABLE attmp3 validate constraint attmpconstr;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 validate constraint attmpconstr;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Try a non-verified CHECK constraint
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DELETE FROM attmp3 WHERE NOT b > 10;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Test inherited NOT VALID CHECK constraints
select * from attmp3;
 a | b  
---+----
 1 | 20
(1 row)

CREATE TABLE attmp6 () INHERITS (attmp3);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE attmp7 () INHERITS (attmp3);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO attmp6 VALUES (6, 30), (7, 16);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE attmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DELETE FROM attmp6 WHERE b > 20;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- An already validated constraint must not be revalidated
CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
INSERT INTO attmp7 VALUES (8, 18);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE attmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp3 VALIDATE CONSTRAINT identity;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- A NO INHERIT constraint should not be looked for in children during VALIDATE CONSTRAINT
create table parent_noinh_convalid (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table child_noinh_convalid () inherits (parent_noinh_convalid);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into parent_noinh_convalid values (1);
ERROR:  cannot execute INSERT in a read-only transaction
insert into child_noinh_convalid values (1);
ERROR:  cannot execute INSERT in a read-only transaction
alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- fail, because of the row in parent
alter table parent_noinh_convalid validate constraint check_a_is_2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
delete from only parent_noinh_convalid;
ERROR:  cannot execute DELETE in a read-only transaction
-- ok (parent itself contains no violating rows)
alter table parent_noinh_convalid validate constraint check_a_is_2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select convalidated from pg_constraint where conrelid = 'parent_noinh_convalid'::regclass and conname = 'check_a_is_2';
 convalidated 
--------------
 t
(1 row)

-- cleanup
drop table parent_noinh_convalid, child_noinh_convalid;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Try (and fail) to create constraint from attmp5(a) to attmp4(a) - unique constraint on
-- attmp4 is a,b
ALTER TABLE attmp5 add constraint attmpconstr foreign key(a) references attmp4(a) match full;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE attmp7;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp6;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp5;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp4;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp3;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE attmp2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- NOT VALID with plan invalidation -- ensure we don't use a constraint for
-- exclusion until validated
set constraint_exclusion TO 'partition';
create table nv_parent (d date, check (false) no inherit not valid);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- not valid constraint added at creation time should automatically become valid
\d nv_parent
create table nv_child_2010 () inherits (nv_parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table nv_child_2011 () inherits (nv_parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
   ->  Seq Scan on nv_child_2011
         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
(7 rows)

create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
   ->  Seq Scan on nv_child_2011
         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
(7 rows)

explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
   ->  Seq Scan on nv_child_2011
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
   ->  Seq Scan on nv_child_2009
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
(9 rows)

-- after validation, the constraint should be used
alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
   ->  Seq Scan on nv_child_2009
         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
(7 rows)

-- add an inherited NOT VALID constraint
alter table nv_parent add check (d between '2001-01-01'::date and '2099-12-31'::date) not valid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d nv_child_2009
-- we leave nv_parent and children around to help test pg_dump logic
-- Foreign key adding test with mixed types
-- Note: these tables are TEMP to avoid name conflicts when this test
-- is run in parallel with foreign_key.sql.
CREATE TEMP TABLE PKTABLE (ptest1 int PRIMARY KEY);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO PKTABLE VALUES(42);
ERROR:  relation "pktable" does not exist
LINE 1: INSERT INTO PKTABLE VALUES(42);
                    ^
CREATE TEMP TABLE FKTABLE (ftest1 inet);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- This next should fail, because int=inet does not exist
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- This should also fail for the same reason, but here we
-- give the column name
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- This should succeed, even though they are different types,
-- because int=int8 exists and is a member of the integer opfamily
CREATE TEMP TABLE FKTABLE (ftest1 int8);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Check it actually works
INSERT INTO FKTABLE VALUES(42);		-- should succeed
ERROR:  relation "fktable" does not exist
LINE 1: INSERT INTO FKTABLE VALUES(42);
                    ^
INSERT INTO FKTABLE VALUES(43);		-- should fail
ERROR:  relation "fktable" does not exist
LINE 1: INSERT INTO FKTABLE VALUES(43);
                    ^
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- This should fail, because we'd have to cast numeric to int which is
-- not an implicit coercion (or use numeric=numeric, but that's not part
-- of the integer opfamily)
CREATE TEMP TABLE FKTABLE (ftest1 numeric);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE PKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- On the other hand, this should work because int implicitly promotes to
-- numeric, and we allow promotion on the FK side
CREATE TEMP TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO PKTABLE VALUES(42);
ERROR:  relation "pktable" does not exist
LINE 1: INSERT INTO PKTABLE VALUES(42);
                    ^
CREATE TEMP TABLE FKTABLE (ftest1 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Check it actually works
INSERT INTO FKTABLE VALUES(42);		-- should succeed
ERROR:  relation "fktable" does not exist
LINE 1: INSERT INTO FKTABLE VALUES(42);
                    ^
INSERT INTO FKTABLE VALUES(43);		-- should fail
ERROR:  relation "fktable" does not exist
LINE 1: INSERT INTO FKTABLE VALUES(43);
                    ^
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE PKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
                           PRIMARY KEY(ptest1, ptest2));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- This should fail, because we just chose really odd types
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Again, so should this...
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest1, ptest2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- This fails because we mixed up the column ordering
CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest2, ptest1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- As does this...
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
     references pktable(ptest1, ptest2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE FKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE PKTABLE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Test that ALTER CONSTRAINT updates trigger deferrability properly
CREATE TEMP TABLE PKTABLE (ptest1 int primary key);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TEMP TABLE FKTABLE (ftest1 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
WHERE tgrelid = 'pktable'::regclass
ORDER BY 1,2,3;
ERROR:  relation "pktable" does not exist
LINE 3: WHERE tgrelid = 'pktable'::regclass
                        ^
SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
WHERE tgrelid = 'fktable'::regclass
ORDER BY 1,2,3;
ERROR:  relation "fktable" does not exist
LINE 3: WHERE tgrelid = 'fktable'::regclass
                        ^
-- temp tables should go away by themselves, need not drop them.
-- test check constraint adding
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a check constraint
alter table atacc1 add constraint atacc_test1 check (test>3);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should fail
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- should succeed
insert into atacc1 (test) values (4);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do one where the check fails when added
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- insert a soon to be failing row
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test>3);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into atacc1 (test) values (4);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do one where the check fails because the column doesn't exist
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test1>3);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- something a little more complicated
create table atacc1 ( test int, test2 int, test3 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should fail
insert into atacc1 (test,test2,test3) values (4,4,2);
ERROR:  cannot execute INSERT in a read-only transaction
-- should succeed
insert into atacc1 (test,test2,test3) values (4,4,5);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- lets do some naming tests
create table atacc1 (test int check (test>3), test2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table atacc1 add check (test2>test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should fail for $2
insert into atacc1 (test2, test) values (3, 4);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- inheritance related tests
create table atacc1 (test int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table atacc2 (test2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table atacc3 (test3 int) inherits (atacc1, atacc2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table atacc2 add constraint foo check (test2>0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- fail and then succeed on atacc2
insert into atacc2 (test2) values (-3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc2 (test2) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
-- fail and then succeed on atacc3
insert into atacc3 (test2) values (-3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc3 (test2) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc3;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table atacc2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- same things with one created with INHERIT
create table atacc1 (test int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table atacc2 (test2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table atacc3 (test3 int) inherits (atacc1, atacc2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table atacc3 no inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- fail
alter table atacc3 no inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- make sure it really isn't a child
insert into atacc3 (test2) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
select test2 from atacc2;
 test2 
-------
(0 rows)

-- fail due to missing constraint
alter table atacc2 add constraint foo check (test2>0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc3 inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- fail due to missing column
alter table atacc3 rename test2 to testx;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc3 inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- fail due to mismatched data type
alter table atacc3 add test2 bool;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc3 inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc3 drop test2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- succeed
alter table atacc3 add test2 int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
update atacc3 set test2 = 4 where test2 is null;
ERROR:  cannot execute UPDATE in a read-only transaction
alter table atacc3 add constraint foo check (test2>0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc3 inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- fail due to duplicates and circular inheritance
alter table atacc3 inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc2 inherit atacc3;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc2 inherit atacc2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- test that we really are a child now (should see 4 not 3 and cascade should go through)
select test2 from atacc2;
 test2 
-------
     4
(1 row)

drop table atacc2 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- adding only to a parent is allowed as of 9.2
create table atacc1 (test int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table atacc2 (test2 int) inherits (atacc1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- ok:
alter table atacc1 add constraint foo check (test>0) no inherit;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check constraint is not there on child
insert into atacc2 (test) values (-3);
ERROR:  cannot execute INSERT in a read-only transaction
-- check constraint is there on parent
insert into atacc1 (test) values (-3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
-- fail, violating row:
alter table atacc2 add constraint foo check (test>0) no inherit;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test unique constraint adding
create table atacc1 ( test int ) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- insert first value
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- should fail
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- should succeed
insert into atacc1 (test) values (4);
ERROR:  cannot execute INSERT in a read-only transaction
-- try adding a unique oid constraint
alter table atacc1 add constraint atacc_oid1 unique(oid);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try to create duplicates via alter table using - should fail
alter table atacc1 alter column test type integer using 0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do one where the unique constraint fails when added
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- insert soon to be failing rows
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into atacc1 (test) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do one where the unique constraint fails
-- because the column doesn't exist
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- something a little more complicated
create table atacc1 ( test int, test2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test, test2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- insert initial value
insert into atacc1 (test,test2) values (4,4);
ERROR:  cannot execute INSERT in a read-only transaction
-- should fail
insert into atacc1 (test,test2) values (4,4);
ERROR:  cannot execute INSERT in a read-only transaction
-- should all succeed
insert into atacc1 (test,test2) values (4,5);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (5,4);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (5,5);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- lets do some naming tests
create table atacc1 (test int, test2 int, unique(test));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table atacc1 add unique (test2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should fail for @@ second one @@
insert into atacc1 (test2, test) values (3, 3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test2, test) values (2, 3);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test primary key constraint adding
create table atacc1 ( test int ) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- insert first value
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- should fail
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- should succeed
insert into atacc1 (test) values (4);
ERROR:  cannot execute INSERT in a read-only transaction
-- inserting NULL should fail
insert into atacc1 (test) values(NULL);
ERROR:  cannot execute INSERT in a read-only transaction
-- try adding a second primary key (should fail)
alter table atacc1 add constraint atacc_oid1 primary key(oid);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- drop first primary key constraint
alter table atacc1 drop constraint atacc_test1 restrict;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try adding a primary key on oid (should succeed)
alter table atacc1 add constraint atacc_oid1 primary key(oid);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do one where the primary key constraint fails when added
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- insert soon to be failing rows
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test) values (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into atacc1 (test) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do another one where the primary key constraint fails when added
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- insert soon to be failing row
insert into atacc1 (test) values (NULL);
ERROR:  cannot execute INSERT in a read-only transaction
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into atacc1 (test) values (3);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- let's do one where the primary key constraint fails
-- because the column doesn't exist
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a primary key constraint (fails)
alter table atacc1 add constraint atacc_test1 primary key (test1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- adding a new column as primary key to a non-empty table.
-- should fail unless the column has a non-null default value.
create table atacc1 ( test int );
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into atacc1 (test) values (0);
ERROR:  cannot execute INSERT in a read-only transaction
-- add a primary key column without a default (fails).
alter table atacc1 add column test2 int primary key;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- now add a primary key column with a default (succeeds).
alter table atacc1 add column test2 int default 0 primary key;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- something a little more complicated
create table atacc1 ( test int, test2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test, test2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try adding a second primary key - should fail
alter table atacc1 add constraint atacc_test2 primary key (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- insert initial value
insert into atacc1 (test,test2) values (4,4);
ERROR:  cannot execute INSERT in a read-only transaction
-- should fail
insert into atacc1 (test,test2) values (4,4);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (NULL,3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (3, NULL);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (NULL,NULL);
ERROR:  cannot execute INSERT in a read-only transaction
-- should all succeed
insert into atacc1 (test,test2) values (4,5);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (5,4);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test,test2) values (5,5);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- lets do some naming tests
create table atacc1 (test int, test2 int, primary key(test));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- only first should succeed
insert into atacc1 (test2, test) values (3, 3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test2, test) values (2, 3);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (test2, test) values (1, NULL);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- alter table / alter column [set/drop] not null tests
-- try altering system catalogs, should fail
alter table pg_class alter column relname drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table pg_class alter relname set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try altering non-existent table, should fail
alter table non_existent alter column bar set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table non_existent alter column bar drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- test setting columns to null and not null and vice versa
-- test checking for null values and primary key
create table atacc1 (test int not null) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table atacc1 add constraint "atacc1_pkey" primary key (test);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter column test drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 drop constraint "atacc1_pkey";
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter column test drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into atacc1 values (null);
ERROR:  cannot execute INSERT in a read-only transaction
alter table atacc1 alter test set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
delete from atacc1;
ERROR:  cannot execute DELETE in a read-only transaction
alter table atacc1 alter test set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try altering a non-existent column, should fail
alter table atacc1 alter bar set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter bar drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try altering the oid column, should fail
alter table atacc1 alter oid set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter oid drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
alter table myview alter column test drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table myview alter column test set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop view myview;
ERROR:  cannot execute DROP VIEW in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test inheritance
create table parent (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table child (b varchar(255)) inherits (parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table parent alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into parent values (NULL);
ERROR:  cannot execute INSERT in a read-only transaction
insert into child (a, b) values (NULL, 'foo');
ERROR:  cannot execute INSERT in a read-only transaction
alter table parent alter a drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into parent values (NULL);
ERROR:  cannot execute INSERT in a read-only transaction
insert into child (a, b) values (NULL, 'foo');
ERROR:  cannot execute INSERT in a read-only transaction
alter table only parent alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table child alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
delete from parent;
ERROR:  cannot execute DELETE in a read-only transaction
alter table only parent alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into parent values (NULL);
ERROR:  cannot execute INSERT in a read-only transaction
alter table child alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into child (a, b) values (NULL, 'foo');
ERROR:  cannot execute INSERT in a read-only transaction
delete from child;
ERROR:  cannot execute DELETE in a read-only transaction
alter table child alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into child (a, b) values (NULL, 'foo');
ERROR:  cannot execute INSERT in a read-only transaction
drop table child;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table parent;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test setting and removing default values
create table def_test (
	c1	int4 default 5,
	c2	text default 'initial_default'
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into def_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
alter table def_test alter column c1 drop default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into def_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
alter table def_test alter column c2 drop default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into def_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
alter table def_test alter column c1 set default 10;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table def_test alter column c2 set default 'new_default';
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into def_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
select * from def_test;
 c1 |       c2        
----+-----------------
  5 | initial_default
    | initial_default
    | 
 10 | new_default
(4 rows)

-- set defaults to an incorrect type: this should fail
alter table def_test alter column c1 set default 'wrong_datatype';
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table def_test alter column c2 set default 20;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- set defaults on a non-existent column: this should fail
alter table def_test alter column c3 set default 30;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- set defaults on views: we need to create a view, add a rule
-- to allow insertions into it, and then alter the view to add
-- a default
create view def_view_test as select * from def_test;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
create rule def_view_test_ins as
	on insert to def_view_test
	do instead insert into def_test select new.*;
ERROR:  cannot execute CREATE RULE in a read-only transaction
insert into def_view_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
alter table def_view_test alter column c1 set default 45;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into def_view_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
alter table def_view_test alter column c2 set default 'view_default';
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into def_view_test default values;
ERROR:  cannot execute INSERT in a read-only transaction
select * from def_view_test;
 c1 |       c2        
----+-----------------
  5 | initial_default
    | initial_default
    | 
 10 | new_default
    | 
 45 | 
 45 | view_default
(7 rows)

drop rule def_view_test_ins on def_view_test;
ERROR:  cannot execute DROP RULE in a read-only transaction
drop view def_view_test;
ERROR:  cannot execute DROP VIEW in a read-only transaction
drop table def_test;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- alter table / drop column tests
-- try altering system catalogs, should fail
alter table pg_class drop column relname;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try altering non-existent table, should fail
alter table nosuchtable drop column bar;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- test dropping columns
create table atacc1 (a int4 not null, b int4, c int4 not null, d int4) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into atacc1 values (1, 2, 3, 4);
ERROR:  cannot execute INSERT in a read-only transaction
alter table atacc1 drop a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 drop a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- SELECTs
select * from atacc1;
 b | c | d 
---+---+---
 2 | 3 | 4
(1 row)

select * from atacc1 order by a;
ERROR:  column "a" does not exist
LINE 1: select * from atacc1 order by a;
                                      ^
select * from atacc1 order by "........pg.dropped.1........";
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
                                      ^
select * from atacc1 group by a;
ERROR:  column "a" does not exist
LINE 1: select * from atacc1 group by a;
                                      ^
select * from atacc1 group by "........pg.dropped.1........";
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
                                      ^
select atacc1.* from atacc1;
 b | c | d 
---+---+---
 2 | 3 | 4
(1 row)

select a from atacc1;
ERROR:  column "a" does not exist
LINE 1: select a from atacc1;
               ^
select atacc1.a from atacc1;
ERROR:  column atacc1.a does not exist
LINE 1: select atacc1.a from atacc1;
               ^
select b,c,d from atacc1;
 b | c | d 
---+---+---
 2 | 3 | 4
(1 row)

select a,b,c,d from atacc1;
ERROR:  column "a" does not exist
LINE 1: select a,b,c,d from atacc1;
               ^
select * from atacc1 where a = 1;
ERROR:  column "a" does not exist
LINE 1: select * from atacc1 where a = 1;
                                   ^
select "........pg.dropped.1........" from atacc1;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select "........pg.dropped.1........" from atacc1;
               ^
select atacc1."........pg.dropped.1........" from atacc1;
ERROR:  column atacc1.........pg.dropped.1........ does not exist
LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
               ^
select "........pg.dropped.1........",b,c,d from atacc1;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
               ^
select * from atacc1 where "........pg.dropped.1........" = 1;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
                                   ^
-- UPDATEs
update atacc1 set a = 3;
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: update atacc1 set a = 3;
                          ^
update atacc1 set b = 2 where a = 3;
ERROR:  column "a" does not exist
LINE 1: update atacc1 set b = 2 where a = 3;
                                      ^
update atacc1 set "........pg.dropped.1........" = 3;
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
                          ^
update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
                                      ^
-- INSERTs
insert into atacc1 values (10, 11, 12, 13);
ERROR:  INSERT has more expressions than target columns
LINE 1: insert into atacc1 values (10, 11, 12, 13);
                                               ^
insert into atacc1 values (default, 11, 12, 13);
ERROR:  INSERT has more expressions than target columns
LINE 1: insert into atacc1 values (default, 11, 12, 13);
                                                    ^
insert into atacc1 values (11, 12, 13);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 (a) values (10);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (10);
                            ^
insert into atacc1 (a) values (default);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (default);
                            ^
insert into atacc1 (a,b,c,d) values (10,11,12,13);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
                            ^
insert into atacc1 (a,b,c,d) values (default,11,12,13);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
                            ^
insert into atacc1 (b,c,d) values (11,12,13);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1 ("........pg.dropped.1........") values (10);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                            ^
insert into atacc1 ("........pg.dropped.1........") values (default);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                            ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                            ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                            ^
-- DELETEs
delete from atacc1 where a = 3;
ERROR:  column "a" does not exist
LINE 1: delete from atacc1 where a = 3;
                                 ^
delete from atacc1 where "........pg.dropped.1........" = 3;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
                                 ^
delete from atacc1;
ERROR:  cannot execute DELETE in a read-only transaction
-- try dropping a non-existent column, should fail
alter table atacc1 drop bar;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try dropping the oid column, should succeed
alter table atacc1 drop oid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try dropping the xmin column, should fail
alter table atacc1 drop xmin;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
select * from myview;
 b | c | d 
---+---+---
(0 rows)

alter table myview drop d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop view myview;
ERROR:  cannot execute DROP VIEW in a read-only transaction
-- test some commands to make sure they fail on the dropped column
analyze atacc1(a);
ERROR:  cannot execute ANALYZE during recovery
analyze atacc1("........pg.dropped.1........");
ERROR:  cannot execute ANALYZE during recovery
vacuum analyze atacc1(a);
ERROR:  cannot execute VACUUM during recovery
vacuum analyze atacc1("........pg.dropped.1........");
ERROR:  cannot execute VACUUM during recovery
comment on column atacc1.a is 'testing';
ERROR:  cannot execute COMMENT in a read-only transaction
comment on column atacc1."........pg.dropped.1........" is 'testing';
ERROR:  cannot execute COMMENT in a read-only transaction
alter table atacc1 alter a set storage plain;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter "........pg.dropped.1........" set storage plain;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter a set statistics 0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter a set default 3;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter "........pg.dropped.1........" set default 3;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter a drop default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter "........pg.dropped.1........" drop default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter a set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter "........pg.dropped.1........" set not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter a drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 alter "........pg.dropped.1........" drop not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 rename a to x;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 rename "........pg.dropped.1........" to x;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add primary key(a);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add primary key("........pg.dropped.1........");
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add unique(a);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add unique("........pg.dropped.1........");
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add check (a > 3);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add check ("........pg.dropped.1........" > 3);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create table atacc2 (id int4 unique);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table atacc1 add foreign key (a) references atacc2(id);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc2 add foreign key (id) references atacc1(a);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table atacc2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create index "testing_idx" on atacc1(a);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
create index "testing_idx" on atacc1("........pg.dropped.1........");
ERROR:  cannot execute CREATE INDEX in a read-only transaction
-- test create as and select into
insert into atacc1 values (21, 22, 23);
ERROR:  cannot execute INSERT in a read-only transaction
create table attest1 as select * from atacc1;
ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
select * from attest1;
 b  | c  | d  
----+----+----
 21 | 22 | 23
(1 row)

drop table attest1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
select * into attest2 from atacc1;
ERROR:  cannot execute SELECT INTO in a read-only transaction
select * from attest2;
 b  | c  | d  
----+----+----
 21 | 22 | 23
(1 row)

drop table attest2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- try dropping all columns
alter table atacc1 drop c;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 drop d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 drop b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from atacc1;
--
(1 row)

drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test constraint error reporting in presence of dropped columns
create table atacc1 (id serial primary key, value int check (value < 10));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into atacc1(value) values (100);
ERROR:  cannot execute INSERT in a read-only transaction
alter table atacc1 drop column value;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table atacc1 add column value int check (value < 10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into atacc1(value) values (100);
ERROR:  cannot execute INSERT in a read-only transaction
insert into atacc1(id, value) values (null, 0);
ERROR:  cannot execute INSERT in a read-only transaction
drop table atacc1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test inheritance
create table parent (a int, b int, c int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into parent values (1, 2, 3);
ERROR:  cannot execute INSERT in a read-only transaction
alter table parent drop a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create table child (d varchar(255)) inherits (parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into child values (12, 13, 'testing');
ERROR:  cannot execute INSERT in a read-only transaction
select * from parent;
 b  | c  
----+----
  2 |  3
 12 | 13
(2 rows)

select * from child;
 b  | c  |    d    
----+----+---------
 12 | 13 | testing
(1 row)

alter table parent drop c;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from parent;
 b  
----
  2
 12
(2 rows)

select * from child;
 b  |    d    
----+---------
 12 | testing
(1 row)

drop table child;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table parent;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check error cases for inheritance column merging
create table parent (a float8, b numeric(10,4), c text collate "C");
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table child (a float4) inherits (parent); -- fail
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table child (b decimal(10,7)) inherits (parent); -- fail
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table child (c text collate "POSIX") inherits (parent); -- fail
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table child (a double precision, b decimal(10,4)) inherits (parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
drop table child;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table parent;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test copy in/out
create table attest (a int4, b int4, c int4);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into attest values (1,2,3);
ERROR:  cannot execute INSERT in a read-only transaction
alter table attest drop a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
copy attest to stdout;
2	3
copy attest(a) to stdout;
ERROR:  column "a" of relation "attest" does not exist
copy attest("........pg.dropped.1........") to stdout;
ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
copy attest from stdin;
ERROR:  cannot execute COPY FROM in a read-only transaction
select * from attest;
 b | c 
---+---
 2 | 3
(1 row)

copy attest from stdin;
ERROR:  cannot execute COPY FROM in a read-only transaction
select * from attest;
 b  | c  
----+----
  2 |  3
 21 | 22
(2 rows)

copy attest(a) from stdin;
ERROR:  column "a" of relation "attest" does not exist
copy attest("........pg.dropped.1........") from stdin;
ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
copy attest(b,c) from stdin;
ERROR:  cannot execute COPY FROM in a read-only transaction
select * from attest;
 b  | c  
----+----
  2 |  3
 21 | 22
 31 | 32
(3 rows)

drop table attest;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test inheritance
create table dropColumn (a int, b int, e int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table dropColumnChild (c int) inherits (dropColumn);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table dropColumnAnother (d int) inherits (dropColumnChild);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- these two should fail
alter table dropColumnchild drop column a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table only dropColumnChild drop column b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- these three should work
alter table only dropColumn drop column e;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table dropColumnChild drop column c;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table dropColumn drop column a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create table renameColumn (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table renameColumnChild (b int) inherits (renameColumn);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table renameColumnAnother (c int) inherits (renameColumnChild);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- these three should fail
alter table renameColumnChild rename column a to d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table only renameColumnChild rename column a to d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table only renameColumn rename column a to d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- these should work
alter table renameColumn rename column a to d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table renameColumnChild rename column b to a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- these should work
alter table if exists doesnt_exist_tab rename column a to d;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table if exists doesnt_exist_tab rename column b to a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- this should work
alter table renameColumn add column w int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- this should fail
alter table only renameColumn add column x int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Test corner cases in dropping of inherited columns
create table p1 (f1 int, f2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table c1 (f1 int not null) inherits(p1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should work
alter table p1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- c1.f1 is still there, but no longer inherited
select f1 from c1;
 f1 
----
(0 rows)

alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select f1 from c1;
ERROR:  column "f1" does not exist
LINE 1: select f1 from c1;
               ^
HINT:  Perhaps you meant to reference the column "c1.f2".
drop table p1 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create table p1 (f1 int, f2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table c1 () inherits(p1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table p1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- c1.f1 is dropped now, since there is no local definition for it
select f1 from c1;
ERROR:  column "f1" does not exist
LINE 1: select f1 from c1;
               ^
HINT:  Perhaps you meant to reference the column "c1.f2".
drop table p1 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create table p1 (f1 int, f2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table c1 () inherits(p1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table only p1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- c1.f1 is NOT dropped, but must now be considered non-inherited
alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table p1 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create table p1 (f1 int, f2 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table c1 (f1 int not null) inherits(p1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table only p1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- c1.f1 is still there, but no longer inherited
alter table c1 drop column f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table p1 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create table p1(id int, name text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table p2(id2 int, name text, height int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table c1(age int) inherits(p1,p2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table gc1() inherits (c1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 c1      | id      |           1 | f
 c1      | name    |           2 | f
 c1      | id2     |           1 | f
 c1      | height  |           1 | f
 c1      | age     |           0 | t
 gc1     | id      |           1 | f
 gc1     | name    |           1 | f
 gc1     | id2     |           1 | f
 gc1     | height  |           1 | f
 gc1     | age     |           1 | f
 p1      | id      |           0 | t
 p1      | name    |           0 | t
 p2      | id2     |           0 | t
 p2      | name    |           0 | t
 p2      | height  |           0 | t
(15 rows)

-- should work
alter table only p1 drop column name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should work. Now c1.name is local and inhcount is 0.
alter table p2 drop column name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be rejected since its inherited
alter table gc1 drop column name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should work, and drop gc1.name along
alter table c1 drop column name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should fail: column does not exist
alter table gc1 drop column name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should work and drop the attribute in all tables
alter table p2 drop column height;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- IF EXISTS test
create table dropColumnExists ();
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table dropColumnExists drop column non_existing; --fail
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table dropColumnExists drop column if exists non_existing; --succeed
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 c1      | id      |           1 | f
 c1      | id2     |           1 | f
 c1      | age     |           0 | t
 gc1     | id      |           1 | f
 gc1     | id2     |           1 | f
 gc1     | age     |           1 | f
 p1      | id      |           0 | t
 p2      | id2     |           0 | t
(8 rows)

drop table p1, p2 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test attinhcount tracking with merged columns
create table depth0();
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table depth1(c text) inherits (depth0);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table depth2() inherits (depth1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table depth0 add c text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select attrelid::regclass, attname, attinhcount, attislocal
from pg_attribute
where attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')
order by attrelid::regclass::text, attnum;
 attrelid | attname | attinhcount | attislocal 
----------+---------+-------------+------------
 depth0   | c       |           0 | t
 depth1   | c       |           1 | t
 depth2   | c       |           1 | f
(3 rows)

--
-- Test the ALTER TABLE SET WITH/WITHOUT OIDS command
--
create table altstartwith (col integer) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into altstartwith values (1);
ERROR:  cannot execute INSERT in a read-only transaction
select oid > 0, * from altstartwith;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

alter table altstartwith set without oids;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select oid > 0, * from altstartwith; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altstartwith;
               ^
select * from altstartwith;
 col 
-----
   1
(1 row)

alter table altstartwith set with oids;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select oid > 0, * from altstartwith;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

drop table altstartwith;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Check inheritance cases
create table altwithoid (col integer) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- Inherits parents oid column anyway
create table altinhoid () inherits (altwithoid) without oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into altinhoid values (1);
ERROR:  cannot execute INSERT in a read-only transaction
select oid > 0, * from altwithoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

alter table altwithoid set without oids;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altinhoid;
               ^
select * from altwithoid;
 col 
-----
   1
(1 row)

select * from altinhoid;
 col 
-----
   1
(1 row)

alter table altwithoid set with oids;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select oid > 0, * from altwithoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

drop table altwithoid cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create table altwithoid (col integer) without oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- child can have local oid column
create table altinhoid () inherits (altwithoid) with oids;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into altinhoid values (1);
ERROR:  cannot execute INSERT in a read-only transaction
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

alter table altwithoid set with oids;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select oid > 0, * from altwithoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

-- the child's local definition should remain
alter table altwithoid set without oids;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

drop table altwithoid cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test renumbering of child-table columns in inherited operations
create table p1 (f1 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table c1 (f2 text, f3 int) inherits (p1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table p1 add column a1 int check (a1 > 0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table p1 add column f2 text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into p1 values (1,2,'abc');
ERROR:  cannot execute INSERT in a read-only transaction
insert into c1 values(11,'xyz',33,0); -- should fail
ERROR:  cannot execute INSERT in a read-only transaction
insert into c1 values(11,'xyz',33,22);
ERROR:  cannot execute INSERT in a read-only transaction
select * from p1;
 f1 | a1 | f2  
----+----+-----
  1 |  2 | abc
 11 | 22 | xyz
(2 rows)

update p1 set a1 = a1 + 1, f2 = upper(f2);
ERROR:  cannot execute UPDATE in a read-only transaction
select * from p1;
 f1 | a1 | f2  
----+----+-----
  1 |  3 | ABC
 11 | 23 | XYZ
(2 rows)

drop table p1 cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test that operations with a dropped column do not try to reference
-- its datatype
create domain mytype as text;
ERROR:  cannot execute CREATE DOMAIN in a read-only transaction
create temp table foo (f1 text, f2 mytype, f3 text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into foo values('bb','cc','dd');
ERROR:  relation "foo" does not exist
LINE 1: insert into foo values('bb','cc','dd');
                    ^
select * from foo;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo;
                      ^
drop domain mytype cascade;
ERROR:  cannot execute DROP DOMAIN in a read-only transaction
select * from foo;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo;
                      ^
insert into foo values('qq','rr');
ERROR:  relation "foo" does not exist
LINE 1: insert into foo values('qq','rr');
                    ^
select * from foo;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo;
                      ^
update foo set f3 = 'zz';
ERROR:  relation "foo" does not exist
LINE 1: update foo set f3 = 'zz';
               ^
select * from foo;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo;
                      ^
select f3,max(f1) from foo group by f3;
ERROR:  relation "foo" does not exist
LINE 1: select f3,max(f1) from foo group by f3;
                               ^
-- Simple tests for alter table column type
alter table foo alter f1 TYPE integer; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table foo alter f1 TYPE varchar(10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create table anothertab (atcol1 serial8, atcol2 boolean,
	constraint anothertab_chk check (atcol1 <= 3));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into anothertab (atcol1, atcol2) values (default, true);
ERROR:  cannot execute INSERT in a read-only transaction
insert into anothertab (atcol1, atcol2) values (default, false);
ERROR:  cannot execute INSERT in a read-only transaction
select * from anothertab;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
(2 rows)

alter table anothertab alter column atcol1 type boolean; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab alter column atcol1 type boolean using atcol1::int; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab alter column atcol1 type integer;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from anothertab;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
(2 rows)

insert into anothertab (atcol1, atcol2) values (45, null); -- fails
ERROR:  cannot execute INSERT in a read-only transaction
insert into anothertab (atcol1, atcol2) values (default, null);
ERROR:  cannot execute INSERT in a read-only transaction
select * from anothertab;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
      3 | 
(3 rows)

alter table anothertab alter column atcol2 type text
      using case when atcol2 is true then 'IT WAS TRUE'
                 when atcol2 is false then 'IT WAS FALSE'
                 else 'IT WAS NULL!' end;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from anothertab;
 atcol1 |    atcol2    
--------+--------------
      1 | IT WAS TRUE
      2 | IT WAS FALSE
      3 | IT WAS NULL!
(3 rows)

alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab alter column atcol1 drop default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab drop constraint anothertab_chk;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab drop constraint anothertab_chk; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeeds
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from anothertab;
 atcol1 |    atcol2    
--------+--------------
 f      | IT WAS TRUE
 t      | IT WAS FALSE
 f      | IT WAS NULL!
(3 rows)

drop table anothertab;
ERROR:  cannot execute DROP TABLE in a read-only transaction
create table another (f1 int, f2 text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into another values(1, 'one');
ERROR:  cannot execute INSERT in a read-only transaction
insert into another values(2, 'two');
ERROR:  cannot execute INSERT in a read-only transaction
insert into another values(3, 'three');
ERROR:  cannot execute INSERT in a read-only transaction
select * from another;
 f1 |  f2   
----+-------
  1 | one
  2 | two
  3 | three
(3 rows)

alter table another
  alter f1 type text using f2 || ' more',
  alter f2 type bigint using f1 * 10;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from another;
     f1     | f2 
------------+----
 one more   | 10
 two more   | 20
 three more | 30
(3 rows)

drop table another;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- table's row type
create table tab1 (a int, b text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table tab2 (x int, y tab1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table tab1 alter column b type varchar; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Alter column type that's part of a partitioned index
create table at_partitioned (a int, b text) partition by range (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table at_part_1 partition of at_partitioned for values from (0) to (1000);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into at_partitioned values (512, '0.123');
ERROR:  cannot execute INSERT in a read-only transaction
create table at_part_2 (b text, a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into at_part_2 values ('1.234', 1024);
ERROR:  cannot execute INSERT in a read-only transaction
create index on at_partitioned (b);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
create index on at_partitioned (a);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
\d at_part_1
\d at_part_2
alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d at_part_2
alter table at_partitioned alter column b type numeric using b::numeric;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d at_part_1
\d at_part_2
drop table at_partitioned;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Alter column type when no table rewrite is required
-- Also check that comments are preserved
create table at_partitioned(id int, name varchar(64), unique (id, name))
  partition by hash(id);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
comment on constraint at_partitioned_id_name_key on at_partitioned is 'parent constraint';
ERROR:  cannot execute COMMENT in a read-only transaction
comment on index at_partitioned_id_name_key is 'parent index';
ERROR:  cannot execute COMMENT in a read-only transaction
create table at_partitioned_0 partition of at_partitioned
  for values with (modulus 2, remainder 0);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
comment on constraint at_partitioned_0_id_name_key on at_partitioned_0 is 'child 0 constraint';
ERROR:  cannot execute COMMENT in a read-only transaction
comment on index at_partitioned_0_id_name_key is 'child 0 index';
ERROR:  cannot execute COMMENT in a read-only transaction
create table at_partitioned_1 partition of at_partitioned
  for values with (modulus 2, remainder 1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
comment on constraint at_partitioned_1_id_name_key on at_partitioned_1 is 'child 1 constraint';
ERROR:  cannot execute COMMENT in a read-only transaction
comment on index at_partitioned_1_id_name_key is 'child 1 index';
ERROR:  cannot execute COMMENT in a read-only transaction
insert into at_partitioned values(1, 'foo');
ERROR:  cannot execute INSERT in a read-only transaction
insert into at_partitioned values(3, 'bar');
ERROR:  cannot execute INSERT in a read-only transaction
create temp table old_oids as
  select relname, oid as oldoid, relfilenode as oldfilenode
  from pg_class where relname like 'at_partitioned%';
ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
select relname,
  c.oid = oldoid as orig_oid,
  case relfilenode
    when 0 then 'none'
    when c.oid then 'own'
    when oldfilenode then 'orig'
    else 'OTHER'
    end as storage,
  obj_description(c.oid, 'pg_class') as desc
  from pg_class c left join old_oids using (relname)
  where relname like 'at_partitioned%'
  order by relname;
ERROR:  relation "old_oids" does not exist
LINE 10:   from pg_class c left join old_oids using (relname)
                                     ^
select conname, obj_description(oid, 'pg_constraint') as desc
  from pg_constraint where conname like 'at_partitioned%'
  order by conname;
           conname            |        desc        
------------------------------+--------------------
 at_partitioned_0_id_name_key | child 0 constraint
 at_partitioned_1_id_name_key | child 1 constraint
 at_partitioned_id_name_key   | parent constraint
(3 rows)

alter table at_partitioned alter column name type varchar(127);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Note: these tests currently show the wrong behavior for comments :-(
select relname,
  c.oid = oldoid as orig_oid,
  case relfilenode
    when 0 then 'none'
    when c.oid then 'own'
    when oldfilenode then 'orig'
    else 'OTHER'
    end as storage,
  obj_description(c.oid, 'pg_class') as desc
  from pg_class c left join old_oids using (relname)
  where relname like 'at_partitioned%'
  order by relname;
ERROR:  relation "old_oids" does not exist
LINE 10:   from pg_class c left join old_oids using (relname)
                                     ^
select conname, obj_description(oid, 'pg_constraint') as desc
  from pg_constraint where conname like 'at_partitioned%'
  order by conname;
           conname            |       desc        
------------------------------+-------------------
 at_partitioned_0_id_name_key | 
 at_partitioned_1_id_name_key | 
 at_partitioned_id_name_key   | parent constraint
(3 rows)

-- Don't remove this DROP, it exposes bug #15672
drop table at_partitioned;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- disallow recursive containment of row types
create temp table recur1 (f1 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table recur1 add column f2 recur1; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table recur1 add column f2 recur1[]; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create domain array_of_recur1 as recur1[];
ERROR:  cannot execute CREATE DOMAIN in a read-only transaction
alter table recur1 add column f2 array_of_recur1; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
create temp table recur2 (f1 int, f2 recur1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table recur1 add column f2 recur2; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table recur1 add column f2 int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table recur1 alter column f2 type recur2; -- fails
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- SET STORAGE may need to add a TOAST table
create table test_storage (a text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table test_storage alter a set storage plain;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table test_storage add b int default 0; -- rewrite table to remove its TOAST table
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table test_storage alter a set storage extended; -- re-add TOAST table
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select reltoastrelid <> 0 as has_toast_table
from pg_class
where oid = 'test_storage'::regclass;
 has_toast_table 
-----------------
 t
(1 row)

-- ALTER COLUMN TYPE with a check constraint and a child table (bug #13779)
CREATE TABLE test_inh_check (a float check (a > 10.2), b float);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
\d test_inh_check
\d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(2 rows)

ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_inh_check
\d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(2 rows)

-- also try noinherit, local, and local+inherited cases
ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE test_inh_check_child ADD CONSTRAINT bmerged CHECK (b > 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_inh_check
\d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | bmerged                |           0 | t          | f
 test_inh_check       | bnoinherit             |           0 | t          | t
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | blocal                 |           0 | t          | f
 test_inh_check_child | bmerged                |           1 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(6 rows)

ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_inh_check
\d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | bmerged                |           0 | t          | f
 test_inh_check       | bnoinherit             |           0 | t          | t
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | blocal                 |           0 | t          | f
 test_inh_check_child | bmerged                |           1 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(6 rows)

-- ALTER COLUMN TYPE with different schema in children
-- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
CREATE TABLE test_type_diff (f1 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE test_type_diff ADD COLUMN f2 int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
INSERT INTO test_type_diff_c VALUES (1, 2, 3);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE test_type_diff ALTER COLUMN f2 TYPE bigint USING f2::bigint;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE test_type_diff2 (int_two int2, int_four int4, int_eight int8);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_type_diff2_c1 (int_four int4, int_eight int8, int_two int2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6);
ERROR:  cannot execute INSERT in a read-only transaction
INSERT INTO test_type_diff2_c3 VALUES (7, 8, 9);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int8 USING int_four::int8;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- whole-row references are disallowed
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2));
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check for rollback of ANALYZE corrupting table property flags (bug #11638)
CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
BEGIN;
ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ANALYZE check_fk_presence_2;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
\d check_fk_presence_2
DROP TABLE check_fk_presence_1, check_fk_presence_2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check column addition within a view (bug #14876)
create table at_base_table(id int, stuff text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into at_base_table values (23, 'skidoo');
ERROR:  cannot execute INSERT in a read-only transaction
create view at_view_1 as select * from at_base_table bt;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
\d+ at_view_1
\d+ at_view_2
explain (verbose, costs off) select * from at_view_2;
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff))
(2 rows)

select * from at_view_2;
 id | stuff  |             j              
----+--------+----------------------------
 23 | skidoo | {"id":23,"stuff":"skidoo"}
(1 row)

create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
\d+ at_view_1
\d+ at_view_2
explain (verbose, costs off) select * from at_view_2;
                           QUERY PLAN                           
----------------------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff, NULL))
(2 rows)

select * from at_view_2;
 id | stuff  |                   j                    
----+--------+----------------------------------------
 23 | skidoo | {"id":23,"stuff":"skidoo","more":null}
(1 row)

drop view at_view_2;
ERROR:  cannot execute DROP VIEW in a read-only transaction
drop view at_view_1;
ERROR:  cannot execute DROP VIEW in a read-only transaction
drop table at_base_table;
ERROR:  cannot execute DROP TABLE in a read-only transaction
--
-- lock levels
--
drop type lockmodes;
ERROR:  cannot execute DROP TYPE in a read-only transaction
create type lockmodes as enum (
 'SIReadLock'
,'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
drop view my_locks;
ERROR:  cannot execute DROP VIEW in a read-only transaction
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = txid_current()::integer)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
create table alterlock (f1 int primary key, f2 text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into alterlock values (1, 'foo');
ERROR:  cannot execute INSERT in a read-only transaction
create table alterlock2 (f3 int primary key, f1 int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into alterlock2 values (1, 1);
ERROR:  cannot execute INSERT in a read-only transaction
begin; alter table alterlock alter column f2 set statistics 150;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
begin; alter table alterlock cluster on alterlock_pkey;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock set without cluster;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock set (fillfactor = 100);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock reset (fillfactor);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock set (toast.autovacuum_enabled = off);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock set (autovacuum_enabled = off);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock alter column f2 set (n_distinct = 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
-- test that mixing options with different lock levels works as expected
begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock alter column f2 set storage extended;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
begin; alter table alterlock alter column f2 set default 'x';
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
begin;
create trigger ttdummy
	before delete or update on alterlock
	for each row
	execute procedure
	ttdummy (1, 1);
ERROR:  cannot execute CREATE TRIGGER in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
begin;
select * from my_locks order by 1;
ERROR:  cannot execute txid_current() during recovery
alter table alterlock2 add foreign key (f1) references alterlock (f1);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
begin;
alter table alterlock2
add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin;
alter table alterlock2 validate constraint alterlock2nv;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = txid_current()::integer)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname = 'my_locks'
group by c.relname;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
-- raise exception
alter table my_locks set (autovacuum_enabled = false);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter view my_locks set (autovacuum_enabled = false);
ERROR:  cannot execute ALTER VIEW in a read-only transaction
alter table my_locks reset (autovacuum_enabled);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter view my_locks reset (autovacuum_enabled);
ERROR:  cannot execute ALTER VIEW in a read-only transaction
begin;
alter view my_locks set (security_barrier=off);
ERROR:  cannot execute ALTER VIEW in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
alter view my_locks reset (security_barrier);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
-- this test intentionally applies the ALTER TABLE command against a view, but
-- uses a view option so we expect this to succeed. This form of SQL is
-- accepted for historical reasons, as shown in the docs for ALTER VIEW
begin;
alter table my_locks set (security_barrier=off);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
alter table my_locks reset (security_barrier);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
-- cleanup
drop table alterlock2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table alterlock;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop view my_locks;
ERROR:  cannot execute DROP VIEW in a read-only transaction
drop type lockmodes;
ERROR:  cannot execute DROP TYPE in a read-only transaction
--
-- alter function
--
create function test_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql returns null on null input;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select test_strict(NULL);
 test_strict 
-------------
 
(1 row)

alter function test_strict(text) called on null input;
ERROR:  cannot execute ALTER FUNCTION in a read-only transaction
select test_strict(NULL);
    test_strict    
-------------------
 got passed a null
(1 row)

create function non_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql called on null input;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
select non_strict(NULL);
    non_strict     
-------------------
 got passed a null
(1 row)

alter function non_strict(text) returns null on null input;
ERROR:  cannot execute ALTER FUNCTION in a read-only transaction
select non_strict(NULL);
 non_strict 
------------
 
(1 row)

--
-- alter object set schema
--
create schema alter1;
ERROR:  cannot execute CREATE SCHEMA in a read-only transaction
create schema alter2;
ERROR:  cannot execute CREATE SCHEMA in a read-only transaction
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create view alter1.v1 as select * from alter1.t1;
ERROR:  cannot execute CREATE VIEW in a read-only transaction
create function alter1.plus1(int) returns int as 'select $1+1' language sql;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
create domain alter1.posint integer check (value > 0);
ERROR:  cannot execute CREATE DOMAIN in a read-only transaction
create type alter1.ctype as (f1 int, f2 text);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
ERROR:  cannot execute CREATE OPERATOR in a read-only transaction
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
  operator 1 alter1.=(alter1.ctype, alter1.ctype);
ERROR:  cannot execute CREATE OPERATOR CLASS in a read-only transaction
create conversion alter1.ascii_to_utf8 for 'sql_ascii' to 'utf8' from ascii_to_utf8;
ERROR:  cannot execute CREATE CONVERSION in a read-only transaction
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ERROR:  cannot execute CREATE TEXT SEARCH PARSER in a read-only transaction
create text search configuration alter1.cfg(parser = alter1.prs);
ERROR:  cannot execute CREATE TEXT SEARCH CONFIGURATION in a read-only transaction
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
ERROR:  cannot execute CREATE TEXT SEARCH TEMPLATE in a read-only transaction
create text search dictionary alter1.dict(template = alter1.tmpl);
ERROR:  cannot execute CREATE TEXT SEARCH DICTIONARY in a read-only transaction
insert into alter1.t1(f2) values(11);
ERROR:  cannot execute INSERT in a read-only transaction
insert into alter1.t1(f2) values(12);
ERROR:  cannot execute INSERT in a read-only transaction
alter table alter1.t1 set schema alter1; -- no-op, same schema
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table alter1.t1 set schema alter2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table alter1.v1 set schema alter2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter function alter1.plus1(int) set schema alter2;
ERROR:  cannot execute ALTER FUNCTION in a read-only transaction
alter domain alter1.posint set schema alter2;
ERROR:  cannot execute ALTER DOMAIN in a read-only transaction
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
ERROR:  cannot execute ALTER OPERATOR CLASS in a read-only transaction
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
ERROR:  cannot execute ALTER OPERATOR FAMILY in a read-only transaction
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
ERROR:  cannot execute ALTER OPERATOR in a read-only transaction
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
ERROR:  cannot execute ALTER FUNCTION in a read-only transaction
alter type alter1.ctype set schema alter1; -- no-op, same schema
ERROR:  cannot execute ALTER TYPE in a read-only transaction
alter type alter1.ctype set schema alter2;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
alter conversion alter1.ascii_to_utf8 set schema alter2;
ERROR:  cannot execute ALTER CONVERSION in a read-only transaction
alter text search parser alter1.prs set schema alter2;
ERROR:  cannot execute ALTER TEXT SEARCH PARSER in a read-only transaction
alter text search configuration alter1.cfg set schema alter2;
ERROR:  cannot execute ALTER TEXT SEARCH CONFIGURATION in a read-only transaction
alter text search template alter1.tmpl set schema alter2;
ERROR:  cannot execute ALTER TEXT SEARCH TEMPLATE in a read-only transaction
alter text search dictionary alter1.dict set schema alter2;
ERROR:  cannot execute ALTER TEXT SEARCH DICTIONARY in a read-only transaction
-- this should succeed because nothing is left in alter1
drop schema alter1;
ERROR:  cannot execute DROP SCHEMA in a read-only transaction
insert into alter2.t1(f2) values(13);
ERROR:  cannot execute INSERT in a read-only transaction
insert into alter2.t1(f2) values(14);
ERROR:  cannot execute INSERT in a read-only transaction
select * from alter2.t1;
 f1 | f2 
----+----
  1 | 11
  2 | 12
  3 | 13
  4 | 14
(4 rows)

select * from alter2.v1;
 f1 | f2 
----+----
  1 | 11
  2 | 12
  3 | 13
  4 | 14
(4 rows)

select alter2.plus1(41);
 plus1 
-------
    42
(1 row)

-- clean up
drop schema alter2 cascade;
ERROR:  cannot execute DROP SCHEMA in a read-only transaction
--
-- composite types
--
CREATE TYPE test_type AS (a int);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
\d test_type
ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type ADD ATTRIBUTE b text;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type
ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type
ALTER TYPE test_type DROP ATTRIBUTE b;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type
ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type
DROP TYPE test_type;
ERROR:  cannot execute DROP TYPE in a read-only transaction
CREATE TYPE test_type1 AS (a int, b text);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
CREATE TABLE test_tbl1 (x int, y test_type1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
CREATE TYPE test_type2 AS (a int, b text);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
CREATE TABLE test_tbl2 OF test_type2;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_type2
\d test_tbl2
\d test_tbl2_subclass
DROP TABLE test_tbl2_subclass;
ERROR:  cannot execute DROP TABLE in a read-only transaction
CREATE TYPE test_typex AS (a int, b text);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TYPE test_typex DROP ATTRIBUTE a; -- fails
ERROR:  cannot execute ALTER TYPE in a read-only transaction
ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
\d test_tblx
DROP TABLE test_tblx;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TYPE test_typex;
ERROR:  cannot execute DROP TYPE in a read-only transaction
-- This test isn't that interesting on its own, but the purpose is to leave
-- behind a table to test pg_upgrade with. The table has a composite type
-- column in it, and the composite type has a dropped attribute.
CREATE TYPE test_type3 AS (a int);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
CREATE TYPE test_type_empty AS ();
ERROR:  cannot execute CREATE TYPE in a read-only transaction
DROP TYPE test_type_empty;
ERROR:  cannot execute DROP TYPE in a read-only transaction
--
-- typed tables: OF / NOT OF
--
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
ERROR:  cannot execute CREATE TYPE in a read-only transaction
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
ERROR:  cannot execute ALTER TYPE in a read-only transaction
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt4 (x int);							-- too few columns
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE tt7 (x int, q text, y numeric(8,2)) WITH OIDS;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE tt7 DROP q;								-- OK
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt0 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt1 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt2 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt3 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt4 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt5 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt6 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt7 OF tt_t0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
ERROR:  cannot execute CREATE TYPE in a read-only transaction
ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt7 NOT OF;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d tt7
-- make sure we can drop a constraint on the parent but it remains on the child
CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should fail
INSERT INTO test_drop_constr_child (c) VALUES (NULL);
ERROR:  cannot execute INSERT in a read-only transaction
DROP TABLE test_drop_constr_parent CASCADE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
--
-- IF EXISTS test
--
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE tt8(a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE SCHEMA alter2;
ERROR:  cannot execute CREATE SCHEMA in a read-only transaction
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d alter2.tt8
DROP TABLE alter2.tt8;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP SCHEMA alter2;
ERROR:  cannot execute DROP SCHEMA in a read-only transaction
--
-- Check conflicts between index and CHECK constraint names
--
CREATE TABLE tt9(c integer);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE tt9 ADD CHECK(c > 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CHECK(c > 2);  -- picks nonconflicting name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 3);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 4);  -- fail, dup name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD UNIQUE(c);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key UNIQUE(c);  -- fail, dup name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CONSTRAINT foo UNIQUE(c);  -- fail, dup name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key CHECK(c > 5);  -- fail, dup name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d tt9
DROP TABLE tt9;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Check that comments on constraints and indexes are not lost at ALTER TABLE.
CREATE TABLE comment_test (
  id int,
  positive_col int CHECK (positive_col > 0),
  indexed_col int,
  CONSTRAINT comment_test_pk PRIMARY KEY (id));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE INDEX comment_test_index ON comment_test(indexed_col);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test';
ERROR:  cannot execute COMMENT in a read-only transaction
SELECT col_description('comment_test'::regclass, 1) as comment;
           comment           
-----------------------------
 Column 'id' on comment_test
(1 row)

SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
       index        |                    comment                    
--------------------+-----------------------------------------------
 comment_test_index | Simple index on comment_test
 comment_test_pk    | Index backing the PRIMARY KEY of comment_test
(2 rows)

SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
           constraint            |                    comment                    
---------------------------------+-----------------------------------------------
 comment_test_pk                 | PRIMARY KEY constraint of comment_test
 comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
(2 rows)

-- Change the datatype of all the columns. ALTER TABLE is optimized to not
-- rebuild an index if the new data type is binary compatible with the old
-- one. Check do a dummy ALTER TABLE that doesn't change the datatype
-- first, to test that no-op codepath, and another one that does.
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Check that the comments are intact.
SELECT col_description('comment_test'::regclass, 1) as comment;
           comment           
-----------------------------
 Column 'id' on comment_test
(1 row)

SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
       index        |                    comment                    
--------------------+-----------------------------------------------
 comment_test_index | Simple index on comment_test
 comment_test_pk    | Index backing the PRIMARY KEY of comment_test
(2 rows)

SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
           constraint            |                    comment                    
---------------------------------+-----------------------------------------------
 comment_test_pk                 | PRIMARY KEY constraint of comment_test
 comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
(2 rows)

-- Check compatibility for foreign keys and comments. This is done
-- separately as rebuilding the column type of the parent leads
-- to an error and would reduce the test scope.
CREATE TABLE comment_test_child (
  id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE INDEX comment_test_child_fk ON comment_test_child(id);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
ERROR:  cannot execute COMMENT in a read-only transaction
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
ERROR:  cannot execute COMMENT in a read-only transaction
-- Change column type of parent
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Comments should be intact
SELECT col_description('comment_test_child'::regclass, 1) as comment;
              comment              
-----------------------------------
 Column 'id' on comment_test_child
(1 row)

SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
         index         |                       comment                       
-----------------------+-----------------------------------------------------
 comment_test_child_fk | Index backing the FOREIGN KEY of comment_test_child
(1 row)

SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
      constraint       |                   comment                    
-----------------------+----------------------------------------------
 comment_test_child_fk | FOREIGN KEY constraint of comment_test_child
(1 row)

-- Check that we map relation oids to filenodes and back correctly.  Only
-- display bad mappings so the test output doesn't change all the time.  A
-- filenode function call can return NULL for a relation dropped concurrently
-- with the call's surrounding query, so ignore a NULL mapped_oid for
-- relations that no longer exist after all calls finish.
CREATE TEMP TABLE filenode_mapping AS
SELECT
    oid, mapped_oid, reltablespace, relfilenode, relname
FROM pg_class,
    pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
ERROR:  relation "filenode_mapping" does not exist
LINE 1: SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c...
                        ^
-- Checks on creating and manipulation of user defined relations in
-- pg_catalog.
--
-- XXX: It would be useful to add checks around trying to manipulate
-- catalog tables, but that might have ugly consequences when run
-- against an existing server with allow_system_table_mods = on.
SHOW allow_system_table_mods;
 allow_system_table_mods 
-------------------------
 off
(1 row)

-- disallowed because of search_path issues with pg_dump
CREATE TABLE pg_catalog.new_system_table();
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- instead create in public first, move to catalog
CREATE TABLE new_system_table(id serial primary key, othercol text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- XXX: it's currently impossible to move relations out of pg_catalog
ALTER TABLE new_system_table SET SCHEMA public;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- move back, will be ignored -- already there
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE new_system_table RENAME TO old_system_table;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
ERROR:  cannot execute CREATE INDEX in a read-only transaction
INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
ERROR:  cannot execute INSERT in a read-only transaction
UPDATE old_system_table SET id = -id;
ERROR:  cannot execute UPDATE in a read-only transaction
DELETE FROM old_system_table WHERE othercol = 'somedata';
ERROR:  cannot execute DELETE in a read-only transaction
TRUNCATE old_system_table;
ERROR:  cannot execute TRUNCATE TABLE in a read-only transaction
ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE old_system_table DROP COLUMN othercol;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE old_system_table;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- set logged
CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check relpersistence of an unlogged table
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
ORDER BY relname;
     relname      | relkind | relpersistence 
------------------+---------+----------------
 toast index      | i       | p
 toast table      | t       | p
 unlogged1        | r       | p
 unlogged1_f1_seq | S       | p
 unlogged1_pkey   | i       | p
(5 rows)

CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE unlogged1 SET LOGGED;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check relpersistence of an unlogged table after changing to permanent
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
ORDER BY relname;
     relname      | relkind | relpersistence 
------------------+---------+----------------
 toast index      | i       | p
 toast table      | t       | p
 unlogged1        | r       | p
 unlogged1_f1_seq | S       | p
 unlogged1_pkey   | i       | p
(5 rows)

ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE unlogged3;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE unlogged2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE unlogged1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- set unlogged
CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check relpersistence of a permanent table
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
ORDER BY relname;
    relname     | relkind | relpersistence 
----------------+---------+----------------
 logged1        | r       | p
 logged1_f1_seq | S       | p
 logged1_pkey   | i       | p
 toast index    | i       | p
 toast table    | t       | p
(5 rows)

CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE logged2 SET UNLOGGED;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE logged1 SET UNLOGGED;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check relpersistence of a permanent table after changing to unlogged
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
ORDER BY relname;
    relname     | relkind | relpersistence 
----------------+---------+----------------
 logged1        | r       | u
 logged1_f1_seq | S       | p
 logged1_pkey   | i       | u
 toast index    | i       | u
 toast table    | t       | u
(5 rows)

ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE logged3;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE logged2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE logged1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test ADD COLUMN IF NOT EXISTS
CREATE TABLE test_add_column(c1 integer);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN c2 integer;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN c2 integer; -- fail because c2 already exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY test_add_column
	ADD COLUMN c2 integer; -- fail because c2 already exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN c2 integer, -- fail because c2 already exists
	ADD COLUMN c3 integer;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN c3 integer; -- fail because c3 already exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN IF NOT EXISTS c3 integer; -- skipping because c3 already exists
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
	ADD COLUMN c4 integer;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
\d test_add_column
DROP TABLE test_add_column;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- unsupported constraint types for partitioned tables
CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE (a, (a+b+1));
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- cannot drop column that is part of the partition key
ALTER TABLE partitioned DROP COLUMN a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE partitioned ALTER COLUMN a TYPE char(5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE partitioned DROP COLUMN b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE partitioned ALTER COLUMN b TYPE char(5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- partitioned table cannot participate in regular inheritance
CREATE TABLE nonpartitioned (
	a int,
	b int
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE partitioned INHERIT nonpartitioned;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE nonpartitioned INHERIT partitioned;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- cannot add NO INHERIT constraint to partitioned tables
ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE partitioned, nonpartitioned;
ERROR:  cannot execute DROP TABLE in a read-only transaction
--
-- ATTACH PARTITION
--
-- check that target table is partitioned
CREATE TABLE unparted (
	a int
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE fail_part (like unparted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE unparted, fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that partition bound is compatible
CREATE TABLE list_parted (
	a int NOT NULL,
	b char(2) COLLATE "C",
	CONSTRAINT check_a CHECK (a > 0)
) PARTITION BY LIST (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE fail_part (LIKE list_parted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that the table being attached exists
ALTER TABLE list_parted ATTACH PARTITION nonexistant FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check ownership of the source table
CREATE ROLE regress_test_me;
ERROR:  cannot execute CREATE ROLE in a read-only transaction
CREATE ROLE regress_test_not_me;
ERROR:  cannot execute CREATE ROLE in a read-only transaction
CREATE TABLE not_owned_by_me (LIKE list_parted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SET SESSION AUTHORIZATION regress_test_me;
CREATE TABLE owned_by_me (
	a int
) PARTITION BY LIST (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
RESET SESSION AUTHORIZATION;
DROP TABLE owned_by_me, not_owned_by_me;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP ROLE regress_test_not_me;
ERROR:  cannot execute DROP ROLE in a read-only transaction
DROP ROLE regress_test_me;
ERROR:  cannot execute DROP ROLE in a read-only transaction
-- check that the table being attached is not part of regular inheritance
CREATE TABLE parent (LIKE list_parted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE child () INHERITS (parent);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE parent CASCADE;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check any TEMP-ness
CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE perm_part (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE temp_parted, perm_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that the table being attached is not a typed table
CREATE TYPE mytype AS (a int);
ERROR:  cannot execute CREATE TYPE in a read-only transaction
CREATE TABLE fail_part OF mytype;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TYPE mytype CASCADE;
ERROR:  cannot execute DROP TYPE in a read-only transaction
-- check existence (or non-existence) of oid column
ALTER TABLE list_parted SET WITH OIDS;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE fail_part (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted SET WITHOUT OIDS;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE fail_part SET WITH OIDS;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that the table being attached has only columns present in the parent
CREATE TABLE fail_part (like list_parted, c int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that the table being attached has every column of the parent
CREATE TABLE fail_part (a int NOT NULL);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that columns match in type, collation and NOT NULL status
CREATE TABLE fail_part (
	b char(3),
	a int NOT NULL
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX";
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that the table being attached has all constraints of the parent
CREATE TABLE fail_part (
	b char(2) COLLATE "C",
	a int NOT NULL
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that the constraint matches in definition with parent's constraint
ALTER TABLE fail_part ADD CONSTRAINT check_a CHECK (a >= 0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check the attributes and constraints after partition is attached
CREATE TABLE part_1 (
	a int NOT NULL,
	b char(2) COLLATE "C",
	CONSTRAINT check_a CHECK (a > 0)
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- attislocal and conislocal are always false for merged attributes and constraints respectively.
SELECT attislocal, attinhcount FROM pg_attribute WHERE attrelid = 'part_1'::regclass AND attnum > 0;
 attislocal | attinhcount 
------------+-------------
 f          |           1
 f          |           1
(2 rows)

SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_1'::regclass AND conname = 'check_a';
 conislocal | coninhcount 
------------+-------------
 f          |           1
(1 row)

-- check that the new partition won't overlap with an existing partition
CREATE TABLE fail_part (LIKE part_1 INCLUDING CONSTRAINTS);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that an existing table can be attached as a default partition
CREATE TABLE def_part (LIKE list_parted INCLUDING CONSTRAINTS);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check attaching default partition fails if a default partition already
-- exists
CREATE TABLE fail_def_part (LIKE part_1 INCLUDING CONSTRAINTS);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check validation when attaching list partitions
CREATE TABLE list_parted2 (
	a int,
	b char
) PARTITION BY LIST (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check that violating rows are correctly reported
CREATE TABLE part_2 (LIKE list_parted2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO part_2 VALUES (3, 'a');
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be ok after deleting the bad row
DELETE FROM part_2;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check partition cannot be attached if default has some row for its values
CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO list_parted2_def VALUES (11, 'z');
ERROR:  cannot execute INSERT in a read-only transaction
CREATE TABLE part_3 (LIKE list_parted2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be ok after deleting the bad row
DELETE FROM list_parted2_def WHERE a = 11;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- adding constraints that describe the desired partition constraint
-- (or more restrictive) will help skip the validation scan
CREATE TABLE part_3_4 (
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IN (3))
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- however, if a list partition does not accept nulls, there should be
-- an explicit NOT NULL constraint on the partition key column for the
-- validation scan to be skipped;
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- adding a NOT NULL constraint will cause the scan to be skipped
ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_3_4 ALTER a SET NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check if default partition scan skipped
ALTER TABLE list_parted2_def ADD CONSTRAINT check_a CHECK (a IN (5, 6));
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check validation when attaching range partitions
CREATE TABLE range_parted (
	a int,
	b int
) PARTITION BY RANGE (a, b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check that violating rows are correctly reported
CREATE TABLE part1 (
	a int NOT NULL CHECK (a = 1),
	b int NOT NULL CHECK (b >= 1 AND b <= 10)
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO part1 VALUES (1, 10);
ERROR:  cannot execute INSERT in a read-only transaction
-- Remember the TO bound is exclusive
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be ok after deleting the bad row
DELETE FROM part1;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- adding constraints that describe the desired partition constraint
-- (or more restrictive) will help skip the validation scan
CREATE TABLE part2 (
	a int NOT NULL CHECK (a = 1),
	b int NOT NULL CHECK (b >= 10 AND b < 18)
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Create default partition
CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT;
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- Only one default partition is allowed, hence, following should give error
CREATE TABLE partr_def2 (LIKE part1 INCLUDING CONSTRAINTS);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Overlapping partitions cannot be attached, hence, following should give error
INSERT INTO partr_def1 VALUES (2, 10);
ERROR:  cannot execute INSERT in a read-only transaction
CREATE TABLE part3 (LIKE range_parted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Attaching partitions should be successful when there are no overlapping rows
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that leaf partitions are scanned when attaching a partitioned
-- table
CREATE TABLE part_5 (
	LIKE list_parted2
) PARTITION BY LIST (b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check that violating rows are correctly reported
CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO part_5_a (a, b) VALUES (6, 'a');
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- delete the faulting row and also add a constraint to skip the scan
DELETE FROM part_5_a WHERE a NOT IN (3);
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 DETACH PARTITION part_5;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_5 DROP CONSTRAINT check_a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- scan should again be skipped, even though NOT NULL is now a column property
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Check the case where attnos of the partitioning columns in the table being
-- attached differs from the parent.  It should not affect the constraint-
-- checking logic that allows to skip the scan.
CREATE TABLE part_6 (
	c int,
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 6)
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE part_6 DROP c;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Similar to above, but the table being attached is a partitioned table
-- whose partition has still different attnos for the root partitioning
-- columns.
CREATE TABLE part_7 (
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
) PARTITION BY LIST (b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE part_7_a_null (
	c int,
	d int,
	e int,
	LIKE list_parted2,  -- 'a' will have attnum = 4
	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'),
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE part_7_a_null DROP c, DROP d, DROP e;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Same example, but check this time that the constraint correctly detects
-- violating rows
ALTER TABLE list_parted2 DETACH PARTITION part_7;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_7 DROP CONSTRAINT check_a; -- thusly, scan won't be skipped
ERROR:  cannot execute ALTER TABLE in a read-only transaction
INSERT INTO part_7 (a, b) VALUES (8, null), (9, 'a');
ERROR:  cannot execute INSERT in a read-only transaction
SELECT tableoid::regclass, a, b FROM part_7 order by a;
   tableoid    | a | b 
---------------+---+---
 part_7_a_null | 8 | 
 part_7_a_null | 9 | a
(2 rows)

ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that leaf partitions of default partition are scanned when
-- attaching a partitioned table.
ALTER TABLE part_5 DROP CONSTRAINT check_a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO part5_def_p1 VALUES (5, 'y');
ERROR:  cannot execute INSERT in a read-only transaction
CREATE TABLE part5_p1 (LIKE part_5);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be ok after deleting the bad row
DELETE FROM part5_def_p1 WHERE b = 'y';
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that the table being attached is not already a partition
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that circular inheritance is not allowed
ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- If a partitioned table being created or an existing table being attached
-- as a partition does not have a constraint that would allow validation scan
-- to be skipped, but an individual partition does, then the partition's
-- validation scan is skipped.
CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE quuux_default1 PARTITION OF quuux_default (
	CONSTRAINT check_1 CHECK (a IS NOT NULL AND a = 1)
) FOR VALUES IN ('b');
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE quuux1 (a int, b text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1); -- validate!
ERROR:  cannot execute ALTER TABLE in a read-only transaction
CREATE TABLE quuux2 (a int, b text);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2); -- skip validation
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE quuux1, quuux2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- should validate for quuux1, but not for quuux2
CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
DROP TABLE quuux;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check validation when attaching hash partitions
-- Use hand-rolled hash functions and operator class to get predictable result
-- on different matchines. part_test_int4_ops is defined in insert.sql.
-- check that the new partition won't overlap with an existing partition
CREATE TABLE hash_parted (
	a int,
	b int
) PARTITION BY HASH (a part_test_int4_ops);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE fail_part (LIKE hpart_1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check validation when attaching hash partitions
-- check that violating rows are correctly reported
CREATE TABLE hpart_2 (LIKE hash_parted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO hpart_2 VALUES (3, 0);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be ok after deleting the bad row
DELETE FROM hpart_2;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that leaf partitions are scanned when attaching a partitioned
-- table
CREATE TABLE hpart_5 (
	LIKE hash_parted
) PARTITION BY LIST (b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
-- check that violating rows are correctly reported
CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO hpart_5_a (a, b) VALUES (7, 1);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be ok after deleting the bad row
DELETE FROM hpart_5_a;
ERROR:  cannot execute DELETE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that the table being attach is with valid modulus and remainder value
CREATE TABLE fail_part(LIKE hash_parted);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE fail_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
--
-- DETACH PARTITION
--
-- check that the table is partitioned at all
CREATE TABLE regular_table (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE regular_table DETACH PARTITION any_name;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE regular_table;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that the partition being detached exists at all
ALTER TABLE list_parted2 DETACH PARTITION part_4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE hash_parted DETACH PARTITION hpart_4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that the partition being detached is actually a partition of the parent
CREATE TABLE not_a_part (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 DETACH PARTITION part_1;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE hash_parted DETACH PARTITION not_a_part;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE not_a_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that, after being detached, attinhcount/coninhcount is dropped to 0 and
-- attislocal/conislocal is set to true
ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT attinhcount, attislocal FROM pg_attribute WHERE attrelid = 'part_3_4'::regclass AND attnum > 0;
 attinhcount | attislocal 
-------------+------------
           0 | t
           0 | t
(2 rows)

SELECT coninhcount, conislocal FROM pg_constraint WHERE conrelid = 'part_3_4'::regclass AND conname = 'check_a';
 coninhcount | conislocal 
-------------+------------
           0 | t
(1 row)

DROP TABLE part_3_4;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that a detached partition is not dropped on dropping a partitioned table
CREATE TABLE range_parted2 (
    a int
) PARTITION BY RANGE(a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE range_parted2 DETACH PARTITION part_rp;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE range_parted2;
ERROR:  cannot execute DROP TABLE in a read-only transaction
SELECT * from part_rp;
 a 
---
(0 rows)

DROP TABLE part_rp;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- Check ALTER TABLE commands for partitioned tables and partitions
-- cannot add/drop column to/from *only* the parent
ALTER TABLE ONLY list_parted2 ADD COLUMN c int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY list_parted2 DROP COLUMN b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- cannot add a column to partition or drop an inherited one
ALTER TABLE part_2 ADD COLUMN c text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_2 DROP COLUMN b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Nor rename, alter type
ALTER TABLE part_2 RENAME COLUMN b to c;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_2 ALTER COLUMN b TYPE text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- cannot add/drop NOT NULL or check constraints to *only* the parent, when
-- partitions exist
ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ALTER b SET NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- It's alright though, if no partitions are yet created
CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE ONLY parted_no_parts ALTER a SET NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY parted_no_parts ADD CONSTRAINT check_a CHECK (a > 0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY parted_no_parts ALTER a DROP NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE ONLY parted_no_parts DROP CONSTRAINT check_a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
DROP TABLE parted_no_parts;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- cannot drop inherited NOT NULL or check constraints from partition
ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_2 ALTER b DROP NOT NULL;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_2 DROP CONSTRAINT check_a2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- Doesn't make sense to add NO INHERIT constraints on partitioned tables
ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- check that a partition cannot participate in regular inheritance
CREATE TABLE inh_test () INHERITS (part_2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
CREATE TABLE inh_test (LIKE part_2);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
ALTER TABLE inh_test INHERIT part_2;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE part_2 INHERIT inh_test;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- cannot drop or alter type of partition key columns of lower level
-- partitioned tables; for example, part_5, which is list_parted2's
-- partition, is partitioned on b;
ALTER TABLE list_parted2 DROP COLUMN b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE list_parted2 ALTER COLUMN b TYPE text;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- dropping non-partition key columns should be allowed on the parent table.
ALTER TABLE list_parted DROP COLUMN b;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
SELECT * FROM list_parted;
 a 
---
(0 rows)

-- cleanup
DROP TABLE list_parted, list_parted2, range_parted;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE fail_def_part;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP TABLE hash_parted;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- more tests for certain multi-level partitioning scenarios
create table p (a int, b int) partition by range (a, b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table p1 (b int, a int not null) partition by range (b);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table p11 (like p1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table p11 drop a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table p11 add a int;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table p11 drop a;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table p11 add a int not null;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- attnum for key attribute 'a' is different in p, p1, and p11
select attrelid::regclass, attname, attnum
from pg_attribute
where attname = 'a'
 and (attrelid = 'p'::regclass
   or attrelid = 'p1'::regclass
   or attrelid = 'p11'::regclass)
order by attrelid::regclass::text;
 attrelid | attname | attnum 
----------+---------+--------
 p        | a       |      1
 p1       | a       |      2
 p11      | a       |      4
(3 rows)

alter table p1 attach partition p11 for values from (2) to (5);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
insert into p1 (a, b) values (2, 3);
ERROR:  cannot execute INSERT in a read-only transaction
-- check that partition validation scan correctly detects violating rows
alter table p attach partition p1 for values from (1, 2) to (1, 10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- cleanup
drop table p;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table p1;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- validate constraint on partitioned tables should only scan leaf partitions
create table parted_validate_test (a int) partition by list (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table parted_validate_test add constraint parted_validate_test_chka check (a > 0) not valid;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table parted_validate_test validate constraint parted_validate_test_chka;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table parted_validate_test;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- test alter column options
CREATE TABLE attmp(i integer);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
INSERT INTO attmp VALUES (1);
ERROR:  cannot execute INSERT in a read-only transaction
ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
ANALYZE attmp;
ERROR:  cannot execute ANALYZE during recovery
DROP TABLE attmp;
ERROR:  cannot execute DROP TABLE in a read-only transaction
DROP USER regress_alter_table_user1;
ERROR:  cannot execute DROP ROLE in a read-only transaction
-- check that violating rows are correctly reported when attaching as the
-- default partition
create table defpart_attach_test (a int) partition by list (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table defpart_attach_test1 partition of defpart_attach_test for values in (1);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table defpart_attach_test_d (like defpart_attach_test);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
insert into defpart_attach_test_d values (1), (2);
ERROR:  cannot execute INSERT in a read-only transaction
-- error because its constraint as the default partition would be violated
-- by the row containing 1
alter table defpart_attach_test attach partition defpart_attach_test_d default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
delete from defpart_attach_test_d where a = 1;
ERROR:  cannot execute DELETE in a read-only transaction
alter table defpart_attach_test_d add check (a > 1);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
-- should be attached successfully and without needing to be scanned
alter table defpart_attach_test attach partition defpart_attach_test_d default;
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table defpart_attach_test;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check combinations of temporary and permanent relations when attaching
-- partitions.
create table perm_part_parent (a int) partition by list (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create temp table temp_part_parent (a int) partition by list (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table perm_part_child (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create temp table temp_part_child (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table temp_part_parent attach partition perm_part_child default; -- error
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table perm_part_parent attach partition temp_part_child default; -- error
ERROR:  cannot execute ALTER TABLE in a read-only transaction
alter table temp_part_parent attach partition temp_part_child default; -- ok
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table perm_part_parent cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop table temp_part_parent cascade;
ERROR:  cannot execute DROP TABLE in a read-only transaction
-- check that attaching partitions to a table while it is being used is
-- prevented
create table tab_part_attach (a int) partition by list (a);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create or replace function func_part_attach() returns trigger
  language plpgsql as $$
  begin
    execute 'create table tab_part_attach_1 (a int)';
    execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
    return null;
  end $$;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
create trigger trig_part_attach before insert on tab_part_attach
  for each statement execute procedure func_part_attach();
ERROR:  cannot execute CREATE TRIGGER in a read-only transaction
insert into tab_part_attach values (1);
ERROR:  cannot execute INSERT in a read-only transaction
drop table tab_part_attach;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop function func_part_attach();
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
-- test case where the partitioning operator is a SQL function whose
-- evaluation results in the table's relcache being rebuilt partway through
-- the execution of an ATTACH PARTITION command
create function at_test_sql_partop (int4, int4) returns int language sql
as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
ERROR:  cannot execute CREATE FUNCTION in a read-only transaction
create operator class at_test_sql_partop for type int4 using btree as
    operator 1 < (int4, int4), operator 2 <= (int4, int4),
    operator 3 = (int4, int4), operator 4 >= (int4, int4),
    operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
ERROR:  cannot execute CREATE OPERATOR CLASS in a read-only transaction
create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
create table at_test_sql_partop_1 (a int);
ERROR:  cannot execute CREATE TABLE in a read-only transaction
alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10);
ERROR:  cannot execute ALTER TABLE in a read-only transaction
drop table at_test_sql_partop;
ERROR:  cannot execute DROP TABLE in a read-only transaction
drop operator class at_test_sql_partop using btree;
ERROR:  cannot execute DROP OPERATOR CLASS in a read-only transaction
drop function at_test_sql_partop;
ERROR:  cannot execute DROP FUNCTION in a read-only transaction
