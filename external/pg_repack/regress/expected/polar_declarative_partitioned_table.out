/*
 * polar_declarative_partitioned_table.sql
 *
 * Test declarative partitioned table because the cases from community
 * only test inherited tables.
 *
 * This case can run in any branch because it doesn't include Oracle grammar and global index
 */
SET ROLE polar_repack_superuser;
CREATE SCHEMA repack_part_schema;
SET search_path TO repack_part_schema;
-- Create partitioned table
CREATE TABLE prt (
    a_int INT PRIMARY KEY,
    b_text TEXT,
    c_varchar VARCHAR(30),
    d_num NUMERIC
) PARTITION BY RANGE (a_int);
-- Create 3 range partitions
CREATE TABLE prt_p_0 PARTITION OF prt FOR VALUES FROM (0) TO (10);
CREATE TABLE prt_p_1 PARTITION OF prt FOR VALUES FROM (10) TO (20);
CREATE TABLE prt_p_2 PARTITION OF prt FOR VALUES FROM (20) TO (30);
-- Create default partition, which is also partitioned
CREATE TABLE prt_p_def PARTITION OF prt DEFAULT PARTITION BY HASH (a_int);
-- Create 3 hash sub-partitions in default partition
CREATE TABLE prt_p_def_p_0 PARTITION OF prt_p_def FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE prt_p_def_p_1 PARTITION OF prt_p_def FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE "prt_p_def_P_2" PARTITION OF prt_p_def FOR VALUES WITH (MODULUS 3, REMAINDER 2);
-- Load data
INSERT INTO prt SELECT i * 10, i, i, i FROM generate_series(0, 9) i;
-- Create indexes
CREATE INDEX prt_idx_btree_a on prt USING btree (a_int);
CREATE INDEX prt_idx_gin_b on prt USING gin (b_text);
CREATE INDEX prt_idx_gist_c on prt USING gist (c_varchar);
CREATE INDEX "prt_idx_HASH_d" on prt USING hash (d_num);
-- show table definition
\d+ prt
                                 Partitioned table "repack_part_schema.prt"
  Column   |         Type          | Collation | Nullable | Default | Storage  | Stats target | Description 
-----------+-----------------------+-----------+----------+---------+----------+--------------+-------------
 a_int     | integer               |           | not null |         | plain    |              | 
 b_text    | text                  |           |          |         | extended |              | 
 c_varchar | character varying(30) |           |          |         | extended |              | 
 d_num     | numeric               |           |          |         | main     |              | 
Partition key: RANGE (a_int)
Indexes:
    "prt_pkey" PRIMARY KEY, btree (a_int)
    "prt_idx_HASH_d" hash (d_num)
    "prt_idx_btree_a" btree (a_int)
    "prt_idx_gin_b" gin (b_text)
    "prt_idx_gist_c" gist (c_varchar)
Partitions: prt_p_0 FOR VALUES FROM (0) TO (10),
            prt_p_1 FOR VALUES FROM (10) TO (20),
            prt_p_2 FOR VALUES FROM (20) TO (30),
            prt_p_def DEFAULT, PARTITIONED

\d+ prt_p_0
                                     Table "repack_part_schema.prt_p_0"
  Column   |         Type          | Collation | Nullable | Default | Storage  | Stats target | Description 
-----------+-----------------------+-----------+----------+---------+----------+--------------+-------------
 a_int     | integer               |           | not null |         | plain    |              | 
 b_text    | text                  |           |          |         | extended |              | 
 c_varchar | character varying(30) |           |          |         | extended |              | 
 d_num     | numeric               |           |          |         | main     |              | 
Partition of: prt FOR VALUES FROM (0) TO (10)
Partition constraint: ((a_int IS NOT NULL) AND (a_int >= 0) AND (a_int < 10))
Indexes:
    "prt_p_0_pkey" PRIMARY KEY, btree (a_int)
    "prt_p_0_a_int_idx" btree (a_int)
    "prt_p_0_b_text_idx" gin (b_text)
    "prt_p_0_c_varchar_idx" gist (c_varchar)
    "prt_p_0_d_num_idx" hash (d_num)

\d+ prt_p_def
                              Partitioned table "repack_part_schema.prt_p_def"
  Column   |         Type          | Collation | Nullable | Default | Storage  | Stats target | Description 
-----------+-----------------------+-----------+----------+---------+----------+--------------+-------------
 a_int     | integer               |           | not null |         | plain    |              | 
 b_text    | text                  |           |          |         | extended |              | 
 c_varchar | character varying(30) |           |          |         | extended |              | 
 d_num     | numeric               |           |          |         | main     |              | 
Partition of: prt DEFAULT
Partition constraint: (NOT ((a_int IS NOT NULL) AND (((a_int >= 0) AND (a_int < 10)) OR ((a_int >= 10) AND (a_int < 20)) OR ((a_int >= 20) AND (a_int < 30)))))
Partition key: HASH (a_int)
Indexes:
    "prt_p_def_pkey" PRIMARY KEY, btree (a_int)
    "prt_p_def_a_int_idx" btree (a_int)
    "prt_p_def_b_text_idx" gin (b_text)
    "prt_p_def_c_varchar_idx" gist (c_varchar)
    "prt_p_def_d_num_idx" hash (d_num)
Partitions: prt_p_def_p_0 FOR VALUES WITH (modulus 3, remainder 0),
            prt_p_def_p_1 FOR VALUES WITH (modulus 3, remainder 1),
            "prt_p_def_P_2" FOR VALUES WITH (modulus 3, remainder 2)

\d prt_p_def_p_0
              Table "repack_part_schema.prt_p_def_p_0"
  Column   |         Type          | Collation | Nullable | Default 
-----------+-----------------------+-----------+----------+---------
 a_int     | integer               |           | not null | 
 b_text    | text                  |           |          | 
 c_varchar | character varying(30) |           |          | 
 d_num     | numeric               |           |          | 
Partition of: prt_p_def FOR VALUES WITH (modulus 3, remainder 0)
Indexes:
    "prt_p_def_p_0_pkey" PRIMARY KEY, btree (a_int)
    "prt_p_def_p_0_a_int_idx" btree (a_int)
    "prt_p_def_p_0_b_text_idx" gin (b_text)
    "prt_p_def_p_0_c_varchar_idx" gist (c_varchar)
    "prt_p_def_p_0_d_num_idx" hash (d_num)

-- Force index scan to prove the index is ok after repacking
SET enable_seqscan TO off;
--
-- 1. Repack partitioned table
--
SELECT count(*) FROM prt;
 count 
-------
    10
(1 row)

--- ERROR, cannot use --table for partitioned table
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt
ERROR: pg_repack failed with error: ERROR:  relation "repack_part_schema.prt" does not exist
--- OK, can only use --parent-table for partitioned table
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt
INFO: repacking table "repack_part_schema.prt_p_0"
INFO: repacking table "repack_part_schema.prt_p_1"
INFO: repacking table "repack_part_schema.prt_p_2"
INFO: repacking table "repack_part_schema.prt_p_def_p_0"
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
INFO: repacking table "repack_part_schema."prt_p_def_P_2""
SELECT count(*) FROM prt;
 count 
-------
    10
(1 row)

--
-- 2. Repack partition
--
SELECT * FROM prt_p_0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

SELECT * FROM prt_p_1;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    10 | 1      | 1         |     1
(1 row)

SELECT * FROM prt_p_2;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    20 | 2      | 2         |     2
(1 row)

--- OK to use --table for partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_0
INFO: repacking table "repack_part_schema.prt_p_0"
--- OK to use --parent-table for partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt_p_0
INFO: repacking table "repack_part_schema.prt_p_0"
--- OK for multi partitions
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_0 --table=repack_part_schema.prt_p_1 --table=repack_part_schema.prt_p_2
INFO: repacking table "repack_part_schema.prt_p_0"
INFO: repacking table "repack_part_schema.prt_p_1"
INFO: repacking table "repack_part_schema.prt_p_2"
SELECT * FROM prt_p_0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

SELECT * FROM prt_p_1;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    10 | 1      | 1         |     1
(1 row)

SELECT * FROM prt_p_2;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    20 | 2      | 2         |     2
(1 row)

-- Scan by index, prove that index is ok after repacking partition
SELECT * FROM prt WHERE a_int = 0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 0;
                    QUERY PLAN                     
---------------------------------------------------
 Index Scan using prt_p_0_a_int_idx on prt_p_0 prt
   Index Cond: (a_int = 0)
(2 rows)

SELECT * FROM prt WHERE b_text = '0';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '0';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '0'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '0';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '0';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '0'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 0;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '0'::numeric)
(13 rows)

--
-- 3. Repack partitioned partition
--
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

--- ERROR, cannot use --table for partitioned partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def
ERROR: pg_repack failed with error: ERROR:  relation "repack_part_schema.prt_p_def" does not exist
--- OK, can only use --parent-table for partitioned partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt_p_def
INFO: repacking table "repack_part_schema.prt_p_def_p_0"
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
INFO: repacking table "repack_part_schema."prt_p_def_P_2""
--- OK, partitioned table and partitioned partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt --parent-table=repack_part_schema.prt_p_def
INFO: repacking table "repack_part_schema.prt_p_0"
INFO: repacking table "repack_part_schema.prt_p_1"
INFO: repacking table "repack_part_schema.prt_p_2"
INFO: repacking table "repack_part_schema.prt_p_def_p_0"
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
INFO: repacking table "repack_part_schema."prt_p_def_P_2""
--- OK, partitioned table and sub-partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt --table=repack_part_schema.prt_p_def_p_1
INFO: repacking table "repack_part_schema.prt_p_0"
INFO: repacking table "repack_part_schema.prt_p_1"
INFO: repacking table "repack_part_schema.prt_p_2"
INFO: repacking table "repack_part_schema.prt_p_def_p_0"
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
INFO: repacking table "repack_part_schema."prt_p_def_P_2""
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

-- Scan by index, prove that index is ok after repacking partitioned partition
SELECT * FROM prt WHERE a_int = 50;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 50;
                          QUERY PLAN                           
---------------------------------------------------------------
 Index Scan using prt_p_def_p_0_a_int_idx on prt_p_def_p_0 prt
   Index Cond: (a_int = 50)
(2 rows)

SELECT * FROM prt WHERE b_text = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '5';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '5'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '5';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '5'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 5;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 5;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '5'::numeric)
(13 rows)

--
-- 4. Repack sub-partition
--
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_1
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt_p_def_p_1
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
--- OK for multi sub-partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table='repack_part_schema."prt_p_def_P_2"'
INFO: repacking table "repack_part_schema.prt_p_def_p_0"
INFO: repacking table "repack_part_schema.prt_p_def_p_1"
INFO: repacking table "repack_part_schema."prt_p_def_P_2""
--- Error, upper case name should be preserved by '' and ""
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table=repack_part_schema.prt_p_def_P_2
ERROR: pg_repack failed with error: ERROR:  relation "repack_part_schema.prt_p_def_P_2" does not exist
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table="repack_part_schema.prt_p_def_P_2"
ERROR: pg_repack failed with error: ERROR:  relation "repack_part_schema.prt_p_def_P_2" does not exist
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table=repack_part_schema."prt_p_def_P_2"
ERROR: pg_repack failed with error: ERROR:  relation "repack_part_schema.prt_p_def_P_2" does not exist
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

-- Scan by index, prove that index is ok after repacking leaf partition
SELECT * FROM prt WHERE a_int = 50;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 50;
                          QUERY PLAN                           
---------------------------------------------------------------
 Index Scan using prt_p_def_p_0_a_int_idx on prt_p_def_p_0 prt
   Index Cond: (a_int = 50)
(2 rows)

SELECT * FROM prt WHERE b_text = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '5';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '5'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '5';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '5'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 5;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 5;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '5'::numeric)
(13 rows)

--
-- 5. Repack index on partitioned table
--
SELECT count(*) FROM prt;
 count 
-------
    10
(1 row)

--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_0"
INFO: repacking index "repack_part_schema.prt_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_0_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_1"
INFO: repacking index "repack_part_schema.prt_p_1_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_1_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_1_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_1_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_1_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_2"
INFO: repacking index "repack_part_schema.prt_p_2_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_2_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_2_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_2_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_2_pkey"
INFO: repacking indexes of "repack_part_schema."prt_p_def_P_2""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_a_int_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_b_text_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_c_varchar_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_d_num_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_pkey""
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_0"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_1"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_pkey"
-- This is not supported and not planned to be supported by community
-- because repacking index is deprecated and should be replaced by REINDEX CONCURRENTLY in PG12+ versions
-- see issue for more details: https://github.com/reorg/pg_repack/issues/389
-- \! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_pkey
SELECT count(*) FROM prt;
 count 
-------
    10
(1 row)

-- Scan by index, prove that index is ok after repacking index on partition
SELECT * FROM prt WHERE a_int = 0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 0;
                    QUERY PLAN                     
---------------------------------------------------
 Index Scan using prt_p_0_a_int_idx on prt_p_0 prt
   Index Cond: (a_int = 0)
(2 rows)

SELECT * FROM prt WHERE b_text = '0';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '0';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '0'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '0';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '0';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '0'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 0;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '0'::numeric)
(13 rows)

--
-- 6. Repack index on partition
--
SELECT count(*) FROM prt_p_0;
 count 
-------
     1
(1 row)

--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_0 --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_0"
INFO: repacking index "repack_part_schema.prt_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_0_pkey"
--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt_p_0 --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_0"
INFO: repacking index "repack_part_schema.prt_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_0_pkey"
--- OK for multi partitions
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_0 --table=repack_part_schema.prt_p_1 --table=repack_part_schema.prt_p_2 --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_0"
INFO: repacking index "repack_part_schema.prt_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_0_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_1"
INFO: repacking index "repack_part_schema.prt_p_1_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_1_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_1_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_1_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_1_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_2"
INFO: repacking index "repack_part_schema.prt_p_2_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_2_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_2_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_2_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_2_pkey"
--- OK for primary key index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_0_pkey
INFO: repacking index "repack_part_schema.prt_p_0_pkey"
--- OK for btree index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_0_a_int_idx
INFO: repacking index "repack_part_schema.prt_p_0_a_int_idx"
--- OK for gin index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_0_b_text_idx
INFO: repacking index "repack_part_schema.prt_p_0_b_text_idx"
--- OK for gist index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_0_c_varchar_idx
INFO: repacking index "repack_part_schema.prt_p_0_c_varchar_idx"
--- OK for multi index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_0_pkey --index=repack_part_schema.prt_p_0_a_int_idx --index=repack_part_schema.prt_p_0_b_text_idx --index=repack_part_schema.prt_p_0_c_varchar_idx
INFO: repacking index "repack_part_schema.prt_p_0_pkey"
INFO: repacking index "repack_part_schema.prt_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_0_c_varchar_idx"
SELECT count(*) FROM prt_p_0;
 count 
-------
     1
(1 row)

-- Scan by index, prove that index is ok after repacking index on partition
SELECT * FROM prt WHERE a_int = 0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 0;
                    QUERY PLAN                     
---------------------------------------------------
 Index Scan using prt_p_0_a_int_idx on prt_p_0 prt
   Index Cond: (a_int = 0)
(2 rows)

SELECT * FROM prt WHERE b_text = '0';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '0';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '0'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '0'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '0'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '0';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '0';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '0'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '0'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 0;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
     0 | 0      | 0         |     0
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 0;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '0'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '0'::numeric)
(13 rows)

--
-- 7. Repack index on partitioned partition
--
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt_p_def --only-indexes
INFO: repacking indexes of "repack_part_schema."prt_p_def_P_2""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_a_int_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_b_text_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_c_varchar_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_d_num_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_pkey""
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_0"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_1"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_pkey"
-- This is not supported and not planned to be supported by community
-- because repacking index is deprecated and should be replaced by REINDEX CONCURRENTLY in PG12+ versions
-- see issue for more details: https://github.com/reorg/pg_repack/issues/389
-- \! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_def_pkey
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

-- Scan by index, prove that index is ok after repacking index on partitioned partition
SELECT * FROM prt WHERE a_int = 50;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 50;
                          QUERY PLAN                           
---------------------------------------------------------------
 Index Scan using prt_p_def_p_0_a_int_idx on prt_p_def_p_0 prt
   Index Cond: (a_int = 50)
(2 rows)

SELECT * FROM prt WHERE b_text = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '5';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '5'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '5';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '5'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 5;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 5;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '5'::numeric)
(13 rows)

--
-- 8. Repack index on sub-partition
--
SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_0"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
--- OK
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --parent-table=repack_part_schema.prt_p_def_p_0 --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_0"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
--- OK for multi sub-partition
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table='repack_part_schema."prt_p_def_P_2"' --only-indexes
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_0"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
INFO: repacking indexes of "repack_part_schema.prt_p_def_p_1"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_c_varchar_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_d_num_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_1_pkey"
INFO: repacking indexes of "repack_part_schema."prt_p_def_P_2""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_a_int_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_b_text_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_c_varchar_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_d_num_idx""
INFO: repacking index "repack_part_schema."prt_p_def_P_2_pkey""
--- Error, upper case name should be preserved by '' and ""
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table=repack_part_schema.prt_p_def_P_2 --only-indexes
ERROR: ERROR:  relation "repack_part_schema.prt_p_def_P_2" does not exist
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table="repack_part_schema.prt_p_def_P_2" --only-indexes
ERROR: ERROR:  relation "repack_part_schema.prt_p_def_P_2" does not exist
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --table=repack_part_schema.prt_p_def_p_0 --table=repack_part_schema.prt_p_def_p_1 --table=repack_part_schema."prt_p_def_P_2" --only-indexes
ERROR: ERROR:  relation "repack_part_schema.prt_p_def_P_2" does not exist
--- OK for primary key index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_def_p_0_pkey
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
--- OK for btree index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_def_p_0_a_int_idx
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
--- OK for gin index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_def_p_0_b_text_idx
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
--- OK for gist index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_def_p_0_c_varchar_idx
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
--- OK for multi index
\! pg_repack -T 3600 -k -U polar_repack_superuser --dbname=contrib_regression_pg_repack --index=repack_part_schema.prt_p_def_p_0_pkey --index=repack_part_schema.prt_p_def_p_0_a_int_idx --index=repack_part_schema.prt_p_def_p_0_b_text_idx --index=repack_part_schema.prt_p_def_p_0_c_varchar_idx
INFO: repacking index "repack_part_schema.prt_p_def_p_0_pkey"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_a_int_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_b_text_idx"
INFO: repacking index "repack_part_schema.prt_p_def_p_0_c_varchar_idx"
-- Scan by index, prove that index is ok after repacking index on leaf partition
SELECT * FROM prt WHERE a_int = 50;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE a_int = 50;
                          QUERY PLAN                           
---------------------------------------------------------------
 Index Scan using prt_p_def_p_0_a_int_idx on prt_p_def_p_0 prt
   Index Cond: (a_int = 50)
(2 rows)

SELECT * FROM prt WHERE b_text = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE b_text = '5';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Bitmap Heap Scan on prt_p_0 prt_1
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_1 prt_2
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_2 prt_3
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_2_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_0 prt_4
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_0_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on prt_p_def_p_1 prt_5
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on prt_p_def_p_1_b_text_idx
               Index Cond: (b_text = '5'::text)
   ->  Bitmap Heap Scan on "prt_p_def_P_2" prt_6
         Recheck Cond: (b_text = '5'::text)
         ->  Bitmap Index Scan on "prt_p_def_P_2_b_text_idx"
               Index Cond: (b_text = '5'::text)
(25 rows)

SELECT * FROM prt WHERE c_varchar = '5';
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE c_varchar = '5';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_c_varchar_idx on prt_p_0 prt_1
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_1_c_varchar_idx on prt_p_1 prt_2
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_2_c_varchar_idx on prt_p_2 prt_3
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_0_c_varchar_idx on prt_p_def_p_0 prt_4
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using prt_p_def_p_1_c_varchar_idx on prt_p_def_p_1 prt_5
         Index Cond: ((c_varchar)::text = '5'::text)
   ->  Index Scan using "prt_p_def_P_2_c_varchar_idx" on "prt_p_def_P_2" prt_6
         Index Cond: ((c_varchar)::text = '5'::text)
(13 rows)

SELECT * FROM prt WHERE d_num = 5;
 a_int | b_text | c_varchar | d_num 
-------+--------+-----------+-------
    50 | 5      | 5         |     5
(1 row)

EXPLAIN (COSTS off) SELECT * FROM prt WHERE d_num = 5;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Index Scan using prt_p_0_d_num_idx on prt_p_0 prt_1
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_1_d_num_idx on prt_p_1 prt_2
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_2_d_num_idx on prt_p_2 prt_3
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_0_d_num_idx on prt_p_def_p_0 prt_4
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using prt_p_def_p_1_d_num_idx on prt_p_def_p_1 prt_5
         Index Cond: (d_num = '5'::numeric)
   ->  Index Scan using "prt_p_def_P_2_d_num_idx" on "prt_p_def_P_2" prt_6
         Index Cond: (d_num = '5'::numeric)
(13 rows)

SELECT count(*) FROM prt_p_def;
 count 
-------
     7
(1 row)

RESET search_path;
