import{_ as k,c as i,a as n,b as a,e as d,w as e,r as t,o as u,d as o}from"./app-HZE5kvva.js";const m={},w={class:"table-of-contents"};function y(l,s){const c=t("Badge"),r=t("ArticleInfo"),p=t("router-link");return u(),i("div",null,[s[4]||(s[4]=n("h1",{id:"epq-计算节点范围选择与并行度控制",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#epq-计算节点范围选择与并行度控制"},[n("span",null,"ePQ 计算节点范围选择与并行度控制")])],-1)),a(c,{type:"tip",text:"V11 / v1.1.20-",vertical:"top"}),a(r,{frontmatter:l.$frontmatter},null,8,["frontmatter"]),n("nav",w,[n("ul",null,[n("li",null,[a(p,{to:"#背景介绍"},{default:e(()=>s[0]||(s[0]=[o("背景介绍")])),_:1})]),n("li",null,[a(p,{to:"#计算节点范围选择"},{default:e(()=>s[1]||(s[1]=[o("计算节点范围选择")])),_:1})]),n("li",null,[a(p,{to:"#并行度控制"},{default:e(()=>s[2]||(s[2]=[o("并行度控制")])),_:1})]),n("li",null,[a(p,{to:"#并行度计算方法示例"},{default:e(()=>s[3]||(s[3]=[o("并行度计算方法示例")])),_:1})])])]),s[5]||(s[5]=d(`<h2 id="背景介绍" tabindex="-1"><a class="header-anchor" href="#背景介绍"><span>背景介绍</span></a></h2><p>PolarDB-PG 的 ePQ 弹性跨机并行查询特性提供了精细的粒度控制方法，可以合理使用集群内的计算资源。在最大程度利用闲置计算资源进行并行查询，提升资源利用率的同时，避免了对其它业务负载产生影响：</p><ol><li>ePQ 可以动态调整集群中参与并行查询的计算节点范围，避免使用负载较高的计算节点</li><li>ePQ 支持为每条查询动态调整在计算节点上的并行度，避免 ePQ 并行查询进程对计算资源的消耗影响到相同节点上的其它进程</li></ol><h2 id="计算节点范围选择" tabindex="-1"><a class="header-anchor" href="#计算节点范围选择"><span>计算节点范围选择</span></a></h2><p>参数 <code>polar_px_nodes</code> 指定了参与 ePQ 的计算节点范围，默认值为空，表示所有只读节点都参与 ePQ 并行查询：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_nodes<span class="token punctuation">;</span></span>
<span class="line"> polar_px_nodes</span>
<span class="line"><span class="token comment">----------------</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre></div><p>如果希望读写节点也参与 ePQ 并行，则可以设置如下参数：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SET</span> polar_px_use_primary <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>如果部分只读节点负载较高，则可以通过修改 <code>polar_px_nodes</code> 参数设置仅特定几个而非所有只读节点参与 ePQ 并行查询。参数 <code>polar_px_nodes</code> 的合法格式是一个以英文逗号分隔的节点名称列表。获取节点名称需要安装 <code>polar_monitor</code> 插件：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> EXTENSION <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> polar_monitor<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>通过 <code>polar_monitor</code> 插件提供的集群拓扑视图，可以查询到集群中所有计算节点的名称：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>slot_name<span class="token punctuation">,</span><span class="token keyword">type</span> <span class="token keyword">FROM</span> polar_cluster_info<span class="token punctuation">;</span></span>
<span class="line"> name  <span class="token operator">|</span> slot_name <span class="token operator">|</span>  <span class="token keyword">type</span></span>
<span class="line"><span class="token comment">-------+-----------+---------</span></span>
<span class="line"> node0 <span class="token operator">|</span>           <span class="token operator">|</span> <span class="token keyword">Primary</span></span>
<span class="line"> node1 <span class="token operator">|</span> standby1  <span class="token operator">|</span> Standby</span>
<span class="line"> node2 <span class="token operator">|</span> replica1  <span class="token operator">|</span> Replica</span>
<span class="line"> node3 <span class="token operator">|</span> replica2  <span class="token operator">|</span> Replica</span>
<span class="line"><span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">rows</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre></div><p>其中：</p><ul><li><code>Primary</code> 表示读写节点</li><li><code>Replica</code> 表示只读节点</li><li><code>Standby</code> 表示备库节点</li></ul><p>通用的最佳实践是使用负载较低的只读节点参与 ePQ 并行查询：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_px_nodes <span class="token operator">=</span> <span class="token string">&#39;node2,node3&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_nodes<span class="token punctuation">;</span></span>
<span class="line"> polar_px_nodes</span>
<span class="line"><span class="token comment">----------------</span></span>
<span class="line"> node2<span class="token punctuation">,</span>node3</span>
<span class="line"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre></div><h2 id="并行度控制" tabindex="-1"><a class="header-anchor" href="#并行度控制"><span>并行度控制</span></a></h2><p>参数 <code>polar_px_dop_per_node</code> 用于设置当前会话中的 ePQ 查询在每个计算节点上的执行单元（Segment）数量，每个执行单元会为其需要执行的每一个计划分片（Slice）启动一个进程。</p><p>该参数默认值为 <code>3</code>，通用最佳实践值为当前计算节点 CPU 核心数的一半。如果计算节点的 CPU 负载较高，可以酌情递减该参数，控制计算节点的 CPU 占用率至 80% 以下；如果查询性能不佳时，可以酌情递增该参数，也需要保持计算节点的 CPU 水位不高于 80%。否则可能会拖慢其它的后台进程。</p><h2 id="并行度计算方法示例" tabindex="-1"><a class="header-anchor" href="#并行度计算方法示例"><span>并行度计算方法示例</span></a></h2><p>创建一张表：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>假设集群内有两个只读节点，<code>polar_px_nodes</code> 为空，此时 ePQ 将使用集群内的所有只读节点参与并行查询；参数 <code>polar_px_dop_per_node</code> 的值为 <code>3</code>，表示每个计算节点上将会有三个执行单元。执行计划如下：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_nodes<span class="token punctuation">;</span></span>
<span class="line"> polar_px_nodes</span>
<span class="line"><span class="token comment">----------------</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_dop_per_node<span class="token punctuation">;</span></span>
<span class="line"> polar_px_dop_per_node</span>
<span class="line"><span class="token comment">-----------------------</span></span>
<span class="line"> <span class="token number">3</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span></span>
<span class="line">                                  QUERY <span class="token keyword">PLAN</span></span>
<span class="line"><span class="token comment">-------------------------------------------------------------------------------</span></span>
<span class="line"> PX Coordinator <span class="token number">6</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">6</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line">   <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line"> Optimizer: PolarDB PX Optimizer</span>
<span class="line"><span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">rows</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre></div><p>从执行计划中可以看出，两个只读节点上总计有六个执行单元（<code>segments: 6</code>）将会执行这个计划中唯一的计划分片 <code>slice1</code>。这意味着总计会有六个进程并行执行当前查询。</p><p>此时，调整 <code>polar_px_dop_per_node</code> 为 <code>4</code>，再次执行查询，两个只读节点上总计会有八个执行单元参与当前查询。由于执行计划中只有一个计划分片 <code>slice1</code>，这意味着总计会有八个进程并行执行当前查询：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_px_dop_per_node <span class="token keyword">TO</span> <span class="token number">4</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SET</span></span>
<span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span></span>
<span class="line">                                  QUERY <span class="token keyword">PLAN</span></span>
<span class="line"><span class="token comment">-------------------------------------------------------------------------------</span></span>
<span class="line"> PX Coordinator <span class="token number">8</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">8</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line">   <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line"> Optimizer: PolarDB PX Optimizer</span>
<span class="line"><span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">rows</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre></div><p>此时，如果设置 <code>polar_px_use_primary</code> 参数，让读写节点也参与查询，那么读写节点上也将会有四个执行单元参与 ePQ 并行执行，集群内总计 12 个进程参与并行执行：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_px_use_primary <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SET</span></span>
<span class="line"><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span></span>
<span class="line">                                   QUERY <span class="token keyword">PLAN</span></span>
<span class="line"><span class="token comment">---------------------------------------------------------------------------------</span></span>
<span class="line"> PX Coordinator <span class="token number">12</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">12</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line">   <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line"> Optimizer: PolarDB PX Optimizer</span>
<span class="line"><span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">rows</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre></div>`,29))])}const g=k(m,[["render",y]]),h=JSON.parse('{"path":"/zh/features/epq/epq-node-and-dop.html","title":"ePQ 计算节点范围选择与并行度控制","lang":"zh-CN","frontmatter":{"author":"渊云","date":"2023/09/06","minute":20},"headers":[{"level":2,"title":"背景介绍","slug":"背景介绍","link":"#背景介绍","children":[]},{"level":2,"title":"计算节点范围选择","slug":"计算节点范围选择","link":"#计算节点范围选择","children":[]},{"level":2,"title":"并行度控制","slug":"并行度控制","link":"#并行度控制","children":[]},{"level":2,"title":"并行度计算方法示例","slug":"并行度计算方法示例","link":"#并行度计算方法示例","children":[]}],"git":{"updatedTime":1760793941000,"contributors":[{"name":"aCoder2013","username":"aCoder2013","email":"7877752+aCoder2013@users.noreply.github.com","commits":1,"url":"https://github.com/aCoder2013"}],"changelog":[{"hash":"6fcfdc2993a4b32b3c1c8119b43c3545d6ab9654","time":1760793941000,"email":"7877752+aCoder2013@users.noreply.github.com","author":"acoder2014","message":"fix: typo in arch-overview.md (#608)"}]},"filePathRelative":"zh/features/epq/epq-node-and-dop.md"}');export{g as comp,h as data};
