import{_ as p,c,a as l,b as o,e as m,w as n,r as a,o as g,d as i}from"./app-HZE5kvva.js";const u="/PolarDB-for-PostgreSQL/assets/online_promote_postmaster-C4ViJDEx.png",P="/PolarDB-for-PostgreSQL/assets/online_promote_startup-DirLTg8T.png",L="/PolarDB-for-PostgreSQL/assets/online_promote_logindex_bgw-D8AmDDQh.png",h={},_={class:"table-of-contents"};function O(r,e){const s=a("Badge"),d=a("ArticleInfo"),t=a("router-link");return g(),c("div",null,[e[8]||(e[8]=l("h1",{id:"只读节点-online-promote",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#只读节点-online-promote"},[l("span",null,"只读节点 Online Promote")])],-1)),o(s,{type:"tip",text:"V11 / v1.1.1-",vertical:"top"}),o(d,{frontmatter:r.$frontmatter},null,8,["frontmatter"]),l("nav",_,[l("ul",null,[l("li",null,[o(t,{to:"#背景"},{default:n(()=>e[0]||(e[0]=[i("背景")])),_:1})]),l("li",null,[o(t,{to:"#使用"},{default:n(()=>e[1]||(e[1]=[i("使用")])),_:1})]),l("li",null,[o(t,{to:"#onlinepromote-原理"},{default:n(()=>e[2]||(e[2]=[i("OnlinePromote 原理")])),_:1}),l("ul",null,[l("li",null,[o(t,{to:"#触发机制"},{default:n(()=>e[3]||(e[3]=[i("触发机制")])),_:1})]),l("li",null,[o(t,{to:"#postmaster-进程处理过程"},{default:n(()=>e[4]||(e[4]=[i("Postmaster 进程处理过程")])),_:1})]),l("li",null,[o(t,{to:"#startup-进程处理过程"},{default:n(()=>e[5]||(e[5]=[i("Startup 进程处理过程")])),_:1})]),l("li",null,[o(t,{to:"#logindex-bgw-进程处理过程"},{default:n(()=>e[6]||(e[6]=[i("LogIndex BGW 进程处理过程")])),_:1})]),l("li",null,[o(t,{to:"#刷脏控制"},{default:n(()=>e[7]||(e[7]=[i("刷脏控制")])),_:1})])])])])]),e[9]||(e[9]=m(`<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p>PolarDB 是基于共享存储的一写多读架构，与传统数据库的主备架构有所不同：</p><ul><li><strong>Standby 节点</strong>，是传统数据库的备库节点，有独立的存储，与主库节点之间通过传输完整的 WAL 日志来同步数据；</li><li><strong>只读节点</strong>，也称为 <strong>Replica 节点</strong>，是 PolarDB 数据库的只读备库节点，与主节点共享同一份存储，与主库节点之间通过传输 WAL Meta 日志信息来同步数据。</li></ul><p>传统数据库支持 Standby 节点升级为主库节点的 Promote 操作，在不重启的情况下，提升备库节点为主库节点，继续提供读写服务，保证集群高可用的同时，也有效降低了实例的恢复时间 RTO。</p><p>PolarDB 同样需要只读备库节点提升为主库节点的 Promote 能力，鉴于只读节点与传统数据库 Standby 节点的不同，PolarDB 提出了一种一写多读架构下只读节点的 OnlinePromote 机制。</p><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h2><p>使用 <code>pg_ctl</code> 工具对 Replica 节点执行 Promote 操作：</p><div class="language-bash" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line">pg_ctl promote <span class="token parameter variable">-D</span> <span class="token punctuation">[</span>datadir<span class="token punctuation">]</span></span>
<span class="line"></span></code></pre></div><h2 id="onlinepromote-原理" tabindex="-1"><a class="header-anchor" href="#onlinepromote-原理"><span>OnlinePromote 原理</span></a></h2><h3 id="触发机制" tabindex="-1"><a class="header-anchor" href="#触发机制"><span>触发机制</span></a></h3><p>PolarDB 使用和传统数据库一致的备库节点 Promote 方法，触发条件如下：</p><ul><li>调用 <code>pg_ctl</code> 工具的 Promote 命令，<code>pg_ctl</code> 工具会向 Postmaster 进程发送信号，接收到信号的 Postmaster 进程再通知其他进程执行相应的操作，完成整个 Promote 操作。</li><li>在 <code>recovery.conf</code> 中定义 trigger file 的路径，其他组件通过生成 trigger file 来触发。</li></ul><p>相比于传统数据库 Standby 节点的 Promote 操作，PolarDB Replica 节点的 OnlinePromote 操作需要多考虑以下几个问题：</p><ul><li>Replica 节点 OnlinePromote 为主库节点后，需要以读写模式重新挂载共享存储；</li><li>Replica 节点会在内存中维护一些重要的控制信息，这些控制信息在主库节点上会被持久化到共享存储中。Promote 过程中，这部分信息也需要持久化到共享存储；</li><li>Replica 节点在内存中通过日志回放得到的数据信息，在 OnlinePromote 的过程中需要确认哪些数据可以写入共享存储；</li><li>Replica 节点在内存中回放 WAL 日志时，缓冲区淘汰方法和不刷脏的特性与主库节点截然不同，OnlinePromote 过程中应该如何处理；</li><li>Replica 节点 OnlinePromote 过程中，各个子进程的处理过程。</li></ul><h3 id="postmaster-进程处理过程" tabindex="-1"><a class="header-anchor" href="#postmaster-进程处理过程"><span>Postmaster 进程处理过程</span></a></h3><ol><li>Postmaster 进程发现 trigger file 文件或者接收到 OnlinePromote 命令后，进入 OnlinePromote 的处理流程；</li><li>发送 <code>SIGTERM</code> 信号给当前所有 Backend 进程。 <ul><li>只读节点在 OnlinePromote 过程中可以继续提供只读服务，但是只读的数据不能保证是最新的。为了避免切换过程中从新的主库节点读到旧的数据，这里先将所有的 Backend 会话断开，等 Startup 进程退出后再开始对外提供读写服务。</li></ul></li><li>重新以 <strong>读写模式</strong> 挂载共享存储，需要底层存储提供相应的功能支持；</li><li>发送 <code>SIGUSR2</code> 信号给 <strong>Startup 进程</strong>，通知其结束回放并处理 OnlinePromote 操作；</li><li>发送 <code>SIGUSR2</code> 信号给 <strong>Polar Worker 辅助进程</strong>，通知其停止对于部分 LogIndex 数据的解析，因为这部分 LogIndex 数据只对于正常运行期间的 Replica 节点有用处。</li><li>发送 <code>SIGUSR2</code> 信号给 <strong>LogIndex BGW (Background Ground Worker) 后台回放进程</strong>，通知其处理 OnlinePromote 操作。</li></ol><p><img src="`+u+'" alt="image.png"></p><h3 id="startup-进程处理过程" tabindex="-1"><a class="header-anchor" href="#startup-进程处理过程"><span>Startup 进程处理过程</span></a></h3><ol><li>Startup 进程回放完所有旧主库节点产生的 WAL 日志，生成相应的 LogIndex 数据；</li><li>确认旧主库节点最后一次的 checkpoint 在 Replica 节点也完成，目的是确保对应的 checkpoint 应该在 Replica 节点本地写入的数据落盘完毕；</li><li>等待确认 LogIndex BGW 进程进入 <code>POLAR_BG_WAITING_RESET</code> 状态；</li><li>将 Replica 节点本地的数据（如 clog 等）拷贝到共享存储中；</li><li>重置 WAL Meta Queue 内存空间，从共享存储中重新加载 slot 信息，并重新设置 LogIndex BGW 进程的回放位点为其与当前一致性位点两者的最小值，表示接下来 LogIndex BGW 进程从该位点开始新的回放；</li><li>将节点角色设置为主库节点，并设置 LogIndex BGW 进程的状态为 <code>POLAR_BG_ONLINE_PROMOTE</code>，至此实例可以对外提供读写服务。</li></ol><p><img src="'+P+'" alt="image.png"></p><h3 id="logindex-bgw-进程处理过程" tabindex="-1"><a class="header-anchor" href="#logindex-bgw-进程处理过程"><span>LogIndex BGW 进程处理过程</span></a></h3><p>LogIndex BGW 进程有自己的状态机，在其生命周期内，一直按照该状态机运行，具体每个状态机的操作内容如下：</p><ul><li><code>POLAR_BG_WAITING_RESET</code>：LogIndex BGW 进程状态重置，通知其他进程状态机发生变化；</li><li><code>POLAR_BG_ONLINE_PROMOTE</code>：读取 LogIndex 数据，组织并分发回放任务，利用并行回放进程组回放 WAL 日志，该状态的进程需要回放完所有的 LogIndex 数据才会进行状态切换，最后推进后台回放进程的回放位点；</li><li><code>POLAR_BG_REDO_NOT_START</code>：表示回放任务结束；</li><li><code>POLAR_BG_RO_BUF_REPLAYING</code>：Replica 节点正常运行时，进程处于该状态，读取 LogIndex 数据，按照 WAL 日志的顺序回放一定量的 WAL 日志，每回放一轮，便会推进后台回放进程的回放位点；</li><li><code>POLAR_BG_PARALLEL_REPLAYING</code>：LogIndex BGW 进程每次读取一定量的 LogIndex 数据，组织并分发回放任务，利用并行回放进程组回放 WAL 日志，每回放一轮，便会推进后台回放进程的回放位点。</li></ul><p><img src="'+L+'" alt="image.png"></p><p>LogIndex BGW 进程接收到 Postmaster 的 <code>SIGUSR2</code> 信号后，执行 OnlinePromote 操作的流程如下：</p><ol><li>将所有的 LogIndex 数据落盘，并切换状态为 <code>POLAR_BG_WAITING_RESET</code>；</li><li>等待 Startup 进程将其切换为 <code>POLAR_BG_ONLINE_PROMOTE</code> 状态； <ul><li>Replica 节点在执行 OnlinePromote 操作前，后台回放进程只回放在 buffer pool 中的页面；</li><li>Replica 节点处于 OnlinePromote 过程中时，鉴于之前主库节点可能有部分页面在内存中，未来得及落盘，所以后台回放进程按照日志顺序回放所有的 WAL 日志，并在回放后调用 <code>MarkBufferDirty</code> 标记该页面为脏页，等待刷脏；</li><li>回放结束后，推进后台回放进程的回放位点，然后切换状态为 <code>POLAR_BG_REDO_NOT_START</code>。</li></ul></li></ol><h3 id="刷脏控制" tabindex="-1"><a class="header-anchor" href="#刷脏控制"><span>刷脏控制</span></a></h3><p>每个脏页都带有一个 Oldest LSN，该 LSN 在 FlushList 里是有序的，目的是通过这个 LSN 来确定一致性位点。</p><p>Replica 节点在 OnlinePromote 过程后，由于同时存在着回放和新的页面写入，如果像主库节点一样，直接将当前的 WAL 日志插入位点设为 Buffer 的 Oldest LSN，可能会导致：比它小的 Buffer 还未落盘，但新的一致性位点已经被设置。</p><p>所以 Replica 节点在 OnlinePromote 过程中需要面对两个问题：</p><ul><li>旧主库节点的 WAL 日志回放时，如何给脏页设置 Oldest LSN；</li><li>新主库节点产生的脏页如何设置 Oldest LSN；</li></ul><p>PolarDB 在 Replica 节点 OnlinePromote 的过程中，将上述两类情况产生的脏页的 Oldest LSN 都设置为 LogIndex BGW 进程推进的回放位点。只有当标记为相同 Oldest LSN 的 Buffer 都落盘了，才将一致性位点向前推进。</p>',32))])}const R=p(h,[["render",O]]),B=JSON.parse('{"path":"/zh/features/availability/avail-online-promote.html","title":"只读节点 Online Promote","lang":"zh-CN","frontmatter":{"author":"学弈","date":"2022/09/20","minute":25},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":2,"title":"OnlinePromote 原理","slug":"onlinepromote-原理","link":"#onlinepromote-原理","children":[{"level":3,"title":"触发机制","slug":"触发机制","link":"#触发机制","children":[]},{"level":3,"title":"Postmaster 进程处理过程","slug":"postmaster-进程处理过程","link":"#postmaster-进程处理过程","children":[]},{"level":3,"title":"Startup 进程处理过程","slug":"startup-进程处理过程","link":"#startup-进程处理过程","children":[]},{"level":3,"title":"LogIndex BGW 进程处理过程","slug":"logindex-bgw-进程处理过程","link":"#logindex-bgw-进程处理过程","children":[]},{"level":3,"title":"刷脏控制","slug":"刷脏控制","link":"#刷脏控制","children":[]}]}],"git":{"updatedTime":1760793941000,"contributors":[{"name":"aCoder2013","username":"aCoder2013","email":"7877752+aCoder2013@users.noreply.github.com","commits":1,"url":"https://github.com/aCoder2013"}],"changelog":[{"hash":"6fcfdc2993a4b32b3c1c8119b43c3545d6ab9654","time":1760793941000,"email":"7877752+aCoder2013@users.noreply.github.com","author":"acoder2014","message":"fix: typo in arch-overview.md (#608)"}]},"filePathRelative":"zh/features/availability/avail-online-promote.md"}');export{R as comp,B as data};
