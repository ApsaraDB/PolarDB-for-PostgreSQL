import{_ as r,c as i,a,b as n,e as d,w as p,r as o,o as k,d as t}from"./app-HZE5kvva.js";const u={},g={class:"table-of-contents"};function h(l,s){const c=o("ArticleInfo"),e=o("router-link");return k(),i("div",null,[s[6]||(s[6]=a("h1",{id:"cpu-使用率高的排查方法",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#cpu-使用率高的排查方法"},[a("span",null,"CPU 使用率高的排查方法")])],-1)),n(c,{frontmatter:l.$frontmatter},null,8,["frontmatter"]),s[7]||(s[7]=a("p",null,"在 PolarDB for PostgreSQL 的使用过程中，可能会出现 CPU 使用率异常升高甚至达到满载的情况。本文将介绍造成这种情况的常见原因和排查方法，以及相应的解决方案。",-1)),a("nav",g,[a("ul",null,[a("li",null,[n(e,{to:"#业务量上涨"},{default:p(()=>s[0]||(s[0]=[t("业务量上涨")])),_:1})]),a("li",null,[n(e,{to:"#慢查询"},{default:p(()=>s[1]||(s[1]=[t("慢查询")])),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#定位执行时间较长的慢查询"},{default:p(()=>s[2]||(s[2]=[t("定位执行时间较长的慢查询")])),_:1})]),a("li",null,[n(e,{to:"#定位读取-buffer-数量较多的慢查询"},{default:p(()=>s[3]||(s[3]=[t("定位读取 Buffer 数量较多的慢查询")])),_:1})]),a("li",null,[n(e,{to:"#定位长时间执行不结束的慢查询"},{default:p(()=>s[4]||(s[4]=[t("定位长时间执行不结束的慢查询")])),_:1})]),a("li",null,[n(e,{to:"#解决方法与优化思路"},{default:p(()=>s[5]||(s[5]=[t("解决方法与优化思路")])),_:1})])])])])]),s[8]||(s[8]=d(`<h2 id="业务量上涨" tabindex="-1"><a class="header-anchor" href="#业务量上涨"><span>业务量上涨</span></a></h2><p>当 CPU 使用率上升时，最有可能的情况是业务量的上涨导致数据库使用的计算资源增多。所以首先需要排查目前数据库的活跃连接数是否比平时高很多。如果数据库配备了监控系统，那么活跃连接数的变化情况可以通过图表的形式观察到；否则可以直接连接到数据库，执行如下 SQL 来获取当前活跃连接数：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> pg_stat_activity <span class="token keyword">WHERE</span> state <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">&#39;idle&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p><code>pg_stat_activity</code> 是 PostgreSQL 的内置系统视图，该视图返回的每一行都是一个正在运行中的 PostgreSQL 进程，<code>state</code> 列表示进程当前的状态。该列可能的取值为：</p><ul><li><code>active</code>：进程正在执行查询</li><li><code>idle</code>：进程空闲，正在等待新的客户端命令</li><li><code>idle in transaction</code>：进程处于事务中，但目前暂未执行查询</li><li><code>idle in transaction (aborted)</code>：进程处于事务中，且有一条语句发生过错误</li><li><code>fastpath function call</code>：进程正在执行一个 fast-path 函数</li><li><code>disabled</code>：进程的状态采集功能被关闭</li></ul><p>上述 SQL 能够查询到所有非空闲状态的进程数，即可能占用 CPU 的活跃连接数。如果活跃连接数较平时更多，则 CPU 使用率的上升是符合预期的。</p><h2 id="慢查询" tabindex="-1"><a class="header-anchor" href="#慢查询"><span>慢查询</span></a></h2><p>如果 CPU 使用率上升，而活跃连接数的变化范围处在正常范围内，那么有可能出现了较多性能较差的慢查询。这些慢查询可能在很长一段时间里占用了较多的 CPU，导致 CPU 使用率上升。PostgreSQL 提供了慢查询日志的功能，执行时间高于 <code>log_min_duration_statement</code> 的 SQL 将会被记录到慢查询日志中。然而当 CPU 占用率接近满载时，将会导致整个系统的停滞，所有 SQL 的执行可能都会慢下来，所以慢查询日志中记录的信息可能非常多，并不容易排查。</p><h3 id="定位执行时间较长的慢查询" tabindex="-1"><a class="header-anchor" href="#定位执行时间较长的慢查询"><span>定位执行时间较长的慢查询</span></a></h3><p><a href="https://www.postgresql.org/docs/15/pgstatstatements.html" target="_blank" rel="noopener noreferrer"><code>pg_stat_statements</code></a> 插件能够记录数据库服务器上所有 SQL 语句在优化和执行阶段的统计信息。由于该插件需要使用共享内存，因此插件名需要被配置在 <code>shared_preload_libraries</code> 参数中。</p><p>如果没有在当前数据库中创建过 <code>pg_stat_statements</code> 插件的话，首先需要创建这个插件。该过程将会注册好插件提供的函数及视图：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> EXTENSION <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> pg_stat_statements<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>该插件和数据库系统本身都会不断累积统计信息。为了排查 CPU 异常升高后这段时间内的问题，需要把数据库和插件中留存的统计信息做一次清空，然后开始收集从当前时刻开始的统计信息：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token comment">-- 清空当前数据库的统计信息</span></span>
<span class="line"><span class="token keyword">SELECT</span> pg_stat_reset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 清空 pg_stat_statements 插件截止目前收集的统计信息</span></span>
<span class="line"><span class="token keyword">SELECT</span> pg_stat_statements_reset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>接下来需要等待一段时间（1-2 分钟），使数据库和插件充分采集这段时间内的统计信息。</p><p>统计信息收集完毕后，参考使用如下 SQL 查询执行时间最长的 5 条 SQL：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token comment">-- &lt; PostgreSQL 13</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_stat_statements <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> total_time <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- &gt;= PostgreSQL 13</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_stat_statements <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> total_exec_time <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><h3 id="定位读取-buffer-数量较多的慢查询" tabindex="-1"><a class="header-anchor" href="#定位读取-buffer-数量较多的慢查询"><span>定位读取 Buffer 数量较多的慢查询</span></a></h3><p>当一张表缺少索引，而对该表的查询基本上都是点查时，数据库将不得不使用全表扫描，并在内存中进行过滤条件的判断，处理掉大量的无效记录，导致 CPU 使用率大幅提升。利用 <code>pg_stat_statements</code> 插件的统计信息，参考如下 SQL，可以列出截止目前读取 Buffer 数量最多的 5 条 SQL：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_stat_statements</span>
<span class="line"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> shared_blks_hit <span class="token operator">+</span> shared_blks_read <span class="token keyword">DESC</span></span>
<span class="line"><span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>借助 PostgreSQL 内置系统视图 <a href="https://www.postgresql.org/docs/15/monitoring-stats.html#MONITORING-PG-STAT-ALL-TABLES-VIEW" target="_blank" rel="noopener noreferrer"><code>pg_stat_user_tables</code></a> 中的统计信息，也可以统计出使用全表扫描的次数最多的表。参考如下 SQL，可以获取具备一定规模数据量（元组约为 10 万个）且使用全表扫描获取到的元组数量最多的 5 张表：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_stat_user_tables</span>
<span class="line"><span class="token keyword">WHERE</span> n_live_tup <span class="token operator">&gt;</span> <span class="token number">100000</span> <span class="token operator">AND</span> seq_scan <span class="token operator">&gt;</span> <span class="token number">0</span></span>
<span class="line"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> seq_tup_read <span class="token keyword">DESC</span></span>
<span class="line"><span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><h3 id="定位长时间执行不结束的慢查询" tabindex="-1"><a class="header-anchor" href="#定位长时间执行不结束的慢查询"><span>定位长时间执行不结束的慢查询</span></a></h3><p>通过系统内置视图 <code>pg_stat_activity</code>，可以查询出长时间执行不结束的 SQL，这些 SQL 有极大可能造成 CPU 使用率过高。参考以下 SQL 获取查询执行时间最长，且目前还未退出的 5 条 SQL：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span></span>
<span class="line">    <span class="token operator">*</span><span class="token punctuation">,</span></span>
<span class="line">    extract<span class="token punctuation">(</span>epoch <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> xact_start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> xact_stay<span class="token punctuation">,</span></span>
<span class="line">    extract<span class="token punctuation">(</span>epoch <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> query_start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> query_stay</span>
<span class="line"><span class="token keyword">FROM</span> pg_stat_activity</span>
<span class="line"><span class="token keyword">WHERE</span> state <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">&#39;idle%&#39;</span></span>
<span class="line"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> query_stay <span class="token keyword">DESC</span></span>
<span class="line"><span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>结合前一步中排查到的 <strong>使用全表扫描最多的表</strong>，参考如下 SQL 获取 <strong>在该表上</strong> 执行时间超过一定阈值（比如 10s）的慢查询：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_stat_activity</span>
<span class="line"><span class="token keyword">WHERE</span></span>
<span class="line">    state <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">&#39;idle%&#39;</span> <span class="token operator">AND</span></span>
<span class="line">    query <span class="token operator">ILIKE</span> <span class="token string">&#39;%表名%&#39;</span> <span class="token operator">AND</span></span>
<span class="line">    <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> query_start <span class="token operator">&gt;</span> <span class="token keyword">interval</span> <span class="token string">&#39;10s&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><h3 id="解决方法与优化思路" tabindex="-1"><a class="header-anchor" href="#解决方法与优化思路"><span>解决方法与优化思路</span></a></h3><p>对于异常占用 CPU 较高的 SQL，如果仅有个别非预期 SQL，则可以通过给后端进程发送信号的方式，先让 SQL 执行中断，使 CPU 使用率恢复正常。参考如下 SQL，以慢查询执行所使用的进程 pid（<code>pg_stat_activity</code> 视图的 <code>pid</code> 列）作为参数，中止相应的进程的执行：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> pg_cancel_backend<span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SELECT</span> pg_terminate_backend<span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>如果执行较慢的 SQL 是业务上必要的 SQL，那么需要对它进行调优。</p><p>首先可以对 SQL 涉及到的表进行采样，更新其统计信息，使优化器能够产生更加准确的执行计划。采样需要占用一定的 CPU，最好在业务低谷期运行：</p><div class="language-sql" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">ANALYZE</span> 表名<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>对于全表扫描较多的表，可以在常用的过滤列上创建索引，以尽量使用索引扫描，减少全表扫描在内存中过滤不符合条件的记录所造成的 CPU 浪费。</p>`,34))])}const _=r(u,[["render",h]]),y=JSON.parse('{"path":"/zh/operation/cpu-usage-high.html","title":"CPU 使用率高的排查方法","lang":"zh-CN","frontmatter":{"author":"棠羽","date":"2023/03/06","minute":20},"headers":[{"level":2,"title":"业务量上涨","slug":"业务量上涨","link":"#业务量上涨","children":[]},{"level":2,"title":"慢查询","slug":"慢查询","link":"#慢查询","children":[{"level":3,"title":"定位执行时间较长的慢查询","slug":"定位执行时间较长的慢查询","link":"#定位执行时间较长的慢查询","children":[]},{"level":3,"title":"定位读取 Buffer 数量较多的慢查询","slug":"定位读取-buffer-数量较多的慢查询","link":"#定位读取-buffer-数量较多的慢查询","children":[]},{"level":3,"title":"定位长时间执行不结束的慢查询","slug":"定位长时间执行不结束的慢查询","link":"#定位长时间执行不结束的慢查询","children":[]},{"level":3,"title":"解决方法与优化思路","slug":"解决方法与优化思路","link":"#解决方法与优化思路","children":[]}]}],"git":{"updatedTime":1760793941000,"contributors":[{"name":"aCoder2013","username":"aCoder2013","email":"7877752+aCoder2013@users.noreply.github.com","commits":1,"url":"https://github.com/aCoder2013"}],"changelog":[{"hash":"6fcfdc2993a4b32b3c1c8119b43c3545d6ab9654","time":1760793941000,"email":"7877752+aCoder2013@users.noreply.github.com","author":"acoder2014","message":"fix: typo in arch-overview.md (#608)"}]},"filePathRelative":"zh/operation/cpu-usage-high.md"}');export{_ as comp,y as data};
