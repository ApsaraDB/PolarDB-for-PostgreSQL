set client_min_messages=warning;
create table xc_int8_tbl(q1 int8, q2 int8);
INSERT INTO xc_int8_tbl VALUES('  123   ','  456');
INSERT INTO xc_int8_tbl VALUES('123   ','4567890123456789');
INSERT INTO xc_int8_tbl VALUES('4567890123456789','123');
INSERT INTO xc_int8_tbl VALUES(+4567890123456789,'4567890123456789');
INSERT INTO xc_int8_tbl VALUES('+4567890123456789','-4567890123456789');
create table xc_int4_tbl(f1 int4);
INSERT INTO xc_int4_tbl(f1) VALUES ('   0  ');
INSERT INTO xc_int4_tbl(f1) VALUES ('123456     ');
INSERT INTO xc_int4_tbl(f1) VALUES ('    -123456');
INSERT INTO xc_int4_tbl(f1) VALUES ('2147483647');
INSERT INTO xc_int4_tbl(f1) VALUES ('-2147483647');
select create_table_nodes('rep_foo(a int, b int)', '{1, 2}'::int[], 'replication', NULL);
 create_table_nodes 
--------------------
 
(1 row)

select create_table_nodes('foo (f1 serial, f2 text, f3 int default 42)', '{1, 2}'::int[], 'hash(f1)', NULL);
 create_table_nodes 
--------------------
 
(1 row)

select create_table_nodes('tp (f1 serial, f2 text, f3 int default 42)', '{1}'::int[], 'hash(f1)', NULL);
 create_table_nodes 
--------------------
 
(1 row)

select create_table_nodes('tc (fc int) INHERITS (tp)', '{2}'::int[], 'hash(f1)', NULL);
 create_table_nodes 
--------------------
 
(1 row)

create table parent(a int, b int);
create table child (c int) INHERITS (parent);
create table grand_child (d int) INHERITS (child);
create table fp(f1 int, f2 varchar(255), f3 int);
create table fp_child (fc int) INHERITS (fp);
create table bar(c1 int, c2 int);
create table ta1 (v1 int, v2 int);
create table ta2 (v1 int, v2 int);
create table sal_emp (name text, pay_by_quarter integer[], schedule text[][]);
create table products(product_id serial PRIMARY KEY ,product_name varchar(150),price numeric(10,2) ) ;
create table my_tab(f1 int, f2 text, f3 int);
create table my_tab2(f1 int, f2 text, f3 int);
create or replace function fn_immutable(integer) RETURNS integer
    AS 'SELECT f3+$1 from my_tab2 where f1=1;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
create or replace function fn_volatile(integer) RETURNS integer
    AS 'SELECT f3+$1 from my_tab2 where f1=1;'
    LANGUAGE SQL
    VOLATILE
    RETURNS NULL ON NULL INPUT;
create or replace function fn_stable(integer) RETURNS integer
    AS 'SELECT $1 from my_tab2 where f1=1;'
    LANGUAGE SQL
    STABLE
    RETURNS NULL ON NULL INPUT;
select create_table_nodes('numbers(a int, b varchar(255), c int)', '{1, 2}'::int[], 'hash(a)', NULL);
 create_table_nodes 
--------------------
 
(1 row)

create table test_tab(a int, b varchar(255), c varchar(255), d int);
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
-- INSERT Returning
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
-------------------------------------------------------------
-- insert returning from a replicated table
-------------------------------------------------------------
insert into rep_foo values(1,2)
returning b, a, b, b, b+a, b-a, ctid;
 b | a | b | b | ?column? | ?column? | ctid  
---+---+---+---+----------+----------+-------
 2 | 1 | 2 | 2 |        3 |        1 | (0,1)
(1 row)

with t as 
(
  insert into rep_foo values(3,4), (5,6), (7,8) 
  returning b, a, b, b, b+a, b-a, ctid
) select * from t order by 1, 2;
 b | a | b | b | ?column? | ?column? | ctid  
---+---+---+---+----------+----------+-------
 4 | 3 | 4 | 4 |        7 |        1 | (0,2)
 6 | 5 | 6 | 6 |       11 |        1 | (0,3)
 8 | 7 | 8 | 8 |       15 |        1 | (0,4)
(3 rows)

truncate table rep_foo;
-------------------------------------------------------------
-- insert returning the colum that was not inserted
-------------------------------------------------------------
insert into foo values(1,'One') returning f3, ctid;
 f3 | ctid  
----+-------
 42 | (0,1)
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- single insert & multi-insert returning misc values
-------------------------------------------------------------
insert into bar values(8,9) 
returning c2, c1, c2, c2, c1+c2, c2-c1 as diff, 
c2-1 as minus1, ctid, least(c1,c2);
 c2 | c1 | c2 | c2 | ?column? | diff | minus1 | ctid  | least 
----+----+----+----+----------+------+--------+-------+-------
  9 |  8 |  9 |  9 |       17 |    1 |      8 | (0,1) |     8
(1 row)

with t as 
(
  insert into bar values(1,2), (3,4),(5,6)
  returning c2, c1, c2, c2, c1+c2, c2-c1 as diff,
    c2-1 as minus1, ctid, least(c1,c2)
) select * from t order by 1,2;
 c2 | c1 | c2 | c2 | ?column? | diff | minus1 | ctid  | least 
----+----+----+----+----------+------+--------+-------+-------
  2 |  1 |  2 |  2 |        3 |    1 |      1 | (0,2) |     1
  4 |  3 |  4 |  4 |        7 |    1 |      3 | (0,1) |     3
  6 |  5 |  6 |  6 |       11 |    1 |      5 | (0,3) |     5
(3 rows)

truncate table bar;
-------------------------------------------------------------
-- sub-plan and init-plan in returning list
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9) returning *, ctid;
 f1 |  f2  | f3 | ctid  
----+------+----+-------
  1 | test | 42 | (0,1)
  2 | More | 11 | (0,2)
  3 | MORE | 16 | (0,1)
(3 rows)

with t as
(
INSERT INTO foo SELECT f1+10, f2, f3+99 FROM foo
RETURNING *, f3-f1, f1+112 IN (SELECT q1 FROM xc_int8_tbl) AS subplan, 
EXISTS(SELECT * FROM xc_int4_tbl) AS initplan
)
select * from t order by 1,2,3;
 f1 |  f2  | f3  | ?column? | subplan | initplan 
----+------+-----+----------+---------+----------
 11 | test | 141 |      130 | t       | t
 12 | More | 110 |       98 | f       | t
 13 | MORE | 115 |      102 | f       | t
(3 rows)

select * from foo order by 1,2;
 f1 |  f2  | f3  
----+------+-----
  1 | test |  42
  2 | More |  11
  3 | MORE |  16
 11 | test | 141
 12 | More | 110
 13 | MORE | 115
(6 rows)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- Make sure returning implementation works in case of inheritance
-------------------------------------------------------------
with t as
(
INSERT INTO fp VALUES (1,'test', 42), (2,'More', 11), (3,upper('more'), 7+9) returning ctid, f3, f2, f1, f3-f1
)
select * from t order by 4,3,2;
 ctid  | f3 |  f2  | f1 | ?column? 
-------+----+------+----+----------
 (0,1) | 42 | test |  1 |       41
 (0,2) | 11 | More |  2 |        9
 (0,1) | 16 | MORE |  3 |       13
(3 rows)

INSERT INTO fp_child VALUES(123,'child',999,-123) returning ctid, *;
 ctid  | f1  |  f2   | f3  |  fc  
-------+-----+-------+-----+------
 (0,1) | 123 | child | 999 | -123
(1 row)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- insert returning in case of an insert rule defined on table
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
create VIEW voo AS SELECT f1, f2 FROM foo;
create OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD
  INSERT INTO foo VALUES(new.*, 57) RETURNING f1, f2;
INSERT INTO voo VALUES(11,'zit');
INSERT INTO voo VALUES(12,'zoo') RETURNING *, f1*2;
 f1 | f2  | ?column? 
----+-----+----------
 12 | zoo |       24
(1 row)

drop view voo;
truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- insert returning in case parent and child reside on different Datanodes
-------------------------------------------------------------
with t as
(
INSERT INTO tp (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9) returning ctid, f3, f2, f1, f3-f1
)
select * from t order by 4,3,2;
 ctid  | f3 |  f2  | f1 | ?column? 
-------+----+------+----+----------
 (0,1) | 42 | test |  1 |       41
 (0,2) | 11 | More |  2 |        9
 (0,3) | 16 | MORE |  3 |       13
(3 rows)

INSERT INTO tc VALUES(123,'child',999,-123)
returning ctid, f3, f2, f1, f3-f1, fc;
 ctid  | f3  |  f2   | f1  | ?column? |  fc  
-------+-----+-------+-----+----------+------
 (0,1) | 999 | child | 123 |      876 | -123
(1 row)

truncate table tc;
truncate table tp;
-------------------------------------------------------------
-- scalars in returning
-------------------------------------------------------------
with t as
(
insert into numbers values(1,'one',11),(2,'Two',22),(3,'Three',33) returning b,c,a, 234, c-2, a+3, ctid
)
select * from t order by 3,2,1;
   b   | c  | a | ?column? | ?column? | ?column? | ctid  
-------+----+---+----------+----------+----------+-------
 one   | 11 | 1 |      234 |        9 |        4 | (0,1)
 Two   | 22 | 2 |      234 |       20 |        5 | (0,2)
 Three | 33 | 3 |      234 |       31 |        6 | (0,1)
(3 rows)

insert into numbers values(4,'four',44)
returning b,c,a,a+1,22,upper(b),c-a, ctid;
  b   | c  | a | ?column? | ?column? | upper | ?column? | ctid  
------+----+---+----------+----------+-------+----------+-------
 four | 44 | 4 |        5 |       22 | FOUR  |       40 | (0,2)
(1 row)

truncate table numbers;
-------------------------------------------------------------
-- Array notation in returning
-------------------------------------------------------------
INSERT INTO sal_emp VALUES ('Bill', ARRAY[10000, 10000, 10000, 10000], ARRAY[['meeting', 'lunch'], ['training', 'presentation']])
returning pay_by_quarter[3], schedule[1:2][1:1], array_lower(schedule, 1), array_length(schedule, 1), array_dims(schedule);
 pay_by_quarter |        schedule        | array_lower | array_length | array_dims 
----------------+------------------------+-------------+--------------+------------
          10000 | {{meeting},{training}} |           1 |            2 | [1:2][1:2]
(1 row)

INSERT INTO sal_emp VALUES ('Carol', ARRAY[20000, 25000, 25000, 25000], ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']])
returning pay_by_quarter[3], schedule[1:2][1:1], array_lower(schedule, 1), array_length(schedule, 1), array_dims(schedule);
 pay_by_quarter |        schedule         | array_lower | array_length | array_dims 
----------------+-------------------------+-------------+--------------+------------
          25000 | {{breakfast},{meeting}} |           1 |            2 | [1:2][1:2]
(1 row)

truncate table sal_emp;
-------------------------------------------------------------
-- ANY in returning
-------------------------------------------------------------
with t as
(
INSERT INTO products(product_name, price) VALUES  ('apple', 0.5) ,('cherry apple', 1.25) ,('avocado', 1.5),('octopus',20.50) ,('watermelon',2.00)
returning product_id, product_id = ANY('{1,4,5}'::int[])
)
select * from t order by 1;
 product_id | ?column? 
------------+----------
          1 | t
          2 | f
          3 | f
          4 | t
          5 | t
(5 rows)

truncate table products;
alter sequence products_product_id_seq restart with 1;
-------------------------------------------------------------
-- functions in returning
-------------------------------------------------------------
insert into my_tab2 values(1,'One',11) returning *;
 f1 | f2  | f3 
----+-----+----
  1 | One | 11
(1 row)

insert into my_tab2 values(2,'Two',22) returning *;
 f1 | f2  | f3 
----+-----+----
  2 | Two | 22
(1 row)

insert into my_tab2 values(3,'Three',33) returning *;
 f1 |  f2   | f3 
----+-------+----
  3 | Three | 33
(1 row)

insert into my_tab values(1,'One',11) returning f3,f2,f1,f3-f1,fn_immutable(f3);
 f3 | f2  | f1 | ?column? | fn_immutable 
----+-----+----+----------+--------------
 11 | One |  1 |       10 |           22
(1 row)

insert into my_tab values(2,'Two',22) returning f3,f2,f1,f3-f1, fn_volatile(f3);
 f3 | f2  | f1 | ?column? | fn_volatile 
----+-----+----+----------+-------------
 22 | Two |  2 |       20 |          33
(1 row)

insert into my_tab values(3,'Three',33) returning f3,f2,f1,f3-f1, fn_stable(f3);
 f3 |  f2   | f1 | ?column? | fn_stable 
----+-------+----+----------+-----------
 33 | Three |  3 |       30 |        33
(1 row)

truncate table my_tab;
truncate table my_tab2;
-------------------------------------------------------------
-- boolean operator in returning
-------------------------------------------------------------
insert into numbers values(0,'zero',1) returning (a::bool) OR (c::bool);
 ?column? 
----------
 t
(1 row)

insert into numbers values(0,'zero',1) returning (a::bool) AND (c::bool);
 ?column? 
----------
 f
(1 row)

insert into numbers values(0,'zero',1) returning NOT(a::bool);
 ?column? 
----------
 t
(1 row)

truncate table numbers;
-------------------------------------------------------------
-- use of case in returning clause 
-------------------------------------------------------------
with t as
(
insert into numbers values(1,'one',11),(2,'Two',22),(3,'Three',33) returning case when a=1 then 'First' when a=2 then 'Second' when a=3 then 'Third' else 'nth' end
)
select * from t order by 1;
  case  
--------
 First
 Second
 Third
(3 rows)

truncate table numbers;
-------------------------------------------------------------
-- use of conditional expressions in returning clause 
-------------------------------------------------------------
with t as
(
insert into test_tab values(0,'zero', NULL, 1), (1,NULL,NULL,23),(2,'Two','Second',NULL),(3,'Three','Third', 2)
 returning *, COALESCE(c,b), NULLIF(b,c), greatest(a,d), least(a,d), b IS NULL, C IS NOT NULL
)
select * from t order by 1,2,3,4;
 a |   b   |   c    | d  | coalesce | nullif | greatest | least | ?column? | ?column? 
---+-------+--------+----+----------+--------+----------+-------+----------+----------
 0 | zero  |        |  1 | zero     | zero   |        1 |     0 | f        | f
 1 |       |        | 23 |          |        |       23 |     1 | t        | f
 2 | Two   | Second |    | Second   | Two    |        2 |     2 | f        | t
 3 | Three | Third  |  2 | Third    | Three  |        3 |     2 | f        | t
(4 rows)

truncate table test_tab;
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
-- UPDATE Returning
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
-------------------------------------------------------------
-- update returning from a replicated table
-------------------------------------------------------------
insert into rep_foo values(1,2),(3,4), (5,6);
update rep_foo set b=b+1 where b = 2 returning b, a, b, b, b+a, b-a, ctid;
 b | a | b | b | ?column? | ?column? | ctid  
---+---+---+---+----------+----------+-------
 3 | 1 | 3 | 3 |        4 |        2 | (0,4)
(1 row)

with t as
(
update rep_foo set b=b+1 returning b, a, b, b, b+a, b-a, ctid
)
select * from t order by 1,2;
 b | a | b | b | ?column? | ?column? | ctid  
---+---+---+---+----------+----------+-------
 4 | 1 | 4 | 4 |        5 |        3 | (0,7)
 5 | 3 | 5 | 5 |        8 |        2 | (0,5)
 7 | 5 | 7 | 7 |       12 |        2 | (0,6)
(3 rows)

truncate table rep_foo;
-------------------------------------------------------------
-- update more rows in one go and return updated values
-------------------------------------------------------------
insert into bar values(1,2), (3,4),(5,6);
with t as
(
update bar set c2=c2+1 returning c2, c1, c2, c2, c1+c2, c2-c1, c2-1, ctid
)
select * from t order by 1,2;
 c2 | c1 | c2 | c2 | ?column? | ?column? | ?column? | ctid  
----+----+----+----+----------+----------+----------+-------
  3 |  1 |  3 |  3 |        4 |        2 |        2 | (0,3)
  5 |  3 |  5 |  5 |        8 |        2 |        4 | (0,2)
  7 |  5 |  7 |  7 |       12 |        2 |        6 | (0,4)
(3 rows)

truncate table bar;
-------------------------------------------------------------
-- use a function in returning clause
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
update foo set f3 = f3+1 WHERE f1 < 2 RETURNING f3, f2, f1, f3-f1, least(f1,f3), ctid;
 f3 |  f2  | f1 | ?column? | least | ctid  
----+------+----+----------+-------+-------
 43 | test |  1 |       42 |     1 | (0,3)
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- An example of a join where returning list contains columns from both tables
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
update foo set f3=f3*2 from xc_int4_tbl i WHERE (foo.f1 + (123456-1)) = i.f1 RETURNING foo.*, foo.f3-foo.f1,  i.f1 as "i.f1", foo.ctid, i.ctid;
 f1 |  f2  | f3 | ?column? |  i.f1  | ctid  | ctid  
----+------+----+----------+--------+-------+-------
  1 | test | 84 |       83 | 123456 | (0,3) | (0,1)
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- sub-plan and init-plan in returning list
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
update foo set f3=f3*2 WHERE f1 < 2 RETURNING *, f3-f1, ctid, f1+112 IN (SELECT q1 FROM xc_int8_tbl) AS subplan, EXISTS(SELECT * FROM xc_int4_tbl) AS initplan;
 f1 |  f2  | f3 | ?column? | ctid  | subplan | initplan 
----+------+----+----------+-------+---------+----------
  1 | test | 84 |       83 | (0,3) | f       | t
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- Test * in a join case when used in returning
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
update foo set f3=f3*2 from xc_int8_tbl i  WHERE foo.f1+122 = i.q1  RETURNING *, foo.ctid;
 f1 |  f2  | f3 | q1  |        q2        | ctid  
----+------+----+-----+------------------+-------
  1 | test | 84 | 123 | 4567890123456789 | (0,3)
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- Make sure returning implementation did not break update in case of inheritance
-------------------------------------------------------------
INSERT INTO fp VALUES (1,'test',42), (2,'More', 11), (3,upper('more'), 7+9);
INSERT INTO fp_child VALUES(123,'child',999,-123);
ALTER table fp ADD COLUMN f4 int8 DEFAULT 99;
explain (costs off, num_nodes off, nodes off, verbose on)
UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.fp
   Node expr: public.fp.f1
   Remote query: UPDATE ONLY fp SET f4 = $4 WHERE ((public.fp.ctid = $6) AND (public.fp.xc_node_id = $7))
   Node expr: fp.f1
   Remote query: UPDATE ONLY fp_child fp SET f4 = $5 WHERE ((fp.ctid = $7) AND (fp.xc_node_id = $8))
   ->  Data Node Scan on fp "_REMOTE_TABLE_QUERY_"
         Output: public.fp.f1, public.fp.f2, public.fp.f3, (public.fp.f4 + public.fp.f3), public.fp.f4, public.fp.ctid, public.fp.xc_node_id
         Remote query: SELECT f1, f2, f3, f4, ctid, xc_node_id FROM ONLY fp WHERE (f4 = 99)
   ->  Data Node Scan on fp_child "_REMOTE_TABLE_QUERY_"
         Output: fp.f1, fp.f2, fp.f3, fp.f4, (fp.f4 + fp.f3), fp.f4, fp.ctid, fp.xc_node_id
         Remote query: SELECT f1, f2, f3, fc, f4, ctid, xc_node_id FROM ONLY fp_child fp WHERE (f4 = 99)
(11 rows)

explain (costs off, num_nodes off, nodes off, verbose on)
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.fp
   Node expr: public.fp.f1
   Remote query: UPDATE ONLY fp SET f3 = $3 WHERE ((public.fp.ctid = $6) AND (public.fp.xc_node_id = $7))
   Node expr: fp.f1
   Remote query: UPDATE ONLY fp_child fp SET f3 = $3 WHERE ((fp.ctid = $7) AND (fp.xc_node_id = $8))
   ->  Hash Join
         Output: public.fp.f1, public.fp.f2, (public.fp.f3 * 2), public.fp.f4, public.fp.f1, public.fp.ctid, public.fp.xc_node_id, i.ctid
         Hash Cond: (public.fp.f1 = i.q2)
         ->  Data Node Scan on fp "_REMOTE_TABLE_QUERY_"
               Output: public.fp.f1, public.fp.f2, public.fp.f3, public.fp.f4, public.fp.ctid, public.fp.xc_node_id
               Remote query: SELECT f1, f2, f3, f4, ctid, xc_node_id FROM ONLY fp WHERE true
         ->  Hash
               Output: i.ctid, i.q2
               ->  Data Node Scan on xc_int8_tbl "_REMOTE_TABLE_QUERY_"
                     Output: i.ctid, i.q2
                     Remote query: SELECT ctid, q2 FROM ONLY xc_int8_tbl i WHERE true
   ->  Hash Join
         Output: fp.f1, fp.f2, (fp.f3 * 2), fp.f4, fp.f4, fp.f1, fp.ctid, fp.xc_node_id, i.ctid
         Hash Cond: (fp.f1 = i.q2)
         ->  Data Node Scan on fp_child "_REMOTE_TABLE_QUERY_"
               Output: fp.f1, fp.f2, fp.f3, fp.f4, fp.f4, fp.ctid, fp.xc_node_id
               Remote query: SELECT f1, f2, f3, fc, f4, ctid, xc_node_id FROM ONLY fp_child fp WHERE true
         ->  Hash
               Output: i.ctid, i.q2
               ->  Data Node Scan on xc_int8_tbl "_REMOTE_TABLE_QUERY_"
                     Output: i.ctid, i.q2
                     Remote query: SELECT ctid, q2 FROM ONLY xc_int8_tbl i WHERE true
(27 rows)

explain (costs off, num_nodes off, nodes off, verbose on)
update fp_child set fc=fc+2 returning *, f4-f1;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.fp_child
   Output: fp_child.f1, fp_child.f2, fp_child.f3, fp_child.fc, fp_child.f4, (fp_child.f4 - fp_child.f1)
   Node expr: fp_child.f1
   Remote query: UPDATE ONLY fp_child SET fc = $4 WHERE ((fp_child.ctid = $6) AND (fp_child.xc_node_id = $7)) RETURNING fp_child.f1, fp_child.f2, fp_child.f3, fp_child.fc, fp_child.f4
   ->  Data Node Scan on fp_child "_REMOTE_TABLE_QUERY_"
         Output: fp_child.f1, fp_child.f2, fp_child.f3, (fp_child.fc + 2), fp_child.f4, fp_child.ctid, fp_child.xc_node_id
         Remote query: SELECT f1, f2, f3, fc, f4, ctid, xc_node_id FROM ONLY fp_child WHERE true
(7 rows)

explain (costs off, num_nodes off, nodes off, verbose on)
update fp set f3 = f3 + 1 where f1<2 returning *, f3-f1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.fp
   Output: public.fp.f1, public.fp.f2, public.fp.f3, public.fp.f4, (public.fp.f3 - public.fp.f1)
   Node expr: public.fp.f1
   Remote query: UPDATE ONLY fp SET f3 = $3 WHERE ((public.fp.ctid = $6) AND (public.fp.xc_node_id = $7)) RETURNING public.fp.f1, public.fp.f2, public.fp.f3, public.fp.f4
   Node expr: fp.f1
   Remote query: UPDATE ONLY fp_child fp SET f3 = $3 WHERE ((fp.ctid = $7) AND (fp.xc_node_id = $8)) RETURNING fp.f1, fp.f2, fp.f3, fp.f4
   ->  Data Node Scan on fp "_REMOTE_TABLE_QUERY_"
         Output: public.fp.f1, public.fp.f2, (public.fp.f3 + 1), public.fp.f4, public.fp.f1, public.fp.ctid, public.fp.xc_node_id
         Remote query: SELECT f1, f2, f3, f4, ctid, xc_node_id FROM ONLY fp WHERE (f1 < 2)
   ->  Data Node Scan on fp_child "_REMOTE_TABLE_QUERY_"
         Output: fp.f1, fp.f2, (fp.f3 + 1), fp.f4, fp.f4, fp.f1, fp.ctid, fp.xc_node_id
         Remote query: SELECT f1, f2, f3, fc, f4, ctid, xc_node_id FROM ONLY fp_child fp WHERE (f1 < 2)
(12 rows)

UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99;
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2;
update fp_child set fc=fc+2 returning *, f4-f1;
 f1  |  f2   |  f3  |  fc  |  f4  | ?column? 
-----+-------+------+------+------+----------
 123 | child | 1998 | -121 | 1098 |      975
(1 row)

update fp set f3 = f3 + 1 where f1<2 returning *, f3-f1;
 f1 |  f2  | f3 | f4  | ?column? 
----+------+----+-----+----------
  1 | test | 43 | 141 |       42
(1 row)

select * from fp order by 1,2,3;
 f1  |  f2   |  f3  |  f4  
-----+-------+------+------
   1 | test  |   43 |  141
   2 | More  |   11 |  110
   3 | MORE  |   16 |  115
 123 | child | 1998 | 1098
(4 rows)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- Update parent with returning in case of a join
-------------------------------------------------------------
INSERT INTO fp VALUES (1, 'test', 42), (2, 'More', 11), (3, upper('more'), 7+9);
INSERT INTO fp_child VALUES(123,'child',999,-123);
with t as
(
UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99 returning ctid, *
)
select * from t order by 1,2,3;
 ctid  | f1  |  f2   | f3  |  f4  
-------+-----+-------+-----+------
 (0,2) |   3 | MORE  |  16 |  115
 (0,2) | 123 | child | 999 | 1098
 (0,3) |   1 | test  |  42 |  141
 (0,4) |   2 | More  |  11 |  110
(4 rows)

with t as
(
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2 returning *, fp.ctid, i.ctid
)
select * from t order by 1,2,3;
 f1  |  f2   |  f3  |  f4  |        q1        | q2  | ctid  | ctid  
-----+-------+------+------+------------------+-----+-------+-------
 123 | child | 1998 | 1098 | 4567890123456789 | 123 | (0,3) | (0,1)
(1 row)

with t as
(
update fp set f3=i.q1 from xc_int8_tbl i  WHERE fp.f1 = i.q1  RETURNING *, fp.f1-fp.f3
)
select * from t order by 1,2,3;
 f1  |  f2   | f3  |  f4  | q1  |        q2        | ?column? 
-----+-------+-----+------+-----+------------------+----------
 123 | child | 123 | 1098 | 123 | 4567890123456789 |        0
(1 row)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- update child with returning in case of a join
-------------------------------------------------------------
INSERT INTO fp VALUES (1, 'test', 42), (2, 'More', 11), (3, upper('more'), 7+9);
INSERT INTO fp_child VALUES(123,'child',999,-123);
with t as
(
UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99 returning *
)
select * from t order by 1,2,3;
 f1  |  f2   | f3  |  f4  
-----+-------+-----+------
   1 | test  |  42 |  141
   2 | More  |  11 |  110
   3 | MORE  |  16 |  115
 123 | child | 999 | 1098
(4 rows)

with t as
(
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2 returning *
)
select * from t order by 1,2,3;
 f1  |  f2   |  f3  |  f4  |        q1        | q2  
-----+-------+------+------+------------------+-----
 123 | child | 1998 | 1098 | 4567890123456789 | 123
(1 row)

with t as
(
update fp_child set f4 = f4 + 1 from xc_int8_tbl i  WHERE fp_child.f1 = i.q1  RETURNING *, fp_child.f1-fp_child.f3
)
select * from t order by 1,2,3;
 f1  |  f2   |  f3  |  fc  |  f4  | q1  |        q2        | ?column? 
-----+-------+------+------+------+-----+------------------+----------
 123 | child | 1998 | -123 | 1099 | 123 | 4567890123456789 |    -1875
(1 row)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- Returning in case of a rule defined on table
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
create VIEW voo AS SELECT f1, f3 FROM foo;
create OR REPLACE RULE voo_u AS ON UPDATE TO voo DO INSTEAD UPDATE foo SET f3 = new.f3 WHERE f1 = old.f1 RETURNING f3, f1;
update voo set f3 = f1 + 1;
update voo set f3 = f1 + 1 where f1 < 2 RETURNING *;
 f1 | f3 
----+----
  2 |  1
(1 row)

drop view voo;
truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- returning in case parent and child reside on different Datanodes
-------------------------------------------------------------
INSERT INTO tp (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
INSERT INTO tc VALUES(123,'child',999,-123);
update tc set fc = fc + 23 from xc_int8_tbl i  WHERE tc.f1 = i.q1 returning *;
 f1  |  f2   | f3  |  fc  | q1  |        q2        
-----+-------+-----+------+-----+------------------
 123 | child | 999 | -100 | 123 | 4567890123456789
(1 row)

update tp set f3 = f3 + 23 from xc_int8_tbl i  WHERE tp.f1 = i.q1 returning *;
 f1  |  f2   |  f3  | q1  |        q2        
-----+-------+------+-----+------------------
 123 | child | 1022 | 123 | 4567890123456789
(1 row)

truncate table tc;
truncate table tp;
-------------------------------------------------------------
-- returning in case of 3 levels of inheritance
-------------------------------------------------------------
insert into parent values(1,2),(3,4),(5,6),(7,8);
insert into child values(11,22,33),(44,55,66);
insert into grand_child values(111,222,333,444),(555,666,777,888);
update parent set b = a + 1 from xc_int8_tbl i WHERE parent.a + 455 = i.q2  RETURNING *, b-i.q2;
 a | b | q1  | q2  | ?column? 
---+---+-----+-----+----------
 1 | 2 | 123 | 456 |     -454
(1 row)

update child set c=c+1 from xc_int8_tbl i  WHERE child.a + (456-44) = i.q2  RETURNING *, b-a;
 a  | b  | c  | q1  | q2  | ?column? 
----+----+----+-----+-----+----------
 44 | 55 | 67 | 123 | 456 |       11
(1 row)

update grand_child set d=d+2 from xc_int8_tbl i  WHERE grand_child.a + (456-111) = i.q2  RETURNING *, b-a;
  a  |  b  |  c  |  d  | q1  | q2  | ?column? 
-----+-----+-----+-----+-----+-----+----------
 111 | 222 | 333 | 446 | 123 | 456 |      111
(1 row)

truncate table grand_child;
truncate table child;
truncate table parent;
-------------------------------------------------------------
-- Return system columns 
-------------------------------------------------------------
insert into bar values(1,2),(3,4),(5,6),(7,8),(9,0);
update bar  set c2=c2 where c1 = 1 returning c2, c1, c2-c1, ctid, cmin, xmax, cmax;
 c2 | c1 | ?column? | ctid  | cmin | xmax | cmax 
----+----+----------+-------+------+------+------
  2 |  1 |        1 | (0,4) |    0 |    0 |    0
(1 row)

truncate table bar;
-------------------------------------------------------------
-- scalars in returning
-------------------------------------------------------------
insert into numbers values(1,'one',11),(2,'Two',22),(3,'Three',33);
insert into numbers values(4,'four',44);
update numbers set c=a where a=4 returning b,c,a,a+1,22,upper(b),c-a, ctid;
  b   | c | a | ?column? | ?column? | upper | ?column? | ctid  
------+---+---+----------+----------+-------+----------+-------
 four | 4 | 4 |        5 |       22 | FOUR  |        0 | (0,3)
(1 row)

truncate table numbers;
-------------------------------------------------------------
-- Array notation in returning
-------------------------------------------------------------
INSERT INTO sal_emp VALUES ('Bill', ARRAY[10000, 10000, 10000, 10000], ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);
INSERT INTO sal_emp VALUES ('Carol', ARRAY[20000, 25000, 25000, 25000], ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
update sal_emp set pay_by_quarter[3] = pay_by_quarter[2]  WHERE pay_by_quarter[1] <> pay_by_quarter[2] 
returning pay_by_quarter[3], schedule[1:2][1:1], array_lower(schedule, 1), array_length(schedule, 1), array_dims(schedule);
 pay_by_quarter |        schedule         | array_lower | array_length | array_dims 
----------------+-------------------------+-------------+--------------+------------
          25000 | {{breakfast},{meeting}} |           1 |            2 | [1:2][1:2]
(1 row)

truncate table sal_emp;
-------------------------------------------------------------
-- ANY in returning
-------------------------------------------------------------
INSERT INTO products(product_name, price) VALUES  ('apple', 0.5) ,('cherry apple', 1.25) ,('avocado', 1.5),('octopus',20.50) ,('watermelon',2.00);
with t as
(
update products set price = price + 1.0 WHERE product_id = ANY('{1,4,5}'::int[]) returning product_id, product_id = ANY('{1,4,5}'::int[])
)
select * from t order by 1;
 product_id | ?column? 
------------+----------
          1 | t
          4 | t
          5 | t
(3 rows)

truncate table products;
alter sequence products_product_id_seq restart with 1;
-------------------------------------------------------------
-- functions in returning
-------------------------------------------------------------
insert into my_tab values(1,'One',11);
insert into my_tab values(2,'Two',22);
insert into my_tab values(3,'Three',33);
insert into my_tab2 values(1,'One',11);
insert into my_tab2 values(2,'Two',22);
insert into my_tab2 values(3,'Three',33);
update my_tab set f3=2*f3 where f1=1 returning f3,f2,f1,fn_immutable(f3);
 f3 | f2  | f1 | fn_immutable 
----+-----+----+--------------
 22 | One |  1 |           33
(1 row)

update my_tab set f3=2*f3 where f1=2 returning f3,f2,f1,fn_volatile(f3);
 f3 | f2  | f1 | fn_volatile 
----+-----+----+-------------
 44 | Two |  2 |          55
(1 row)

update my_tab set f3=2*f3 where f1=3 returning f3,f2,f1,fn_stable(f3);
 f3 |  f2   | f1 | fn_stable 
----+-------+----+-----------
 66 | Three |  3 |        66
(1 row)

truncate table my_tab;
truncate table my_tab2;
-------------------------------------------------------------
-- boolean operator in returning
-------------------------------------------------------------
insert into numbers values(0,'zero',1);
update numbers set c=c-a where a=0 returning (a::bool) OR (c::bool);
 ?column? 
----------
 t
(1 row)

update numbers set c=c-a where a=0 returning (a::bool) AND (c::bool);
 ?column? 
----------
 f
(1 row)

update numbers set c=c-a where a=0 returning NOT(a::bool);
 ?column? 
----------
 t
(1 row)

truncate table numbers;
-------------------------------------------------------------
-- use of case in returning clause 
-------------------------------------------------------------
insert into numbers values(1,'one',11),(2,'Two',22),(3,'Three',33);
with t as
(
update numbers set c=c-a returning case when a=1 then 'First' when a=2 then 'Second' when a=3 then 'Third' else 'nth' end
)
select * from t order by 1;
  case  
--------
 First
 Second
 Third
(3 rows)

truncate table numbers;
-------------------------------------------------------------
-- use of conditional expressions in returning clause 
-------------------------------------------------------------
insert into test_tab values(0,'zero', NULL, 1), (1,NULL,NULL,23),(2,'Two','Second',NULL),(3,'Three','Third', 2);
with t as
(
update test_tab set d=d-a returning *, COALESCE(c,b), NULLIF(b,c), greatest(a,d), least(a,d), b IS NULL, C IS NOT NULL
)
select * from t order by 1,2,3,4;
 a |   b   |   c    | d  | coalesce | nullif | greatest | least | ?column? | ?column? 
---+-------+--------+----+----------+--------+----------+-------+----------+----------
 0 | zero  |        |  1 | zero     | zero   |        1 |     0 | f        | f
 1 |       |        | 22 |          |        |       22 |     1 | t        | f
 2 | Two   | Second |    | Second   | Two    |        2 |     2 | f        | t
 3 | Three | Third  | -1 | Third    | Three  |        3 |    -1 | f        | t
(4 rows)

truncate table test_tab;
-------------------------------------------------------------
-- Returning from both the tables in case of an update using from clause
-------------------------------------------------------------
insert into bar values(1,2);
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT);
update foo set f3=f3*2 from bar i RETURNING foo.*, foo.ctid foo_ctid, i.ctid i_ctid;
 f1 |  f2  | f3 | foo_ctid | i_ctid 
----+------+----+----------+--------
  1 | test | 84 | (0,2)    | (0,1)
(1 row)

truncate table bar;
truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- Another case of returning from both the tables in case of an update using from clause
-- This is a very important test case, it uncovered a bug in remote executor
-- where eof_underlying was not being set to false despite HandleDataRow getting
-- a data row from the datanode and copying it in RemoteQueryState
-------------------------------------------------------------
insert into ta1 values(1,2),(2,3),(3,4);
insert into ta2 values(1,2),(2,3),(3,4);
with t as
(
update ta1 t1 set v2=t1.v2+10 from ta1 t2 where t2.v2<=3 returning t1.ctid,t1.v1 t1_v1, t1.v2 t1_v2, t2.v1 t2_v1,t2.v2 t2_v2,t1.v1*t2.v2
)
select * from t order by 2,3;
 ctid  | t1_v1 | t1_v2 | t2_v1 | t2_v2 | ?column? 
-------+-------+-------+-------+-------+----------
 (0,3) |     1 |    12 |     1 |     2 |        2
 (0,4) |     2 |    13 |     1 |     2 |        4
 (0,2) |     3 |    14 |     1 |     2 |        6
(3 rows)

select * from ta1 order by v1;
 v1 | v2 
----+----
  1 | 12
  2 | 13
  3 | 14
(3 rows)

with t as
(
update ta1 t1 set v2=t1.v2+10 from ta2 t2 where t2.v2<=13 returning t1.ctid,t1.v1 t1_v1, t1.v2 t1_v2
)
select * from t order by 2,3;
 ctid  | t1_v1 | t1_v2 
-------+-------+-------
 (0,5) |     1 |    22
 (0,6) |     2 |    23
 (0,3) |     3 |    24
(3 rows)

select * from ta1 order by v1;
 v1 | v2 
----+----
  1 | 22
  2 | 23
  3 | 24
(3 rows)

truncate table ta1;
truncate table ta2;
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- DELETE Returning
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-------------------------------------------------------------
-- delete returning from a replicated table
-------------------------------------------------------------
insert into rep_foo values(1,2),(3,4), (5,6);
delete from rep_foo where a = 1 returning b, a, b, b, b+a, b-a;
 b | a | b | b | ?column? | ?column? 
---+---+---+---+----------+----------
 2 | 1 | 2 | 2 |        3 |        1
(1 row)

with t as
(
delete from rep_foo returning b, a, b, b, b+a, b-a
)
select * from t order by 1,2;
 b | a | b | b | ?column? | ?column? 
---+---+---+---+----------+----------
 4 | 3 | 4 | 4 |        7 |        1
 6 | 5 | 6 | 6 |       11 |        1
(2 rows)

truncate table rep_foo;
-------------------------------------------------------------
-- delete more rows in one go and return deleted values
-------------------------------------------------------------
insert into bar values(1,2), (3,4),(5,6);
with t as
(
delete from bar returning c2, c1, c2, c2, c1+c2, c2-c1, c2-1
)
select * from t order by 1,2;
 c2 | c1 | c2 | c2 | ?column? | ?column? | ?column? 
----+----+----+----+----------+----------+----------
  2 |  1 |  2 |  2 |        3 |        1 |        1
  4 |  3 |  4 |  4 |        7 |        1 |        3
  6 |  5 |  6 |  6 |       11 |        1 |        5
(3 rows)

truncate table bar;
-------------------------------------------------------------
-- use a function in returning clause
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
DELETE FROM foo WHERE f1 < 2 RETURNING f3, f2, f1, f3-f1, least(f1,f3);
 f3 |  f2  | f1 | ?column? | least 
----+------+----+----------+-------
 42 | test |  1 |       41 |     1
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- An example of a join where returning list contains columns from both tables
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
DELETE FROM foo USING xc_int4_tbl i WHERE (foo.f1 + (123456-1)) = i.f1 RETURNING foo.*, foo.f3-foo.f1,  i.f1 as "i.f1";
 f1 |  f2  | f3 | ?column? |  i.f1  
----+------+----+----------+--------
  1 | test | 42 |       41 | 123456
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- sub-plan and init-plan in returning list
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
DELETE FROM foo WHERE f1 < 2 RETURNING *, f3-f1,  f1+112 IN (SELECT q1 FROM xc_int8_tbl) AS subplan, EXISTS(SELECT * FROM xc_int4_tbl) AS initplan;
 f1 |  f2  | f3 | ?column? | subplan | initplan 
----+------+----+----------+---------+----------
  1 | test | 42 |       41 | f       | t
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- Test * in a join case when used in returning
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
DELETE FROM foo  USING xc_int8_tbl i  WHERE foo.f1+122 = i.q1  RETURNING *;
 f1 |  f2  | f3 | q1  |        q2        
----+------+----+-----+------------------
  1 | test | 42 | 123 | 4567890123456789
(1 row)

truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- Test delete returning in case of child tables and parent tables
-------------------------------------------------------------
INSERT INTO fp VALUES (1,'test',42), (2,'More', 11), (3,upper('more'), 7+9);
INSERT INTO fp_child VALUES(123,'child',999,-123);
INSERT INTO fp_child VALUES(456,'child',999,-456);
UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99;
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2;
DELETE FROM fp_child where fc = -123 returning *, f4-f1;
 f1  |  f2   |  f3  |  fc  |  f4  | ?column? 
-----+-------+------+------+------+----------
 123 | child | 1998 | -123 | 1098 |      975
(1 row)

DELETE FROM fp where f1 < 2 returning *, f3-f1;
 f1 |  f2  | f3 | f4  | ?column? 
----+------+----+-----+----------
  1 | test | 42 | 141 |       41
(1 row)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- Delete from parent with returning in case of a join
-------------------------------------------------------------
INSERT INTO fp VALUES (1,'test',42), (2,'More', 11), (3,upper('more'), 7+9);
INSERT INTO fp_child VALUES(123,'child',999,-123);
UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99;
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2;
DELETE FROM fp  USING xc_int8_tbl i  WHERE fp.f1 = i.q1  RETURNING *, fp.f1-fp.f3;
 f1  |  f2   |  f3  |  f4  | q1  |        q2        | ?column? 
-----+-------+------+------+-----+------------------+----------
 123 | child | 1998 | 1098 | 123 | 4567890123456789 |    -1875
(1 row)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- Delete from child with returning in case of a join
-------------------------------------------------------------
INSERT INTO fp VALUES (1,'test',42), (2,'More', 11), (3,upper('more'), 7+9);
INSERT INTO fp_child VALUES(123,'child',999,-123);
UPDATE fp SET f4 = f4 + f3 WHERE f4 = 99;
UPDATE fp SET f3 = f3*2  FROM xc_int8_tbl i  WHERE fp.f1 = i.q2;
DELETE FROM fp_child USING xc_int8_tbl i  WHERE fp_child.f1 = i.q1  RETURNING *, fp_child.f1-fp_child.f3;
 f1  |  f2   |  f3  |  fc  |  f4  | q1  |        q2        | ?column? 
-----+-------+------+------+------+-----+------------------+----------
 123 | child | 1998 | -123 | 1098 | 123 | 4567890123456789 |    -1875
(1 row)

truncate table fp_child;
truncate table fp;
-------------------------------------------------------------
-- delete returning in case of a delete rule defined on table
-------------------------------------------------------------
INSERT INTO foo (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
create VIEW voo AS SELECT f1, f2 FROM foo;
create OR REPLACE RULE voo_d AS ON DELETE TO voo DO INSTEAD  DELETE FROM foo WHERE f1 = old.f1  RETURNING f1, f2;
DELETE FROM foo WHERE f1 = 1;
DELETE FROM foo WHERE f1 < 2 RETURNING *, f3-f1;
 f1 | f2 | f3 | ?column? 
----+----+----+----------
(0 rows)

drop view voo;
truncate table foo;
alter sequence foo_f1_seq restart with 1;
-------------------------------------------------------------
-- delete returning in case parent and child reside on different Datanodes
-------------------------------------------------------------
INSERT INTO tp (f2,f3) VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9);
INSERT INTO tc VALUES(123,'child',999,-123);
DELETE FROM tc  USING xc_int8_tbl i  WHERE tc.f1 = i.q1 returning *;
 f1  |  f2   | f3  |  fc  | q1  |        q2        
-----+-------+-----+------+-----+------------------
 123 | child | 999 | -123 | 123 | 4567890123456789
(1 row)

truncate table tc;
truncate table tp;
-------------------------------------------------------------
-- delete returning in case of 3 levels of inheritance
-------------------------------------------------------------
insert into parent values(1,2),(3,4),(5,6),(7,8);
insert into child values(11,22,33),(44,55,66);
insert into grand_child values(111,222,333,444),(555,666,777,888);
DELETE FROM parent  USING xc_int8_tbl i  WHERE parent.a + 455 = i.q2  RETURNING *, b-a;
 a | b | q1  | q2  | ?column? 
---+---+-----+-----+----------
 1 | 2 | 123 | 456 |        1
(1 row)

DELETE FROM child  USING xc_int8_tbl i  WHERE child.a + (456-44) = i.q2  RETURNING *, b-a;
 a  | b  | c  | q1  | q2  | ?column? 
----+----+----+-----+-----+----------
 44 | 55 | 66 | 123 | 456 |       11
(1 row)

DELETE FROM grand_child  USING xc_int8_tbl i  WHERE grand_child.a + (456-111) = i.q2  RETURNING *, b-a;
  a  |  b  |  c  |  d  | q1  | q2  | ?column? 
-----+-----+-----+-----+-----+-----+----------
 111 | 222 | 333 | 444 | 123 | 456 |      111
(1 row)

truncate table grand_child;
truncate table child;
truncate table parent;
-------------------------------------------------------------
-- Return system columns while deleting
-------------------------------------------------------------
insert into bar values(1,2),(3,4),(5,6),(7,8),(9,0);
with t as
(
delete from bar returning c2, c1, c2-c1, get_xc_node_name_gen(xc_node_id)
)
select * from t order by 1,2;
 c2 | c1 | ?column? | get_xc_node_name_gen 
----+----+----------+----------------------
  0 |  9 |       -9 | NODE_1
  2 |  1 |        1 | NODE_1
  4 |  3 |        1 | NODE_2
  6 |  5 |        1 | NODE_1
  8 |  7 |        1 | NODE_2
(5 rows)

truncate table bar;
-------------------------------------------------------------
-- scalars in returning
-------------------------------------------------------------
insert into numbers values(1,'one',11),(2,'Two',22),(3,'Three',33);
insert into numbers values(4,'four',44);
delete from numbers where a=4 returning b,c,a,a+1,22,upper(b),c-a;
  b   | c  | a | ?column? | ?column? | upper | ?column? 
------+----+---+----------+----------+-------+----------
 four | 44 | 4 |        5 |       22 | FOUR  |       40
(1 row)

truncate table numbers;
-------------------------------------------------------------
-- Array notation in returning
-------------------------------------------------------------
INSERT INTO sal_emp VALUES ('Bill', ARRAY[10000, 10000, 10000, 10000], ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);
INSERT INTO sal_emp VALUES ('Carol', ARRAY[20000, 25000, 25000, 25000], ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
delete from sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2] 
returning pay_by_quarter[3], schedule[1:2][1:1], array_lower(schedule, 1), array_length(schedule, 1), array_dims(schedule);
 pay_by_quarter |        schedule         | array_lower | array_length | array_dims 
----------------+-------------------------+-------------+--------------+------------
          25000 | {{breakfast},{meeting}} |           1 |            2 | [1:2][1:2]
(1 row)

truncate table sal_emp;
-------------------------------------------------------------
-- ANY in returning
-------------------------------------------------------------
INSERT INTO products(product_name, price) VALUES  ('apple', 0.5) ,('cherry apple', 1.25) ,('avocado', 1.5),('octopus',20.50) ,('watermelon',2.00);
with t as
(
DELETE FROM products WHERE product_id = ANY('{1,4,5}'::int[]) returning product_id, product_id = ANY('{1,4,5}'::int[])
)
select * from t order by 1;
 product_id | ?column? 
------------+----------
          1 | t
          4 | t
          5 | t
(3 rows)

truncate table products;
alter sequence products_product_id_seq restart with 1;
-------------------------------------------------------------
-- functions in returning
-------------------------------------------------------------
insert into my_tab values(1,'One',11);
insert into my_tab values(2,'Two',22);
insert into my_tab values(3,'Three',33);
insert into my_tab2 values(1,'One',11);
insert into my_tab2 values(2,'Two',22);
insert into my_tab2 values(3,'Three',33);
delete from my_tab where f1=1 returning f3,f2,f1,fn_immutable(f3);
 f3 | f2  | f1 | fn_immutable 
----+-----+----+--------------
 11 | One |  1 |           22
(1 row)

delete from my_tab where f1=2 returning f3,f2,f1,fn_volatile(f3);
 f3 | f2  | f1 | fn_volatile 
----+-----+----+-------------
 22 | Two |  2 |          33
(1 row)

delete from my_tab where f1=3 returning f3,f2,f1,fn_stable(f3);
 f3 |  f2   | f1 | fn_stable 
----+-------+----+-----------
 33 | Three |  3 |        33
(1 row)

truncate table my_tab;
truncate table my_tab2;
-------------------------------------------------------------
-- boolean operator in returning
-------------------------------------------------------------
insert into numbers values(0,'zero',1);
delete from numbers where a=0 returning (a::bool) OR (c::bool);
 ?column? 
----------
 t
(1 row)

insert into numbers values(0,'zero',1);
delete from numbers where a=0 returning (a::bool) AND (c::bool);
 ?column? 
----------
 f
(1 row)

insert into numbers values(0,'zero',1);
delete from numbers where a=0 returning NOT(a::bool);
 ?column? 
----------
 t
(1 row)

truncate table numbers;
-------------------------------------------------------------
-- use of case in returning clause 
-------------------------------------------------------------
insert into numbers values(1,'one',11),(2,'Two',22),(3,'Three',33);
with t as
(
delete from numbers returning case when a=1 then 'First' when a=2 then 'Second' when a=3 then 'Third' else 'nth' end
)
select * from t order by 1;
  case  
--------
 First
 Second
 Third
(3 rows)

truncate table numbers;
-------------------------------------------------------------
-- use of conditional expressions in returning clause 
-------------------------------------------------------------
insert into test_tab values(0,'zero', NULL, 1), (1,NULL,NULL,23),(2,'Two','Second',NULL),(3,'Three','Third', 2);
with t as
(
delete from test_tab returning *, COALESCE(c,b), NULLIF(b,c), greatest(a,d), least(a,d), b IS NULL, C IS NOT NULL
)
select * from t order by 1,2,3,4;
 a |   b   |   c    | d  | coalesce | nullif | greatest | least | ?column? | ?column? 
---+-------+--------+----+----------+--------+----------+-------+----------+----------
 0 | zero  |        |  1 | zero     | zero   |        1 |     0 | f        | f
 1 |       |        | 23 |          |        |       23 |     1 | t        | f
 2 | Two   | Second |    | Second   | Two    |        2 |     2 | f        | t
 3 | Three | Third  |  2 | Third    | Three  |        3 |     2 | f        | t
(4 rows)

truncate table test_tab;
-------------------------------------------------------------
-- clean up
-------------------------------------------------------------
drop table test_tab;
drop table numbers;
drop function fn_immutable(integer);
drop function fn_volatile(integer);
drop function fn_stable(integer);
drop table my_tab;
drop table my_tab2;
drop table products;
drop table sal_emp;
drop table ta1;
drop table ta2;
drop table bar;
drop table fp_child;
drop table fp;
drop table grand_child;
drop table child;
drop table parent;
drop table tc;
drop table tp;
drop table foo;
drop table rep_foo;
drop table xc_int8_tbl;
drop table xc_int4_tbl;
reset client_min_messages;
