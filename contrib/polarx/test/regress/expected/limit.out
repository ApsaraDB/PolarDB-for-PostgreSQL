--
-- LIMIT
-- Check the LIMIT/OFFSET feature of SELECT
--
SELECT ''::text AS two, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 50
		ORDER BY unique1 LIMIT 2;
 two | unique1 | unique2 | stringu1 
-----+---------+---------+----------
(0 rows)

SELECT ''::text AS five, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 60
		ORDER BY unique1 LIMIT 5;
 five | unique1 | unique2 | stringu1 
------+---------+---------+----------
(0 rows)

SELECT ''::text AS two, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 60 AND unique1 < 63
		ORDER BY unique1 LIMIT 5;
 two | unique1 | unique2 | stringu1 
-----+---------+---------+----------
(0 rows)

SELECT ''::text AS three, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 100
		ORDER BY unique1 LIMIT 3 OFFSET 20;
 three | unique1 | unique2 | stringu1 
-------+---------+---------+----------
(0 rows)

SELECT ''::text AS zero, unique1, unique2, stringu1
		FROM onek WHERE unique1 < 50
		ORDER BY unique1 DESC LIMIT 8 OFFSET 99;
 zero | unique1 | unique2 | stringu1 
------+---------+---------+----------
(0 rows)

SELECT ''::text AS eleven, unique1, unique2, stringu1
		FROM onek WHERE unique1 < 50
		ORDER BY unique1 DESC LIMIT 20 OFFSET 39;
 eleven | unique1 | unique2 | stringu1 
--------+---------+---------+----------
(0 rows)

SELECT ''::text AS ten, unique1, unique2, stringu1
		FROM onek
		ORDER BY unique1 OFFSET 990;
 ten | unique1 | unique2 | stringu1 
-----+---------+---------+----------
(0 rows)

SELECT ''::text AS five, unique1, unique2, stringu1
		FROM onek
		ORDER BY unique1 OFFSET 990 LIMIT 5;
 five | unique1 | unique2 | stringu1 
------+---------+---------+----------
(0 rows)

SELECT ''::text AS five, unique1, unique2, stringu1
		FROM onek
		ORDER BY unique1 LIMIT 5 OFFSET 900;
 five | unique1 | unique2 | stringu1 
------+---------+---------+----------
(0 rows)

-- Test null limit and offset.  The planner would discard a simple null
-- constant, so to ensure executor is exercised, do this:
select * from int8_tbl limit (case when random() < 0.5 then null::bigint end);
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

select * from int8_tbl offset (case when random() < 0.5 then null::bigint end);
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

-- Test assorted cases involving backwards fetch from a LIMIT plan node
begin;
declare c1 scroll cursor for select * from int8_tbl limit 10;
fetch all in c1;
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

fetch 1 in c1;
 q1 | q2 
----+----
(0 rows)

fetch backward 1 in c1;
        q1        |        q2         
------------------+-------------------
 4567890123456789 | -4567890123456789
(1 row)

fetch backward all in c1;
        q1        |        q2        
------------------+------------------
 4567890123456789 | 4567890123456789
 4567890123456789 |              123
              123 | 4567890123456789
              123 |              456
(4 rows)

fetch backward 1 in c1;
 q1 | q2 
----+----
(0 rows)

fetch all in c1;
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

declare c2 scroll cursor for select * from int8_tbl limit 3;
fetch all in c2;
        q1        |        q2        
------------------+------------------
              123 |              456
              123 | 4567890123456789
 4567890123456789 |              123
(3 rows)

fetch 1 in c2;
 q1 | q2 
----+----
(0 rows)

fetch backward 1 in c2;
        q1        | q2  
------------------+-----
 4567890123456789 | 123
(1 row)

fetch backward all in c2;
 q1  |        q2        
-----+------------------
 123 | 4567890123456789
 123 |              456
(2 rows)

fetch backward 1 in c2;
 q1 | q2 
----+----
(0 rows)

fetch all in c2;
        q1        |        q2        
------------------+------------------
              123 |              456
              123 | 4567890123456789
 4567890123456789 |              123
(3 rows)

declare c3 scroll cursor for select * from int8_tbl offset 3;
fetch all in c3;
        q1        |        q2         
------------------+-------------------
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(2 rows)

fetch 1 in c3;
 q1 | q2 
----+----
(0 rows)

fetch backward 1 in c3;
        q1        |        q2         
------------------+-------------------
 4567890123456789 | -4567890123456789
(1 row)

fetch backward all in c3;
        q1        |        q2        
------------------+------------------
 4567890123456789 | 4567890123456789
(1 row)

fetch backward 1 in c3;
 q1 | q2 
----+----
(0 rows)

fetch all in c3;
        q1        |        q2         
------------------+-------------------
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(2 rows)

declare c4 scroll cursor for select * from int8_tbl offset 10;
fetch all in c4;
 q1 | q2 
----+----
(0 rows)

fetch 1 in c4;
 q1 | q2 
----+----
(0 rows)

fetch backward 1 in c4;
 q1 | q2 
----+----
(0 rows)

fetch backward all in c4;
 q1 | q2 
----+----
(0 rows)

fetch backward 1 in c4;
 q1 | q2 
----+----
(0 rows)

fetch all in c4;
 q1 | q2 
----+----
(0 rows)

rollback;
-- Stress test for variable LIMIT in conjunction with bounded-heap sorting
SELECT
  (SELECT n
     FROM (VALUES (1)) AS x,
          (SELECT n FROM generate_series(1,10) AS n
             ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z
  FROM generate_series(1,10) AS s;
 z  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

--
-- Test behavior of volatile and set-returning functions in conjunction
-- with ORDER BY and LIMIT.
--
create temp sequence testseq;
-- XL: The query has been slightly modified to suit XL's execution mechanism
-- when nextval is pushed down to the remote node. Using a subquery gives
-- consistent results and also ensures currval() returns correct value (since
-- nextval gets executed on the coordinator). The original two tests are
-- copied to xl_known_bugs test case
explain (verbose, costs off)
select  *, nextval('testseq') from
	(select unique1, unique2 from tenk1 order by unique2 limit 10) x;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Subquery Scan on x
   Output: x.unique1, x.unique2, nextval('testseq'::regclass)
   ->  Limit
         Output: unique1, unique2
         ->  Sort
               Output: unique1, unique2
               Sort Key: unique2
               ->  Remote Fast Query Execution (primary node count=0, node count=2)
                     Output: unique1, unique2
                     Node/s: datanode_1, datanode_2
                     Remote query: SELECT unique1, unique2 FROM ONLY public.tenk1 WHERE true
                     ->  Seq Scan on public.tenk1
                           Output: unique1, unique2
(13 rows)

select  *, nextval('testseq') from
	(select unique1, unique2 from tenk1 order by unique2 limit 10) x;
 unique1 | unique2 | nextval 
---------+---------+---------
(0 rows)

select currval('testseq');
ERROR:  currval of sequence "testseq" is not yet defined in this session
explain (verbose, costs off)
select *, nextval('testseq') from
	(select unique1, unique2 from tenk1 order by tenthous limit 10) x;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Subquery Scan on x
   Output: x.unique1, x.unique2, nextval('testseq'::regclass)
   ->  Limit
         Output: unique1, unique2, tenthous
         ->  Sort
               Output: unique1, unique2, tenthous
               Sort Key: tenthous
               ->  Remote Fast Query Execution (primary node count=0, node count=2)
                     Output: unique1, unique2, tenthous
                     Node/s: datanode_1, datanode_2
                     Remote query: SELECT unique1, unique2, tenthous FROM ONLY public.tenk1 WHERE true
                     ->  Seq Scan on public.tenk1
                           Output: unique1, unique2, tenthous
(13 rows)

select *, nextval('testseq') from
	(select unique1, unique2 from tenk1 order by tenthous limit 10) x;
 unique1 | unique2 | nextval 
---------+---------+---------
(0 rows)

select currval('testseq');
ERROR:  currval of sequence "testseq" is not yet defined in this session
explain (verbose, costs off)
select unique1, unique2, generate_series(1,10)
  from tenk1 order by unique2 limit 7;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Limit
   Output: tenk1.unique1, tenk1.unique2, (generate_series(1, 10))
   ->  ProjectSet
         Output: tenk1.unique1, tenk1.unique2, generate_series(1, 10)
         ->  Sort
               Output: tenk1.unique1, tenk1.unique2
               Sort Key: tenk1.unique2
               ->  Remote Fast Query Execution (primary node count=0, node count=2)
                     Output: tenk1.unique1, tenk1.unique2
                     Node/s: datanode_1, datanode_2
                     Remote query: SELECT unique1, unique2 FROM ONLY public.tenk1 WHERE true
                     ->  Seq Scan on public.tenk1
                           Output: unique1, unique2
(13 rows)

select unique1, unique2, generate_series(1,10)
  from tenk1 order by unique2 limit 7;
 unique1 | unique2 | generate_series 
---------+---------+-----------------
(0 rows)

explain (verbose, costs off)
select unique1, unique2, generate_series(1,10)
  from tenk1 order by tenthous limit 7;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Limit
   Output: tenk1.unique1, tenk1.unique2, (generate_series(1, 10)), tenk1.tenthous
   ->  ProjectSet
         Output: tenk1.unique1, tenk1.unique2, generate_series(1, 10), tenk1.tenthous
         ->  Sort
               Output: tenk1.unique1, tenk1.unique2, tenk1.tenthous
               Sort Key: tenk1.tenthous
               ->  Remote Fast Query Execution (primary node count=0, node count=2)
                     Output: tenk1.unique1, tenk1.unique2, tenk1.tenthous
                     Node/s: datanode_1, datanode_2
                     Remote query: SELECT unique1, unique2, tenthous FROM ONLY public.tenk1 WHERE true
                     ->  Seq Scan on public.tenk1
                           Output: unique1, unique2, tenthous
(13 rows)

select unique1, unique2, generate_series(1,10)
  from tenk1 order by tenthous limit 7;
 unique1 | unique2 | generate_series 
---------+---------+-----------------
(0 rows)

-- use of random() is to keep planner from folding the expressions together
explain (verbose, costs off)
select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 ProjectSet
   Output: generate_series(0, 2), generate_series(((random() * '0.1'::double precision))::integer, 2)
   ->  Result
(3 rows)

select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
 s1 | s2 
----+----
  0 |  0
  1 |  1
  2 |  2
(3 rows)

explain (verbose, costs off)
select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2
order by s2 desc;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Sort
   Output: (generate_series(0, 2)), (generate_series(((random() * '0.1'::double precision))::integer, 2))
   Sort Key: (generate_series(((random() * '0.1'::double precision))::integer, 2)) DESC
   ->  ProjectSet
         Output: generate_series(0, 2), generate_series(((random() * '0.1'::double precision))::integer, 2)
         ->  Result
(6 rows)

select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2
order by s2 desc;
 s1 | s2 
----+----
  2 |  2
  1 |  1
  0 |  0
(3 rows)

-- test for failure to set all aggregates' aggtranstype
explain (verbose, costs off)
select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
  from tenk1 group by thousand order by thousand limit 3;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (sum(tenk1.tenthous)), ((((sum(tenk1.tenthous)))::double precision + (random() * '0'::double precision))), tenk1.thousand
   ->  Result
         Output: (sum(tenk1.tenthous)), (((sum(tenk1.tenthous)))::double precision + (random() * '0'::double precision)), tenk1.thousand
         ->  Sort
               Output: (sum(tenk1.tenthous)), tenk1.thousand
               Sort Key: tenk1.thousand
               ->  HashAggregate
                     Output: sum(tenk1.tenthous), tenk1.thousand
                     Group Key: tenk1.thousand
                     ->  Remote Fast Query Execution (primary node count=0, node count=2)
                           Output: tenk1.thousand, tenk1.tenthous
                           Node/s: datanode_1, datanode_2
                           Remote query: SELECT thousand, tenthous FROM ONLY public.tenk1 WHERE true
                           ->  Seq Scan on public.tenk1
                                 Output: thousand, tenthous
(16 rows)

select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
  from tenk1 group by thousand order by thousand limit 3;
 s1 | s2 
----+----
(0 rows)

