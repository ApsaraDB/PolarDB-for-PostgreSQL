--
-- insert...on conflict do unique index inference
--
create table insertconflicttest(key int4, fruit text);
--
-- Test unique index inference with operator class specifications and
-- named collations
--
create unique index op_index_key on insertconflicttest(key, fruit text_pattern_ops);
create unique index collation_index_key on insertconflicttest(key, fruit collate "C");
create unique index both_index_key on insertconflicttest(key, fruit collate "C" text_pattern_ops);
create unique index both_index_expr_key on insertconflicttest(key, lower(fruit) collate "C" text_pattern_ops);
-- fails
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
-- succeeds
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do nothing;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: op_index_key, collation_index_key, both_index_key
         ->  Result
(6 rows)

explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit, key) do nothing;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: op_index_key, collation_index_key, both_index_key
         ->  Result
(6 rows)

explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit), key, lower(fruit), key) do nothing;
                      QUERY PLAN                       
-------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: both_index_expr_key
         ->  Result
(6 rows)

explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do update set fruit = excluded.fruit
  where exists (select 1 from insertconflicttest ii where ii.key = excluded.key);
ERROR:  unexpected ON CONFLICT specification: 2
-- Neither collation nor operator class specifications are required --
-- supplying them merely *limits* matches to indexes with matching opclasses
-- used for relevant indexes
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit text_pattern_ops) do nothing;
                           QUERY PLAN                           
----------------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: op_index_key, both_index_key
         ->  Result
(6 rows)

-- Okay, arbitrates using both index where text_pattern_ops opclass does and
-- does not appear.
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit collate "C") do nothing;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: collation_index_key, both_index_key
         ->  Result
(6 rows)

-- Okay, but only accepts the single index where both opclass and collation are
-- specified
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit collate "C" text_pattern_ops, key) do nothing;
                    QUERY PLAN                    
--------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: both_index_key
         ->  Result
(6 rows)

-- Okay, but only accepts the single index where both opclass and collation are
-- specified (plus expression variant)
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", key, key) do nothing;
                      QUERY PLAN                       
-------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: both_index_expr_key
         ->  Result
(6 rows)

-- Attribute appears twice, while not all attributes/expressions on attributes
-- appearing within index definition match in terms of both opclass and
-- collation.
--
-- Works because every attribute in inference specification needs to be
-- satisfied once or more by cataloged index attribute, and as always when an
-- attribute in the cataloged definition has a non-default opclass/collation,
-- it still satisfied some inference attribute lacking any particular
-- opclass/collation specification.
--
-- The implementation is liberal in accepting inference specifications on the
-- assumption that multiple inferred unique indexes will prevent problematic
-- cases.  It rolls with unique indexes where attributes redundantly appear
-- multiple times, too (which is not tested here).
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit text_pattern_ops, key) do nothing;
                           QUERY PLAN                           
----------------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: op_index_key, both_index_key
         ->  Result
(6 rows)

explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C" text_pattern_ops, key, key) do nothing;
                      QUERY PLAN                       
-------------------------------------------------------
 Custom Scan (Polarx Fast Ship Query)
   Node expr: 0
   ->  Insert on insertconflicttest
         Conflict Resolution: NOTHING
         Conflict Arbiter Indexes: both_index_expr_key
         ->  Result
(6 rows)

drop index op_index_key;
drop index collation_index_key;
drop index both_index_key;
drop index both_index_expr_key;
--
-- Make sure that cross matching of attribute opclass/collation does not occur
--
-- In XL, table is distributed by HASH( key ) by default.
-- unique index contains fruit and not key, so this fails.
create unique index cross_match on insertconflicttest(lower(fruit) collate "C", upper(fruit) text_pattern_ops);
ERROR:  Unique index of distributed table must contain the hash/modulo distribution column.
-- fails:
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
-- works:
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", upper(fruit) text_pattern_ops) do nothing;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index cross_match;
ERROR:  index "cross_match" does not exist
--
-- Single key tests
--
create unique index key_index on insertconflicttest(key);
--
-- Explain tests
--
explain (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- Should display qual actually attributable to internal sequential scan:
explain (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Cawesh';
ERROR:  unexpected ON CONFLICT specification: 2
-- With EXCLUDED.* expression in scan node:
explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do update set fruit = excluded.fruit where excluded.fruit != 'Elderberry';
ERROR:  unexpected ON CONFLICT specification: 2
-- Does the same, but JSON format shows "Conflict Arbiter Index" as JSON array:
explain (costs off, format json) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Lime' returning *;
ERROR:  unexpected ON CONFLICT specification: 2
-- Fails (no unique index inference specification, required for do update variant):
insert into insertconflicttest values (1, 'Apple') on conflict do update set fruit = excluded.fruit;
ERROR:  ON CONFLICT DO UPDATE requires inference specification or constraint name
LINE 1: ...nsert into insertconflicttest values (1, 'Apple') on conflic...
                                                             ^
HINT:  For example, ON CONFLICT (column_name).
-- inference succeeds:
insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
insert into insertconflicttest values (2, 'Orange') on conflict (key, key, key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- Succeed, since multi-assignment does not involve subquery:
insert into insertconflicttest
values (1, 'Apple'), (2, 'Orange')
on conflict (key) do update set (fruit, key) = (excluded.fruit, excluded.key);
ERROR:  unexpected ON CONFLICT specification: 2
-- Give good diagnostic message when EXCLUDED.* spuriously referenced from
-- RETURNING:
insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit RETURNING excluded.fruit;
ERROR:  invalid reference to FROM-clause entry for table "excluded"
LINE 1: ...y) do update set fruit = excluded.fruit RETURNING excluded.f...
                                                             ^
HINT:  There is an entry for table "excluded", but it cannot be referenced from this part of the query.
-- Only suggest <table>.* column when inference element misspelled:
insert into insertconflicttest values (1, 'Apple') on conflict (keyy) do update set fruit = excluded.fruit;
ERROR:  column "keyy" does not exist
LINE 1: ...nsertconflicttest values (1, 'Apple') on conflict (keyy) do ...
                                                             ^
HINT:  Perhaps you meant to reference the column "insertconflicttest.key".
-- Have useful HINT for EXCLUDED.* RTE within UPDATE:
insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruitt;
ERROR:  column excluded.fruitt does not exist
LINE 1: ... 'Apple') on conflict (key) do update set fruit = excluded.f...
                                                             ^
HINT:  Perhaps you meant to reference the column "excluded.fruit".
-- inference fails:
insert into insertconflicttest values (3, 'Kiwi') on conflict (key, fruit) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (4, 'Mango') on conflict (fruit, key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (5, 'Lemon') on conflict (fruit) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (6, 'Passionfruit') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
-- Check the target relation can be aliased
insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = excluded.fruit; -- ok, no reference to target table
ERROR:  unexpected ON CONFLICT specification: 2
insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = ict.fruit; -- ok, alias
ERROR:  unexpected ON CONFLICT specification: 2
insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = insertconflicttest.fruit; -- error, references aliased away name
ERROR:  invalid reference to FROM-clause entry for table "insertconflicttest"
LINE 1: ...onfruit') on conflict (key) do update set fruit = insertconf...
                                                             ^
HINT:  Perhaps you meant to reference the table alias "ict".
drop index key_index;
--
-- Composite key tests
--
create unique index comp_key_index on insertconflicttest(key, fruit);
-- inference succeeds:
insert into insertconflicttest values (7, 'Raspberry') on conflict (key, fruit) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
insert into insertconflicttest values (8, 'Lime') on conflict (fruit, key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- inference fails:
insert into insertconflicttest values (9, 'Banana') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (10, 'Blueberry') on conflict (key, key, key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (11, 'Cherry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (12, 'Date') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index comp_key_index;
--
-- Partial index tests, no inference predicate specified
--
create unique index part_comp_key_index on insertconflicttest(key, fruit) where key < 5;
create unique index expr_part_comp_key_index on insertconflicttest(key, lower(fruit)) where key < 5;
-- inference fails:
insert into insertconflicttest values (13, 'Grape') on conflict (key, fruit) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (14, 'Raisin') on conflict (fruit, key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (15, 'Cranberry') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (16, 'Melon') on conflict (key, key, key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (17, 'Mulberry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (18, 'Pineapple') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index part_comp_key_index;
drop index expr_part_comp_key_index;
--
-- Expression index tests
--
create unique index expr_key_index on insertconflicttest(lower(fruit));
ERROR:  Unique index of distributed table must contain the hash/modulo distribution column.
-- inference succeeds:
insert into insertconflicttest values (20, 'Quince') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (21, 'Pomegranate') on conflict (lower(fruit), lower(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
-- inference fails:
insert into insertconflicttest values (22, 'Apricot') on conflict (upper(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index expr_key_index;
ERROR:  index "expr_key_index" does not exist
--
-- Expression index tests (with regular column)
--
create unique index expr_comp_key_index on insertconflicttest(key, lower(fruit));
create unique index tricky_expr_comp_key_index on insertconflicttest(key, lower(fruit), upper(fruit));
-- inference succeeds:
insert into insertconflicttest values (24, 'Plum') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
insert into insertconflicttest values (25, 'Peach') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- Should not infer "tricky_expr_comp_key_index" index:
explain (costs off) insert into insertconflicttest values (26, 'Fig') on conflict (lower(fruit), key, lower(fruit), key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- inference fails:
insert into insertconflicttest values (27, 'Prune') on conflict (key, upper(fruit)) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (28, 'Redcurrant') on conflict (fruit, key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (29, 'Nectarine') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index expr_comp_key_index;
drop index tricky_expr_comp_key_index;
--
-- Non-spurious duplicate violation tests
--
create unique index key_index on insertconflicttest(key);
create unique index fruit_index on insertconflicttest(fruit);
ERROR:  Unique index of distributed table must contain the hash/modulo distribution column.
-- succeeds, since UPDATE happens to update "fruit" to existing value:
insert into insertconflicttest values (26, 'Fig') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- fails, since UPDATE is to row with key value 26, and we're updating "fruit"
-- to a value that happens to exist in another row ('peach'):
insert into insertconflicttest values (26, 'Peach') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
-- succeeds, since "key" isn't repeated/referenced in UPDATE, and "fruit"
-- arbitrates that statement updates existing "Fig" row:
insert into insertconflicttest values (25, 'Fig') on conflict (fruit) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index key_index;
drop index fruit_index;
ERROR:  index "fruit_index" does not exist
--
-- Test partial unique index inference
--
create unique index partial_key_index on insertconflicttest(key) where fruit like '%berry';
-- Succeeds
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' do update set fruit = excluded.fruit;
ERROR:  unexpected ON CONFLICT specification: 2
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' and fruit = 'inconsequential' do nothing;
-- fails
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' or fruit = 'consequential' do nothing;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) where fruit like '%berry' do update set fruit = excluded.fruit;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
drop index partial_key_index;
--
-- Test that wholerow references to ON CONFLICT's EXCLUDED work
--
create unique index plain on insertconflicttest(key);
-- Succeeds, updates existing row:
insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit
  where i.* != excluded.* returning *;
ERROR:  unexpected ON CONFLICT specification: 2
-- No update this time, though:
insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit
  where i.* != excluded.* returning *;
ERROR:  unexpected ON CONFLICT specification: 2
-- Predicate changed to require match rather than non-match, so updates once more:
insert into insertconflicttest as i values (23, 'Jackfruit') on conflict (key) do update set fruit = excluded.fruit
  where i.* = excluded.* returning *;
ERROR:  unexpected ON CONFLICT specification: 2
-- Assign:
insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text
  returning *;
ERROR:  unexpected ON CONFLICT specification: 2
-- deparse whole row var in WHERE and SET clauses:
explain (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.fruit where excluded.* is null;
ERROR:  unexpected ON CONFLICT specification: 2
explain (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text;
ERROR:  unexpected ON CONFLICT specification: 2
drop index plain;
-- Cleanup
drop table insertconflicttest;
--
-- Verify that EXCLUDED does not allow system column references. These
-- do not make sense because EXCLUDED isn't an already stored tuple
-- (and thus doesn't have a ctid, oids are not assigned yet, etc).
--
create table syscolconflicttest(key int4, data text) WITH OIDS;
insert into syscolconflicttest values (1);
insert into syscolconflicttest values (1) on conflict (key) do update set data = excluded.ctid::text;
ERROR:  column excluded.ctid does not exist
LINE 1: ...values (1) on conflict (key) do update set data = excluded.c...
                                                             ^
insert into syscolconflicttest values (1) on conflict (key) do update set data = excluded.oid::text;
ERROR:  column excluded.oid does not exist
LINE 1: ...values (1) on conflict (key) do update set data = excluded.o...
                                                             ^
drop table syscolconflicttest;
--
-- Previous tests all managed to not test any expressions requiring
-- planner preprocessing ...
--
create table insertconflict (a bigint, b bigint) with(dist_type=replication);
create unique index insertconflicti1 on insertconflict(coalesce(a, 0));
create unique index insertconflicti2 on insertconflict(b)
  where coalesce(a, 1) > 0;
insert into insertconflict values (1, 2)
on conflict (coalesce(a, 0)) do nothing;
insert into insertconflict values (1, 2)
on conflict (b) where coalesce(a, 1) > 0 do nothing;
insert into insertconflict values (1, 2)
on conflict (b) where coalesce(a, 1) > 1 do nothing;
drop table insertconflict;
--
-- test insertion through view
--
create table insertconflict (f1 int primary key, f2 text);
create view insertconflictv as
  select * from insertconflict with cascaded check option;
insert into insertconflictv values (1,'foo')
  on conflict (f1) do update set f2 = excluded.f2;
ERROR:  unexpected ON CONFLICT specification: 2
select * from insertconflict;
 f1 | f2 
----+----
(0 rows)

insert into insertconflictv values (1,'bar')
  on conflict (f1) do update set f2 = excluded.f2;
ERROR:  unexpected ON CONFLICT specification: 2
select * from insertconflict;
 f1 | f2 
----+----
(0 rows)

drop view insertconflictv;
drop table insertconflict;
-- ******************************************************************
-- *                                                                *
-- * Test inheritance (example taken from tutorial)                 *
-- *                                                                *
-- ******************************************************************
create table cities (
	name		text,
	population	float8,
	altitude	int		-- (in ft)
);
create table capitals (
	state		char(2)
) inherits (cities);
-- Create unique indexes.  Due to a general limitation of inheritance,
-- uniqueness is only enforced per-relation.  Unique index inference
-- specification will do the right thing, though.
create unique index cities_names_unique on cities (name);
create unique index capitals_names_unique on capitals (name);
-- prepopulate the tables.
insert into cities values ('San Francisco', 7.24E+5, 63);
insert into cities values ('Las Vegas', 2.583E+5, 2174);
insert into cities values ('Mariposa', 1200, 1953);
insert into capitals values ('Sacramento', 3.694E+5, 30, 'CA');
insert into capitals values ('Madison', 1.913E+5, 845, 'WI');
-- Tests proper for inheritance:
select * from capitals;
    name    | population | altitude | state 
------------+------------+----------+-------
 Madison    |     191300 |      845 | WI
 Sacramento |     369400 |       30 | CA
(2 rows)

-- Succeeds:
insert into cities values ('Las Vegas', 2.583E+5, 2174) on conflict do nothing;
insert into capitals values ('Sacramento', 4664.E+5, 30, 'CA') on conflict (name) do update set population = excluded.population;
ERROR:  unexpected ON CONFLICT specification: 2
-- Wrong "Sacramento", so do nothing:
insert into capitals values ('Sacramento', 50, 2267, 'NE') on conflict (name) do nothing;
select * from capitals;
    name    | population | altitude | state 
------------+------------+----------+-------
 Madison    |     191300 |      845 | WI
 Sacramento |     369400 |       30 | CA
(2 rows)

insert into cities values ('Las Vegas', 5.83E+5, 2001) on conflict (name) do update set population = excluded.population, altitude = excluded.altitude;
ERROR:  unexpected ON CONFLICT specification: 2
-- tableoid::regclass is not mapped to relation name in XL
-- bug #4
select * from cities;
     name      | population | altitude 
---------------+------------+----------
 Madison       |     191300 |      845
 San Francisco |     724000 |       63
 Las Vegas     |     258300 |     2174
 Mariposa      |       1200 |     1953
 Sacramento    |     369400 |       30
(5 rows)

insert into capitals values ('Las Vegas', 5.83E+5, 2222, 'NV') on conflict (name) do update set population = excluded.population;
ERROR:  unexpected ON CONFLICT specification: 2
-- Capitals will contain new capital, Las Vegas:
select * from capitals;
    name    | population | altitude | state 
------------+------------+----------+-------
 Madison    |     191300 |      845 | WI
 Sacramento |     369400 |       30 | CA
(2 rows)

-- Cities contains two instances of "Las Vegas", since unique constraints don't
-- work across inheritance:
select * from cities;
     name      | population | altitude 
---------------+------------+----------
 Madison       |     191300 |      845
 San Francisco |     724000 |       63
 Las Vegas     |     258300 |     2174
 Mariposa      |       1200 |     1953
 Sacramento    |     369400 |       30
(5 rows)

-- This only affects "cities" version of "Las Vegas":
insert into cities values ('Las Vegas', 5.86E+5, 2223) on conflict (name) do update set population = excluded.population, altitude = excluded.altitude;
ERROR:  unexpected ON CONFLICT specification: 2
select * from cities;
     name      | population | altitude 
---------------+------------+----------
 Madison       |     191300 |      845
 San Francisco |     724000 |       63
 Las Vegas     |     258300 |     2174
 Mariposa      |       1200 |     1953
 Sacramento    |     369400 |       30
(5 rows)

-- clean up
drop table capitals;
drop table cities;
-- Make sure a table named excluded is handled properly
create table excluded(key int primary key, data text);
insert into excluded values(1, '1');
-- error, ambiguous
insert into excluded values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  table reference "excluded" is ambiguous
LINE 1: ...es(1, '2') on conflict (key) do update set data = excluded.d...
                                                             ^
-- ok, aliased
insert into excluded AS target values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
-- ok, aliased
insert into excluded AS target values(1, '2') on conflict (key) do update set data = target.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
-- make sure excluded isn't a problem in returning clause
insert into excluded values(1, '2') on conflict (key) do update set data = 3 RETURNING excluded.*;
ERROR:  unexpected ON CONFLICT specification: 2
-- clean up
drop table excluded;
-- Check tables w/o oids are handled correctly
create table testoids(key int primary key, data text) without oids;
-- first without oids
insert into testoids values(1, '1') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
insert into testoids values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
-- add oids
alter table testoids set with oids;
-- update existing row, that didn't have an oid
insert into testoids values(1, '3') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
-- insert a new row
insert into testoids values(2, '1') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
-- and update it
insert into testoids values(2, '2') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
-- remove oids again, test
alter table testoids set without oids;
insert into testoids values(1, '4') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
insert into testoids values(3, '1') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
insert into testoids values(3, '2') on conflict (key) do update set data = excluded.data RETURNING *;
ERROR:  unexpected ON CONFLICT specification: 2
DROP TABLE testoids;
-- check that references to columns after dropped columns are handled correctly
create table dropcol(key int primary key, drop1 int, keep1 text, drop2 numeric, keep2 float);
insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 1, '1', '1', 1);
-- set using excluded
insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 2, '2', '2', 2) on conflict(key)
    do update set drop1 = excluded.drop1, keep1 = excluded.keep1, drop2 = excluded.drop2, keep2 = excluded.keep2
    where excluded.drop1 is not null and excluded.keep1 is not null and excluded.drop2 is not null and excluded.keep2 is not null
          and dropcol.drop1 is not null and dropcol.keep1 is not null and dropcol.drop2 is not null and dropcol.keep2 is not null
    returning *;
ERROR:  unexpected ON CONFLICT specification: 2
;
-- set using existing table
insert into dropcol(key, drop1, keep1, drop2, keep2) values(1, 3, '3', '3', 3) on conflict(key)
    do update set drop1 = dropcol.drop1, keep1 = dropcol.keep1, drop2 = dropcol.drop2, keep2 = dropcol.keep2
    returning *;
ERROR:  unexpected ON CONFLICT specification: 2
;
alter table dropcol drop column drop1, drop column drop2;
-- set using excluded
insert into dropcol(key, keep1, keep2) values(1, '4', 4) on conflict(key)
    do update set keep1 = excluded.keep1, keep2 = excluded.keep2
    where excluded.keep1 is not null and excluded.keep2 is not null
          and dropcol.keep1 is not null and dropcol.keep2 is not null
    returning *;
ERROR:  unexpected ON CONFLICT specification: 2
;
-- set using existing table
insert into dropcol(key, keep1, keep2) values(1, '5', 5) on conflict(key)
    do update set keep1 = dropcol.keep1, keep2 = dropcol.keep2
    returning *;
ERROR:  unexpected ON CONFLICT specification: 2
;
DROP TABLE dropcol;
-- check handling of regular btree constraint along with gist constraint
create table twoconstraints (f1 int unique, f2 box,
                             exclude using gist(f2 with &&)) with(dist_type=replication);
insert into twoconstraints values(1, '((0,0),(1,1))');
insert into twoconstraints values(1, '((2,2),(3,3))');  -- fail on f1
ERROR:  duplicate key value violates unique constraint "twoconstraints_f1_key"
DETAIL:  Key (f1)=(1) already exists.
insert into twoconstraints values(2, '((0,0),(1,2))');  -- fail on f2
ERROR:  conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
insert into twoconstraints values(2, '((0,0),(1,2))')
  on conflict on constraint twoconstraints_f1_key do nothing;  -- fail on f2
ERROR:  conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
insert into twoconstraints values(2, '((0,0),(1,2))')
  on conflict on constraint twoconstraints_f2_excl do nothing;  -- do nothing
select * from twoconstraints;
 f1 |     f2      
----+-------------
  1 | (1,1),(0,0)
(1 row)

drop table twoconstraints;
-- check handling of self-conflicts at various isolation levels
create table selfconflict (f1 int primary key, f2 int);
begin transaction isolation level read committed;
insert into selfconflict values (1,1), (1,2) on conflict do nothing;
commit;
begin transaction isolation level repeatable read;
insert into selfconflict values (2,1), (2,2) on conflict do nothing;
commit;
begin transaction isolation level serializable;
insert into selfconflict values (3,1), (3,2) on conflict do nothing;
commit;
begin transaction isolation level read committed;
insert into selfconflict values (4,1), (4,2) on conflict(f1) do update set f2 = 0;
ERROR:  unexpected ON CONFLICT specification: 2
commit;
begin transaction isolation level repeatable read;
insert into selfconflict values (5,1), (5,2) on conflict(f1) do update set f2 = 0;
ERROR:  unexpected ON CONFLICT specification: 2
commit;
begin transaction isolation level serializable;
insert into selfconflict values (6,1), (6,2) on conflict(f1) do update set f2 = 0;
ERROR:  unexpected ON CONFLICT specification: 2
commit;
select * from selfconflict;
 f1 | f2 
----+----
  1 |  1
  2 |  1
  3 |  1
(3 rows)

drop table selfconflict;
